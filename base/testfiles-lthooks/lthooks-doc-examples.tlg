This is a generated file for the l3build validation system.
Don't change this file in any respect.
**** Add to hook example-hook (top-level) on input line ... <- [code from 'top-level']
**** Add to hook example-hook (foo) on input line ... <- [code from package 'foo']
**** Add to hook example-hook (bar) on input line ... <- [from package 'bar']
**** Add to hook example-hook (baz) on input line ... <- [package 'baz' is here]
Update code for hook 'example-hook' on input line ...:
  normal rule foo|baz: > found
 default rule baz|bar: < found
Code labels for sorting:
 foo, bar and baz
Data structure for label rules:
 foo = 1 -> 
 bar = 1 -> 
 baz = 0 -> foo -> bar
Handled code for baz
Handled code for foo
Handled code for bar
==> Hook: 'example-hook'
> Code chunks:
>   'foo' -> [code from package 'foo']
>   'bar' -> [from package 'bar']
>   'baz' -> [package 'baz' is here]
>   'top-level' -> [code from 'top-level']
>   next-only -> [one-time code]
> Default rules:
>   'baz' before 'bar'
> Rules:
>   'foo' after 'baz'
> Execution order:
>   1: 'baz'
>   2: 'foo'
>   3: 'bar'
>   4: 'top-level'
>   5: next-only.
<recently read> }
l. ...\ShowHook{example-hook}
============================================
**** Add to hook myhook (packageA) on input line ... <- \typeout {A}
**** Add to hook myhook (packageB) on input line ... <- \typeout {B}
**** Add to hook myhook (packageC) on input line ... <- \typeout {C}
Update code for hook 'myhook' on input line ...:
Code labels for sorting:
 packageA, packageB and packageC
Data structure for label rules:
 packageA = 0 -> 
 packageB = 0 -> 
 packageC = 0 -> 
Handled code for packageA
Handled code for packageB
Handled code for packageC
==> Hook: 'myhook'
> Code chunks:
>   'packageA' -> \typeout {A}
>   'packageB' -> \typeout {B}
>   'packageC' -> \typeout {C}
> Execution order:
>   1: 'packageA'
>   2: 'packageB'
>   3: 'packageC'.
<recently read> }
l. ...\ShowHook{myhook}
============================================
Update code for hook 'myhook' on input line ...:
  normal rule packageB|packageA: > found
Code labels for sorting:
 packageA, packageB and packageC
Data structure for label rules:
 packageA = 0 -> packageB
 packageB = 1 -> 
 packageC = 0 -> 
Handled code for packageA
Handled code for packageC
Handled code for packageB
==> Hook: 'myhook'
> Code chunks:
>   'packageA' -> \typeout {A}
>   'packageB' -> \typeout {B}
>   'packageC' -> \typeout {C}
> Rules:
>   'packageB' after 'packageA'
> Execution order:
>   1: 'packageA'
>   2: 'packageC'
>   3: 'packageB'.
<recently read> }
l. ...\ShowHook{myhook}
============================================
**** Add to hook env/quote/before (package-1) on input line ... <- \begin {itshape}
**** Add to hook env/quote/after (package-1) on input line ... <- \end {itshape}
**** Add to hook env/quote/before (package-too) on input line ... <- \begin {color}{blue}
**** Add to hook env/quote/after (package-too) on input line ... <- \end {color}
Update code for hook 'env/quote/after' on input line ...:
Code labels for sorting:
 package-1 and package-too
Data structure for label rules:
 package-1 = 0 -> 
 package-too = 0 -> 
Handled code for package-1
Handled code for package-too
==> Hook: 'env/quote/after'
>   builtin generic, reversed
> Code chunks:
>   'package-1' -> \end {itshape}
>   'package-too' -> \end {color}
> Execution order:
>   1: 'package-too'
>   2: 'package-1'.
<recently read> }
l. ...\ShowHook{env/quote/after}
============================================
!!!! If this test changes the documentation needs updating !!!!
