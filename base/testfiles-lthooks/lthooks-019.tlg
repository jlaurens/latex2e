This is a generated file for the l3build validation system.
Don't change this file in any respect.
! LaTeX hooks Error: Hook 'yy' has already been declared.
For immediate help type H <return>.
 ...                                              
l. ...\NewReversedHook{yy}
                             % testing double declarations
There already exists a hook declaration with this name.
Please use a different name for your hook.
**** Add to hook xx (my1) on input line ... <- \typeout {A}
**** Add to hook xx (my1) on input line ... <- \typeout {A2}
**** Add to hook xx (my2) on input line ... <- \typeout {B}
**** Add to hook xx (my3) on input line ... <- \typeout {C}
**** Add to hook xx (my4) on input line ... <- \typeout {D}
**** Add to hook xx (my2) on input line ... <- \typeout {B2}
Update code for hook 'xx' on input line ...:
  normal rule my4|my2: < found
Code labels for sorting:
 my1, my2, my3 and my4
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> 
 my4 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my4
Handled code for my2
A
A2
C
D
B
B2
Update code for hook 'xx' on input line ...:
  normal rule my4|my2: < found
Code labels for sorting:
 my1, my2, my3 and my4
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> 
 my4 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my4
Handled code for my2
==> Hook: 'xx'
> Code chunks:
>   'my1' -> \typeout {A}\typeout {A2}
>   'my2' -> \typeout {B}\typeout {B2}
>   'my3' -> \typeout {C}
>   'my4' -> \typeout {D}
> Rules:
>   'my4' before 'my2'
> Execution order:
>   1: 'my1'
>   2: 'my3'
>   3: 'my4'
>   4: 'my2'.
Expected output: my1 my3 my4 my2
**** Add to hook yy (my1) on input line ... <- \typeout {A}
**** Add to hook yy (my1) on input line ... <- \typeout {A2}
**** Add to hook yy (my2) on input line ... <- \typeout {B}
**** Add to hook yy (my3) on input line ... <- \typeout {C}
**** Add to hook yy (my4) on input line ... <- \typeout {D}
**** Add to hook yy (my2) on input line ... <- \typeout {B2}
**** Add to hook yy (my5) on input line ... <- \typeout {C alternate}
Update code for hook 'yy' on input line ...:
  normal rule my4|my2: > found
  normal rule my5|my3: -> found
---> Drop 'my3' code from \g__hook_yy_code_prop because of 'my5'
Code labels for sorting:
 my1, my2, my3, my4 and my5
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> 
 my4 = 0 -> my2
 my5 = 0 -> 
Handled code for my1
Handled code for my3
Handled code for my4
Handled code for my5
Handled code for my2
B
B2
C alternate
D
A
A2
Update code for hook 'yy' on input line ...:
  normal rule my4|my2: > found
  normal rule my5|my3: -> found
---> Drop 'my3' code from \g__hook_yy_code_prop because of 'my5'
Code labels for sorting:
 my1, my2, my3, my4 and my5
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> 
 my4 = 0 -> my2
 my5 = 0 -> 
Handled code for my1
Handled code for my3
Handled code for my4
Handled code for my5
Handled code for my2
==> Hook: 'yy'
>   reversed
> Code chunks:
>   'my1' -> \typeout {A}\typeout {A2}
>   'my2' -> \typeout {B}\typeout {B2}
>   'my3' -> \typeout {C}
>   'my4' -> \typeout {D}
>   'my5' -> \typeout {C alternate}
> Rules:
>   'my4' after 'my2'
>   'my3' voids 'my5'
> Execution order:
>   1: 'my2'
>   2: 'my5'
>   3: 'my4'
>   4: 'my3'
>   5: 'my1'.
Expected output: my2, my5, my4, my3, my1
**** Add to hook env/quote/before (top-level) on input line ... <- \typeout {before A}
**** Add to hook env/quote/after (top-level) on input line ... <- \typeout {after A}
**** Add to hook env/quote/before (my1) on input line ... <- \typeout {before B}
**** Add to hook env/quote/after (my1) on input line ... <- \typeout {after B}
**** Add to hook env/quote/before (my2) on input line ... <- \typeout {before C}
**** Add to hook env/quote/after (my2) on input line ... <- \typeout {after C}
**** Add to hook env/quote/before (my3) on input line ... <- \typeout {before D}
**** Add to hook env/quote/after (my3) on input line ... <- \typeout {after D}
Update code for hook 'env/quote/before' on input line ...:
 default rule my3|my2: < found
Code labels for sorting:
 my1, my2 and my3
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my2
before B
before D
before C
before A
Update code for hook 'env/quote/before' on input line ...:
 default rule my3|my2: < found
Code labels for sorting:
 my1, my2 and my3
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my2
==> Hook: 'env/quote/before'
>   builtin generic
> Code chunks:
>   'my1' -> \typeout {before B}
>   'my2' -> \typeout {before C}
>   'my3' -> \typeout {before D}
>   'top-level' -> \typeout {before A}
> Default rules:
>   'my3' before 'my2'
> Execution order:
>   1: 'my1'
>   2: 'my3'
>   3: 'my2'
>   4: 'top-level'.
Expected output: my1, my3, my2
Update code for hook 'env/quote/after' on input line ...:
 default rule my3|my2: < found
Code labels for sorting:
 my1, my2 and my3
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my2
after A
after C
after D
after B
Update code for hook 'env/quote/after' on input line ...:
 default rule my3|my2: < found
Code labels for sorting:
 my1, my2 and my3
Data structure for label rules:
 my1 = 0 -> 
 my2 = 1 -> 
 my3 = 0 -> my2
Handled code for my1
Handled code for my3
Handled code for my2
==> Hook: 'env/quote/after'
>   builtin generic, reversed
> Code chunks:
>   'my1' -> \typeout {after B}
>   'my2' -> \typeout {after C}
>   'my3' -> \typeout {after D}
>   'top-level' -> \typeout {after A}
> Default rules, to be mirrored:
>   'my3' before 'my2'
> Execution order:
>   1: 'top-level'
>   2: 'my2'
>   3: 'my3'
>   4: 'my1'.
Expected output: my2, my3, my1
**** Add to hook Start (zz1) on input line ... <- \typeout {A}
**** Add to hook Start (zz2) on input line ... <- \typeout {B}
**** Add to hook Stop (zz1) on input line ... <- \typeout {A}
**** Add to hook Stop (zz2) on input line ... <- \typeout {B}
**** Add to hook Stop (zz3) on input line ... <- \typeout {C}
**** Add to hook Stop (zz4) on input line ... <- \typeout {D}
Update code for hook 'Start' on input line ...:
Code labels for sorting:
 zz1 and zz2
Data structure for label rules:
 zz1 = 0 -> 
 zz2 = 0 -> 
Handled code for zz1
Handled code for zz2
A
B
Update code for hook 'Stop' on input line ...:
Code labels for sorting:
 zz1, zz2, zz3 and zz4
Data structure for label rules:
 zz1 = 0 -> 
 zz2 = 0 -> 
 zz3 = 0 -> 
 zz4 = 0 -> 
Handled code for zz1
Handled code for zz2
Handled code for zz3
Handled code for zz4
D
C
B
A
Update code for hook 'Start' on input line ...:
Code labels for sorting:
 zz1 and zz2
Data structure for label rules:
 zz1 = 0 -> 
 zz2 = 0 -> 
Handled code for zz1
Handled code for zz2
==> Hook: 'Start'
> Code chunks:
>   'zz1' -> \typeout {A}
>   'zz2' -> \typeout {B}
> Execution order:
>   1: 'zz1'
>   2: 'zz2'.
Update code for hook 'Stop' on input line ...:
Code labels for sorting:
 zz1, zz2, zz3 and zz4
Data structure for label rules:
 zz1 = 0 -> 
 zz2 = 0 -> 
 zz3 = 0 -> 
 zz4 = 0 -> 
Handled code for zz1
Handled code for zz2
Handled code for zz3
Handled code for zz4
==> Hook: 'Stop'
>   reversed
> Code chunks:
>   'zz1' -> \typeout {A}
>   'zz2' -> \typeout {B}
>   'zz3' -> \typeout {C}
>   'zz4' -> \typeout {D}
> Execution order:
>   1: 'zz4'
>   2: 'zz3'
>   3: 'zz2'
>   4: 'zz1'.
Update code for hook 'Stop' on input line ...:
  normal rule zz4|zz3: > found
Code labels for sorting:
 zz1, zz2, zz3 and zz4
Data structure for label rules:
 zz1 = 0 -> 
 zz2 = 0 -> 
 zz3 = 1 -> 
 zz4 = 0 -> zz3
Handled code for zz1
Handled code for zz2
Handled code for zz4
Handled code for zz3
==> Hook: 'Stop'
>   reversed
> Code chunks:
>   'zz1' -> \typeout {A}
>   'zz2' -> \typeout {B}
>   'zz3' -> \typeout {C}
>   'zz4' -> \typeout {D}
> Rules:
>   'zz4' after 'zz3'
> Execution order:
>   1: 'zz3'
>   2: 'zz4'
>   3: 'zz2'
>   4: 'zz1'.
Update code for hook 'Start' on input line ...:
==> Hook: 'Start'
>   empty.
Update code for hook 'Stop' on input line ...:
==> Hook: 'Stop'
>   reversed.
**** Add to hook Start (one) on input line ... <- \typeout {begin A}
**** Add to hook Start (one) on input line ... <- \typeout {begin B}
**** Add to hook Start (one) on input line ... <- \typeout {begin C}
**** Add to hook Stop (one) on input line ... <- \typeout {end C}
**** Add to hook Stop (one) on input line ... <- \typeout {end B}
**** Add to hook Stop (one) on input line ... <- \typeout {end A}
Update code for hook 'Start' on input line ...:
Code labels for sorting:
 one
Data structure for label rules:
 one = 0 -> 
Handled code for one
begin A
begin B
begin C
Update code for hook 'Stop' on input line ...:
Code labels for sorting:
 one
Data structure for label rules:
 one = 0 -> 
Handled code for one
end C
end B
end A
Update code for hook 'Start' on input line ...:
Code labels for sorting:
 one
Data structure for label rules:
 one = 0 -> 
Handled code for one
==> Hook: 'Start'
> Code chunks:
>   'one' -> \typeout {begin A}\typeout {begin B}\typeout {begin C}
> Execution order:
>   1: 'one'.
Update code for hook 'Stop' on input line ...:
Code labels for sorting:
 one
Data structure for label rules:
 one = 0 -> 
Handled code for one
==> Hook: 'Stop'
>   reversed
> Code chunks:
>   'one' -> \typeout {end C}\typeout {end B}\typeout {end A}
> Execution order:
>   1: 'one'.
**** Add to hook Start (zz1) on input line ... <- \typeout {A}
**** Add to hook Start (zz2) on input line ... <- \typeout {B}
**** Add to hook Start (zz3) on input line ... <- \typeout {C}
**** Add to hook Stop (zz1) on input line ... <- \typeout {A}
**** Add to hook Stop (zz2) on input line ... <- \typeout {B}
**** Add to hook Stop (zz3) on input line ... <- \typeout {C}
Update code for hook 'Start' on input line ...:
 default rule zz2|zz1: < found
 default rule zz3|zz1: > found
Code labels for sorting:
 zz1, zz2 and zz3
Data structure for label rules:
 zz1 = 1 -> zz3
 zz2 = 0 -> zz1
 zz3 = 1 -> 
Handled code for zz2
Handled code for zz1
Handled code for zz3
B
A
C
Update code for hook 'Stop' on input line ...:
 default rule zz2|zz1: < found
 default rule zz3|zz1: > found
Code labels for sorting:
 zz1, zz2 and zz3
Data structure for label rules:
 zz1 = 1 -> zz3
 zz2 = 0 -> zz1
 zz3 = 1 -> 
Handled code for zz2
Handled code for zz1
Handled code for zz3
C
A
B
Update code for hook 'Start' on input line ...:
 default rule zz2|zz1: < found
 default rule zz3|zz1: > found
Code labels for sorting:
 zz1, zz2 and zz3
Data structure for label rules:
 zz1 = 1 -> zz3
 zz2 = 0 -> zz1
 zz3 = 1 -> 
Handled code for zz2
Handled code for zz1
Handled code for zz3
==> Hook: 'Start'
> Code chunks:
>   'zz1' -> \typeout {A}
>   'zz2' -> \typeout {B}
>   'zz3' -> \typeout {C}
> Default rules:
>   'zz2' before 'zz1'
>   'zz3' after 'zz1'
> Execution order:
>   1: 'zz2'
>   2: 'zz1'
>   3: 'zz3'.
Update code for hook 'Stop' on input line ...:
 default rule zz2|zz1: < found
 default rule zz3|zz1: > found
Code labels for sorting:
 zz1, zz2 and zz3
Data structure for label rules:
 zz1 = 1 -> zz3
 zz2 = 0 -> zz1
 zz3 = 1 -> 
Handled code for zz2
Handled code for zz1
Handled code for zz3
==> Hook: 'Stop'
>   reversed
> Code chunks:
>   'zz1' -> \typeout {A}
>   'zz2' -> \typeout {B}
>   'zz3' -> \typeout {C}
> Default rules, to be mirrored:
>   'zz2' before 'zz1'
>   'zz3' after 'zz1'
> Execution order:
>   1: 'zz3'
>   2: 'zz1'
>   3: 'zz2'.
