\input{regression-test}

\ExplSyntaxOn
\debug_on:n { check-declarations , deprecation }
\ExplSyntaxOff

\documentclass{article}

% There are many different hook profiles.

\START

\BEGINTEST{Generic}
  \BEGINTEST{builtin}
    \BEGINTEST{Raw generic hook}
      \DebugPrintHook{cmd/?/before} % generic
    \ENDTEST
    \BEGINTEST{Automatically activated by \AddToHook}
      \AddToHook{cmd/?/before}{\TYPE{...}}
      \DebugPrintHook{cmd/?/before}
    \ENDTEST
    \BEGINTEST{Disabled}
      \DisableGenericHook{cmd/?/before}
      \DebugPrintHook{cmd/?/before}
    \ENDTEST
    \BEGINTEST{Reversed}
      \DebugPrintHook{cmd/?/after} % generic
    \ENDTEST
    \BEGINTEST{Automatically activated by \AddToHook}
      \AddToHook{cmd/?/after}{\TYPE{...}}
      \DebugPrintHook{cmd/?/after}
    \ENDTEST
    \BEGINTEST{Deprecated generic}
      \DebugPrintHook{file/before/...} % 
    \ENDTEST
  \ENDTEST
  \BEGINTEST{Custom}
    \BEGINTEST{Before and after \ActivateGenericHook}
      \DebugPrintHook{Custom}
      \ActivateGenericHook{Custom}
      \DebugPrintHook{Custom}
    \ENDTEST
    \BEGINTEST{\DisableGenericHook}
    \ENDTEST
      \DisableGenericHook{Custom}
      \DebugPrintHook{Custom}
  \ENDTEST
\ENDTEST

\BEGINTEST{One-time}
  \def\TEST#1{%
    \BEGINTEST{One-time/#1}
      \UseOneTimeHook{One-time/#1}
      \DebugPrintHook{One-time/#1}
    \ENDTEST
  }
  \NewHook{One-time/basic}
  \TEST{basic}
  \NewReversedHook{One-time/reverse}
  \TEST{reverse}
  \def\TEST#1{%
    \BEGINTEST{One-time/#1}
      \UseOneTimeHookWithArguments{One-time/#1}{2}{arg_1}{arg_2}
      \DebugPrintHook{One-time/#1}
    \ENDTEST
  }
  \NewHookWithArguments{One-time/arguments}{2}
  \TEST{arguments}
  \NewReversedHookWithArguments{One-time/reverse/arguments}{2}
  \TEST{reverse/arguments}
\ENDTEST

\BEGINTEST{Code chunks}
  \def\TEST#1{%
    \BEGINTEST{Code chunks/#1}
      \AddToHook{Code chunks/#1}[top-level]{\TYPE{TOP-LEVEL}}
      \AddToHook{Code chunks/#1}[LABEL_A]{\TYPE{CODE_A}}
      \AddToHook{Code chunks/#1}[LABEL_B]{\TYPE{CODE_B}}
      \AddToHook{Code chunks/#1}[LABEL_C]{\TYPE{CODE_C}}
      \AddToHookNext{Code chunks/#1}{\TYPE{NEXT-ONLY}}
      \DebugPrintHook{Code chunks/#1}
    \ENDTEST
  }
  \NewHook{Code chunks/Normal}
  \TEST{Normal}
  \NewReversedHook{Code chunks/Reversed}
  \TEST{Reversed}
  \def\TEST#1{%
    \BEGINTEST{Code chunks/#1}
      \AddToHookWithArguments{Code chunks/#1}[top-level]{\TYPE{TOP-LEVEL}}
      \AddToHookWithArguments{Code chunks/#1}[LABEL_A]{\TYPE{CODE_A}}
      \AddToHookWithArguments{Code chunks/#1}[LABEL_B]{\TYPE{CODE_B}}
      \AddToHookWithArguments{Code chunks/#1}[LABEL_C]{\TYPE{CODE_C}}
      \AddToHookWithArguments{Code chunks/#1}{\TYPE{NEXT-ONLY}}
      \DebugPrintHook{Code chunks/#1}
    \ENDTEST
  }
  \NewHookWithArguments{Code chunks/With arguments}{2}
  \TEST{With arguments}
  \NewReversedHookWithArguments{Code chunks/Reversed with arguments}{2}
  \TEST{Reversed with arguments}
\ENDTEST

\BEGINTEST{Rules}
  \NewHook{Rules}
  \AddToHook{Rules}[LABEL_A]{\TYPE{CODE_A}}
  \AddToHook{Rules}[LABEL_B]{\TYPE{CODE_B}}
  \AddToHook{Rules}[LABEL_C]{\TYPE{CODE_C}}
  \DeclareDefaultHookRule{LABEL_A}<{LABEL_B}
  \DeclareDefaultHookRule{LABEL_B}<{LABEL_C}
  \DeclareDefaultHookRule{LABEL_C}>{LABEL_A}
  \DeclareHookRule{Rules}{LABEL_A}>{LABEL_B}
  \DeclareHookRule{Rules}{LABEL_B}>{LABEL_C}
  \DeclareHookRule{Rules}{LABEL_C}<{LABEL_A}
  \BEGINTEST{Named rules override default ones}
    \DebugPrintHook{Rules}
  \ENDTEST
  \DeclareHookRule{Rules}{LABEL_A}{unrelated}{LABEL_B}
  \DeclareHookRule{Rules}{LABEL_B}{unrelated}{LABEL_C}
  \DeclareHookRule{Rules}{LABEL_C}{unrelated}{LABEL_A}
  \BEGINTEST{Default rules}
    \DebugPrintHook{Rules}
  \ENDTEST
\ENDTEST

\TYPE{!!!! If this test changes the documentation needs updating !!!!}

\END
