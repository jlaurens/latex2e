% \iffalse meta-comment
%
% Copyright (C) 2020-2023
%       Frank Mittelbach, Phelype Oleinik, The LaTeX Project
%
% This file is part of the LaTeX base system.
% -------------------------------------------
%
% It may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%    https://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008 or later.
%
% This file has the LPPL maintenance status "maintained".
%
% The list of all files belonging to the LaTeX base distribution is
% given in the file `manifest.txt'. See also `legal.txt' for additional
% information.
%
% The list of derived (unpacked) files belonging to the distribution
% and covered by LPPL is defined by the unpacking scripts (with
% extension .ins) which are part of the distribution.
%
% \fi
%
% \iffalse
%
%%% From File: lthooks.dtx
%
%    \begin{macrocode}
\def\lthooksversion{v1.1f}
\def\lthooksdate{2023/12/26}
%    \end{macrocode}
%
%<*driver>
\documentclass{l3doc}

\providecommand\InternalDetectionOff{}
\providecommand\InternalDetectionOn{}

\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{lthooks.dtx}
\end{document}
%</driver>
%
% \fi
%
% \providecommand\metatt[1]{\texttt{\meta{#1}}}
% \ExplSyntaxOn
% \cs_new:Npn \LHXVert {|}
% ^^A material to typeset code chunks
% \tl_new:N \l__lthooks_tl
% \int_new:N \l__lthooks_int
% \AddToHook{env/syntax/begin}{
%   \def\SEP{\smash{\rule[-\dp\strutbox]{1pt}{\baselineskip}}\phantom{x}}
%   \def\TAB{\phantom{xx}}
%   \def\FILL#1{\prg_replicate:nn{38-(#1)}{~}}
%   \def\FILLER{\phantom{\prg_replicate:nn{9}{xxxx}xxx}}
%   \def\LEFT#1{\leavevmode\rlap{#1}\FILLER}
%   \def\RIGHT#1{\SEP#1}
%   \cs_set_eq:NN \meta_saved:n \meta
%   \def\meta#1{^^A
%     \tl_set:Nn \l__lthooks_tl { #1 }
%     \hbox_set:Nn \l_tmpa_box { \meta_saved:n { #1 } }
%     \hbox_set:Nn \l_tmpb_box { x }
%     \int_set:Nn \l__lthooks_int { \int_div_truncate:nn
%       { \box_wd:N \l_tmpa_box  }
%       { \box_wd:N \l_tmpb_box  }
%     }
%     \fp_compare:nNnT
%       { \l__lthooks_int * \box_wd:N \l_tmpb_box }
%       < 
%       { \box_wd:N \l_tmpa_box }
%       { \int_incr:N \l__lthooks_int }
%     \makebox[ \l__lthooks_int \box_wd:N \l_tmpb_box ][c]
%       { \box_use:N \l_tmpa_box }
%   }
% }
% \int_new:N \l__lthooks_source_int
% \hook_new:n {lthooksCode/lineno.format}
% \hook_gput_code:nnn
%   {lthooksCode/lineno.format}
%   {lthooksCode/default}
%   {\sffamily\tiny}
% \makeatletter
% \NewDocumentEnvironment{lthooksCode}{O{}} {
%   \keys_define:nn { lthooksCode } {
%     lineno .bool_set:N = \l__lthooks_source_lineno_bool,
%     lineno .default:n  = true,
%     no-lineno .bool_set_inverse:N = \l__lthooks_source_lineno_bool,
%     first  .int_set:N  = \l__lthooks_source_int,
%   }
%   \keys_set:nn { lthooksCode } {first=1, lineno=false, #1 }
%   \cs_set:Npn\SEP{\rule[-\dp\strutbox]{1pt}{\baselineskip}~~}
%   \cs_set:Npn\TAB{\phantom{xx}}
%   \cs_set_eq:NN\IT\textit
%   \bool_if:NF \c_true_bool { FAIL }
%   \bool_if:NT \c_false_bool { FAIL }
%   \bool_if:NTF \l__lthooks_source_lineno_bool {
%     \keys_define:nn { lthooksCode.ROW } {
%       format  .code:n  = \hook_gput_next_code:nn
%         { lthooksCode/lineno.format }
%         { ##1 },
%       mark  .tl_set:N  = \l__lthooks_source_mark_tl,
%       mark  .initial:n = ,
%       label .tl_set:N  = \l__lthooks_label_tl,
%     }
%     \NewDocumentCommand\ROW{O{}}{
%       \keys_define:nn { lthooksCode.ROW } {
%         mark .initial:n = ,
%       }
%       \keys_set:nn { lthooksCode.ROW } { label=, ##1, }
%       \makebox[0pt][r]{\textcolor[gray]{0.5}{
%         \hook_use:n { lthooksCode/lineno.format }
%         \l__lthooks_source_mark_tl
%         \int_use:N \l__lthooks_source_int
%       }\hphantom{x}}
%       \tl_if_empty:NF \l__lthooks_label_tl {
%         \tl_set:Nx \@currentlabel { \int_use:N \l__lthooks_source_int }
%         \phantomsection
%         \label{ \l__lthooks_label_tl }
%       }
%       \int_incr:N \l__lthooks_source_int
%       \TAB
%     }
%   } {
%     \cs_set:Npn\ROW{
%       \TAB
%     }
%   }
%   \begin{flushleft}\ttfamily\small
%   \UseHook{env/syntax/begin}
%   \def\FILL##1{\prg_replicate:nn{37-(##1)}{~}}
%   \def\FILLER{\phantom{\prg_replicate:nn{9}{xxxx}xxx}}
% }{
%   \end{flushleft}
% }
% \makeatother
% \let \lthookslangle \langle
% \let \lthooksrangle \rangle
% \let \META \meta
% \providecommand\META[1]{{
%   \def\langle{
%     \mbox{\ensuremath\lthookslangle \hskip-0.5ex \ensuremath\lthookslangle}
%   }
%   \def\rangle{
%     \mbox{\ensuremath\lthooksrangle \hskip-0.5ex \ensuremath\lthooksrangle}
%   }
%   \meta{#1}
% }}
%
% \ExplSyntaxOff
%
% \providecommand\LHXStar{$^{\text{*}}$}
% \providecommand\LHXLabel[1]{\texttt{#1}}
% \providecommand\hook[1]{\texttt{#1}}
%
% \providecommand\fmi[1]{\marginpar{\footnotesize FMi: #1}}
% \providecommand\fmiinline[1]{\begin{quote}\itshape\footnotesize FMi: #1\end{quote}}
% \providecommand\pho[1]{\marginpar{\footnotesize PhO: #1}}
% \providecommand\phoinline[1]{\begin{quote}\itshape\footnotesize PhO: #1\end{quote}}
%
% \providecommand\JLNote[1]{^^A
%   \marginpar{\footnotesize\colorbox{yellow}{\begin{minipage}[t]{3.75cm}\flushleft JL: #1\end{minipage}}\ignorespaces}^^A
% }
%
%
% \title{\LaTeX{}'s hook management\thanks{This module has version
%    \lthooksversion\ dated \lthooksdate, \copyright\ \LaTeX\
%    Project.}}
%
% \author{Frank Mittelbach\thanks{Code improvements for speed and other goodies by Phelype Oleinik}}
%
% \maketitle
%
% \tableofcontents
%
%
% \section{Presentation}
% In \LaTeX, commands are created as a whole. If one wants to alter
% someone's else command to better suit its own needs, one has generally
% to redefine the command, which can be very tricky. During times,
% package writers have elaborated various techniques to make their
% commands customizable, by users as well as other packages. This lead
% to a very complex situation with many incompatibilities.
%
% The \LaTeX\ hook system is a unified way to modify commands by controlling
% more precisely what is executed and when. It allows to write more
% compatible code, and lowers the risk of breaking things. Not only does it
% replaces elegantly old techniques, it opens new possibilities in writing
% new powerful and reliable code.
%
% \subsection{Introductory example}
% \label{sec:Introductory-example}
% Typesetting next \LaTeX\ document with its explanatory comments introduces
% better than words the notion of \LaTeX\ hook\footnote{A \LaTeX\ hook
% corresponds to a hooking in computer programming.} and the related
% workflow. It does not produce any output and only relies on $6$ hook related
% commands as well as |\typein| and |\typeout| to interact with the terminal.
% Just press the enter key to continue processing when necessary.
%
% \begin{lthooksCode}[lineno]
% \ROW{|\documentclass{article}|}\\
% \ROW[format=\bfseries,mark=$\to$\;,label=line:A-1,
%   ]\cs{ShowHook}|{MyName}          %|
% \IT{Show the hook named }|"MyName"|\\
% \ROW[format=\bfseries,mark=$\to$\;,label=line:A-3,
%   ]{\cs{AddToHook}|{begindocument}  %|}
% \IT{Add to the hook named }|"begindocument"...|\\
% \ROW{|  {\typeout{BEGIN}}        %  |}
% \IT{the code }|"\typeout{BEGIN}"|\\
% \ROW[label=line:A-2,]\cs{ShowHook}|{begindocument}|\\
% \ROW{|\begin{document}|}\\
% \ROW{|\typein{Press enter}|}\\
% \ROW[label=line:A-4,]{\cs{ShowHook}|{env/quote/begin}|}\\
% \ROW[format=\bfseries,mark=$\to$\;,
%   ]{\cs{NewHook}|{MyName}           %|}
% \IT{Declare the new hook named }|"MyName"|\\
% \ROW[format=\bfseries,mark=$\to$\;,
%   ]{\cs{AddToHookNext}|{MyName}     %|}
% \IT{Add to the hook named }|"MyName"...|\\
% \ROW{|  {\typeout{NEXT}}         %  |}
% \IT{the code }|"\typeout{NEXT}"|\IT{ for next use only}\\
% \ROW[label=line:A-5,]{\cs{ShowHook}|{MyName}|}\\
% \ROW[format=\bfseries,mark=$\to$\;,label=line:A-6,
%     ]{\cs{UseHook}|{MyName}           %|}
% \IT{Use the hook named }|"MyName"|\\
% \ROW[label=line:A-7,]{\cs{ShowHook}|{MyName}|}\\
% \ROW[format=\bfseries,mark=$\to$\;,]{\cs{AddToHook}|{MyName}         %|}
% \IT{Add to the hook named }|"MyName"...|\\
% \ROW{|  [labelA]{\typeout{A}}    %  |}
% \IT{the code }|"\typeout{A}"|\IT{ labeled }|"labelA"|\\
% \ROW{\cs{AddToHook}|{MyName}[labelB]{\typeout{B}}   %|}
% \IT{Same for B}\\
% \ROW{\cs{AddToHook}|{MyName}[labelC]{\typeout{C}}   %|}
% \IT{Same for C}\\
% \ROW[label=line:A-8,]{\cs{ShowHook}|{MyName}|}\\
% \ROW{\cs{UseHook}|{MyName}|}\\
% \ROW{|\typein{Press enter}|}\\
% \ROW[format=\bfseries,mark=$\to$\;,label=line:A-9,
%     ]{\cs{DeclareHookRule}|{MyName}|}|   %|
% \IT{Declare a rule for hook }|"MyName"|\IT{ stating that...}\\
% \ROW|  {labelC}{before}{labelA} %  |
% \IT{code for }|"labelC"|\IT{ goes before code for }|"labelA"|\\
% \ROW[label=line:A-10,]{\cs{ShowHook}|{MyName}|}\\
% \ROW{\cs{UseHook}|{MyName}|}\\
% \ROW{|\end{document}|}\\
% \end{lthooksCode}
% The typesetting process first stops at line \ref{line:A-1} and the terminal
% reads
% \begin{lthooksCode}
% \ROW|==> Hook: 'MyName'|\\
% \ROW|>   not declared.|\\
% \end{lthooksCode}
% The hook name \hook{MyName} is not declared.
% Next stop is at line \ref{line:A-2} and the terminal reads
% \begin{lthooksCode}
% \ROW|==> Hook: 'begindocument'|\\
% \ROW|> Code chunks:|\\
% \ROW|>   'top-level' -> \typeout {BEGIN}|\\
% \ROW|> Execution order:|\\
% \ROW|>   1: 'top-level'.|\\
% \end{lthooksCode}
% This \hook{begindocument} hook is declared in \LaTeX, it is related to
% |begin{document}| and detailed in section \ref{sec:begindocument-hooks}.
% The code we added at line \ref{line:A-3} appears with the special label
% \LHXLabel{top-level}. The next stop occurs just after
% |begin{document}|, the code we added to the hook has executed and
% the terminal reads |BEGIN|. More precisely, we are sure that all code added
% to the \hook{begindocument} hook will execute after all the packages have
% complete loading.
%
% Next stop is at line \ref{line:A-4} and the terminal reads
% \begin{lthooksCode}
% \ROW|==> Hook: 'env/quote/begin'|\\
% \ROW|>   builtin generic.|\\
% \end{lthooksCode}
% This hook is related to the \LaTeX\ environment |quote|. Every environment
% or command has special hooks that are more flexible: the
% generic hooks detailed in section \ref{sec:generic}. For example, with
% \begin{lthooksCode}
% \ROW\cs{AddToHook}|{env/quote/begin}{\color{red}}|
% \end{lthooksCode}
% all the forthcoming |quote| environments will be typeset in red,
% provided the proper color management package is loaded beforehands.
%
% Next stop is at line \ref{line:A-5} and the terminal reads
% \begin{lthooksCode}
% \ROW|==> Hook: 'MyName'|\\
% \ROW|> Code chunks:|\\
% \ROW|>   next-only -> \typeout {NEXT}|\\
% \ROW|> Execution order:|\\
% \ROW|>   1: next-only.|\\
% \end{lthooksCode}
% On next stop at the following line, the terminal reads |NEXT| because
% the |\typeout{NEXT}| instruction was executed by |\UseHook{MyName}|.
% After, the \hook{MyName} hook is empty because the added code has then
% been removed. This special behavior offers subtle coding patterns detailed
% in section \ref{sec:One-time-hooks}.
% 
% On next stop at line \ref{line:A-8}, the terminal reads:
% \begin{lthooksCode}
% \ROW|==> Hook: 'MyName'|\\
% \ROW|> Code chunks:|\\
% \ROW|>   'labelA' -> \typeout {A}|\\
% \ROW|>   'labelB' -> \typeout {B}|\\
% \ROW|>   'labelC' -> \typeout {C}|\\
% \ROW|> Execution order:|\\
% \ROW|>   1: 'labelA'|\\
% \ROW|>   2: 'labelB'|\\
% \ROW|>   3: 'labelC'.|\\
% \end{lthooksCode}
% After line \ref{line:A-8}, the three instructions |\typeout{A}|,
% |\typeout{B}| and  |\typeout{C}| were executed and |A|, |B|, |C| are
% displayed in the terminal.
% On line \ref{line:A-9}, we declare a rule that affects the execution order:
% \begin{lthooksCode}
% \ROW|==> Hook: 'MyName'|\\
% \ROW|> Code chunks:|\\
% \ROW|>   ...|\\
% \ROW|> Rules:|\\
% \ROW|>   'labelC' before 'labelA'|\\
% \ROW|> Execution order:|\\
% \ROW|>   1: 'labelB'|\\
% \ROW|>   2: 'labelC'|\\
% \ROW|>   3: 'labelA'.|\\
% \end{lthooksCode}
% and the terminal finally reads |B|, |C|, |A| instead of |A|, |B|, |C|.
%
% \subsection{Basic description}
% A \LaTeX\ hook is uniquely identified by a string: its \emph{name}.
% Hooks have labeled code chunks, all of which being persistent and
% run every time the hook is used, when declared or enabled.
% They also have momentary code run only on the next use
% and definitely discarded afterwards.
% All the code chunks are executed in a well defined order that
% one can control by declaring rules.
% 
% However, hooks are not a panacea. For example, if you want a
% |quote| environment with a different indentation, then you can
% define a new environment mimicking quote with appropriate settings
% or use a dedicated package, but hooks are of no help here.
% Moreover, hooks cannot be used in every place because they can break
% actual code as illustrated in section \ref{sec:Generic-hooks-for-commands}.
%
% \subsection{Collaborative work}
% \label{sec:Collaborative-work}
%
% \LaTeX\ hooks are managed at the global \TeX\ level, therefore
% great care should be taken such that no code breaks unintentionally.
% Next conventions should be followed for that purpose in production
% code. For the sake of simplicity, a \emph{\LaTeX\ object} denotes a
% package, a class, the top level document or even \LaTeX\ itself,
% it is more generally a \emph{logical unit}.
% \begin{itemize}
% \item A \emph{hook owner} is the \LaTeX\ object that defines both
% the hook name and purpose. Each hook should have only one owner.
% For example \hook{env/quote/begin} and \hook{begindocument} are owned by
% \LaTeX. In general, the owner declares the hook.
% \item A \emph{hook user} is a \LaTeX\ object that defines when the
% hook is used, by executing \cs{UseHook} command or similar.
% The owner can also be a user of the hook, just like \LaTeX\ is also the
% user of the \hook{env/quote/begin} hook.
% When explicitely mentionned, other users are prohibited.
% The same may also hold implicitely: \cs{UseHook}|{begindocument}| makes
% little sense out of \LaTeX\ private internals.
% \item For any given hook, a \emph{label owner} is a \LaTeX\ object
% that adds code to a hook, through \cs{AddToHook} command or similar,
% with a given label.
% A \LaTeX\ object can own many different labels, but each label must
% have only one owner. Moreover, no \LaTeX\ object except the 
% label owner should modify the associate code chunk.
% \end{itemize}
% In order to avoid collisions and melting unrelating code,
% hook names and code labels should follow the naming scheme:
% \enquote{\texttt{\META{root}\META{components}}}
% where \META{components} is a possibly empty list of \enquote{\texttt
% {/\META{component}}} and \META{root} is
% \begin{itemize}
% \item \enquote{\texttt{\META{package name}}}
% if the owner is a package,
% \item \enquote{\texttt{\META{class name}/class}}
% if the owner is a class,
% \item \enquote{\texttt{top-level}} if the owner is a document.
% \end{itemize}
% That way, the owner of a hook or a label is clearly identified.
%
% Hooks intended for public use should be properly documented and
% changing their name in new versions should come with a deprecation
% error message to help in transition.
% Moreover, the use of a code label with components on a public
% hook should be properly documented to give third parties a chance
% to order code properly, without digging into the source code.
% Any future change to this label should be documented as well.
%
%
% \subsection{Private work}
%
% The \LaTeX\ hook management system provides us with a different pattern
% to define commands and environments, focusing essentially on the mutability
% of the definitions. Moreover they can be defined asynchronously, meaning
% that the real code may be defined at different places outside
% \cs{newcommand} and alike:
% \begin{lthooksCode}
% \ROW\cs{NewHook}|{foo/private/A}|\\
% \ROW\cs{NewHook}|{foo/private/B}|\\
% \ROW|\newcommand{\foo}|\\
% \ROW\TAB\{\meta{...}|\UseHook{foo/private/A}|^^A
% \meta{...}|\UseHook{foo/private/B}|\meta{...}\}\\
% \ROW\meta{...}\\
% \ROW\cs{AddToHook}|{foo/private/A}{|\meta{...}|}|\\
% \ROW\meta{...}\\
% \ROW\cs{AddToHook}|{foo/private/B}{|\meta{...}|}|\\
% \ROW\meta{...}\\
% \ROW\cs[no-index]{foo}\\
% \end{lthooksCode}
%
% In that case, hooks are part of a private
% implementation and their names should contain a \enquote{|/private|}
% component, as well as the name of the environment or command. The hook
% owner, hook users, label owners are the same \LaTeX\ object.
%
%
% \section{Developer interface}
%
%    The hook management system is offered as a set of CamelCase
%    commands for traditional \LaTeXe{} packages (and for use in the
%    document preamble if needed) as well as \texttt{expl3} commands
%    for modern packages, that use the L3 programming layer of
%    \LaTeX{}. Behind the scene, a single set of data structures is
%    accessed so that packages from both worlds can coexist and access
%    hooks in other packages.
%
% All operations that modify hooks take place at the global \TeX\
% level, whereas hooks are executed in the
% current \TeX\ group.
%
% \subsection{Conventions and command arguments}
% \label{sec:Command-arguments}
% In the sequel
% \begin{arguments}
% \item[\meta{hook}] denotes a string with only inner space characters,
%   It represents a \emph{hook name}.
%   The special value \enquote{|??|} stands for \emph{any hook name}.
% \item[\meta{label}] also denotes a string with only inner space characters.
%   It represents a \emph{code chunk label}.
%   The special values \enquote{|top-level|} and \enquote{|*|} are detailed below
%   whereas \enquote{|0|} is reserved for internal use.
% \end{arguments}
% 
% The command arguments are mainly one of the following.
% \begin{arguments}
% \item[\meta{hook-name}:] on execution, outer spaces are trimmed,
% then full expansion occurs until only spaces and character tokens
% remain, including unicode characters.
% The result is the hook name denoted by \meta{hook}.
% If a non-expandable non-character token still remains,
% a low-level \TeX{} error is raised.
% If you need names with heading or trailing spaces,
% use |\space| or another brace level.
%
% \item[\meta{hook-name\LHXStar}:] same as \meta{hook-name},
% except than for speed, outer spaces are not trimmed.
%
% \item[\meta{hook-spec}:] a hook name specifier.
% The argument is first treated like \meta{hook-name}.
% If the result is a single dot \enquote{|.|} or starts with
% \enquote{|./|} the leading dot is replaced by the
% \meta{current name}, which is generally the package name,
% the class name or the reserved keyword \enquote{|top-level|}.
% A \enquote{|.|} anywhere else is treated literally and is not
% replaced. See section \ref{sec:Managing-the-current-name} to manage the
%  \meta{current name}.
% The end result is the hook name denoted by \meta{hook}.
%
%
% \item[\meta{label-spec}:] a code chunk label specifier,
% treated exactly like \meta{hook-spec} on execution.
% The result is the code chunk label denoted by \meta{label}.
% This argument is required for L3 commands
% but optional for \LaTeXe\ commands. It then defaults to
% \enquote{|.|} which is replaced by \meta{current name}.
% We therefore suggest to use the leading dot shortcut detailed for
% above \meta{hook-spec} whenever possible.
%
% \item[\meta{code}:] any \LaTeX\ code chunk.
% \item[\meta{\#\ code}:] any \LaTeX\ code chunk where
% \enquote{\texttt{\#\meta{i}}} refers to actual argument number
% \meta{i}. The parameter tokens \enquote{\texttt{\#}$_6$} should be
% doubled when not referring to actual arguments.
% \end{arguments}
%
% \subsection{Managing labeled code chunks}
%
% Hooks have persistent code run every time they are executed.
%
% \begin{function}{
%   \AddToHook,
%   \hook_gput_code:nnn,
% }
%   \begin{syntax}
%     \cs{AddToHook}\Arg{hook-spec}\oarg{label-spec}\Arg{code}
%     \cs{hook_gput_code:nnn} \Arg{hook-spec} \Arg{label-spec} \Arg{code}
%   \end{syntax}
%    For one time hooks already consumed executes \meta{code}
%    immediately (see \cs{UseOneTime...} commands).
%    Otherwise persistently adds \meta{code} labeled after
%    \meta{label-spec} to the specified hook.
%    If the hook is never executed or never declared, when not
%    generic or not disabled, \meta{code} will never be executed.
%    There is no restriction on the hook prior to executing
%    \cs{AddToHook}. This allows to modify the code for a hook
%    defined by some package, even in documents that do not
%    use the package.
% \end{function}
%
%    For practical reasons, the addition is cumulative in the sense
% that after
%    \begin{lthooksCode}
% \ROW\cs{AddToHook}|{myHook}[myLabel]|\Arg{code_1}\\
% \ROW\cs{AddToHook}|{myHook}[myLabel]|\Arg{code_2}
%    \end{lthooksCode}
%    the code chunk is the same than after
%    \begin{lthooksCode}
% \ROW\cs{AddToHook}|{myHook}[myLabel]{|\meta{code_1}\meta{code_2}|}|
%    \end{lthooksCode}
%    and only the first effective addition is relevant in code ordering,
%    see section \ref{sec:Ordering-code-execution}.
%
%    As a consequence, it is not straightforward to replace or
%    remove just one \meta{code}, the \cs{RemoveFromHook} command
%    will empty the whole code chunk at once.
%    Also, it is not possible to reorder dynamically the various code
%    in a code chunk. In order to gain more control, one technique
%    is to prepare the code beforehands with L3 |tl| commands.
%    Another technique consists of using a supplemental private hook:
%    \begin{lthooksCode}
% \ROW\cs{DeclareHook}|{myHook/private}|\\
% \ROW\cs{AddToHook}|{myHook/private}[myLabel|$_1$|]|\Arg{code_1}\\
% \ROW|...|\\
% \ROW\cs{AddToHook}|{myHook/private}[myLabel|$_n$|]|\Arg{code_n}\\
% \ROW\cs{AddToHook}|{theHook}[myLabel]{\UseHook{myHook/private}}|
%    \end{lthooksCode}
%
% \begin{function}{
%   \RemoveFromHook,
%   \hook_gremove_code:nn,
% }
%   \begin{syntax}
%     \cs{RemoveFromHook}\Arg{hook-spec}\oarg{label-spec}
%     \cs{hook_gremove_code:nn} \Arg{hook-spec} \Arg{label-spec}
%   \end{syntax}
%    Removes the code chunk with the specified label from the specified
%    hook if any, otherwise a warning is issued and the command aborts.
%
%    When the optional \meta{label-spec} argument is not provided,
%    it defaults to \enquote{|.|} and is replaced by
%    the \META{current name}, generally the package name,
%    the class name or the keyword \enquote{\texttt{top-level}}
%    depending on the execution context
%    (see sections~\ref{sec:Command-arguments} and
%    \ref{sec:Managing-the-current-name}).
%    If the label is \enquote{|*|}, then all code chunks are
%    undistinctively removed which may break things badly. 
%    This last feature should only be used with private hooks that are
%    under complete control.
%
% \end{function}
%    In general, \cs{RemoveFromHook} should only be used when
%    no third party code may be involved.
%    Typically, some package adds code to a private hook,
%    then definitely removes it later on,
%    or the programmer adds code to a public hook under a private label
%    then definitely removes it later on, like in the example below.
% 
% \medskip
%    The command \cs{RemoveFromHook} can be used to replace a single
%    code chunk, with some side effects though. Running
% \begin{lthooksCode}[lineno]
% \ROW\cs{NewHook}|{MyName}|\\
% \ROW\cs{AddToHook}|{MyName}[labelA]{\typeout{A}}|\\
% \ROW\cs{AddToHook}|{MyName}[labelB]{\typeout{B}}|\\
% \ROW\cs{RemoveFromHook}|{MyName}{labelA}|\\
% \ROW\cs{AddToHook}|{MyName}[labelA]{\typeout{A alt}}|\\
% \ROW\cs{ShowHook}|{MyName}|\\
% \end{lthooksCode}
% gives the terminal output
% \begin{lthooksCode}
% \ROW|==> Hook: 'MyName'|\\
% \ROW|> Code chunks:|\\
% \ROW|>   'labelA' -> \typeout {A}|\\
% \ROW|>   'labelB' -> \typeout {B}|\\
% \ROW|> Execution order:|\\
% \ROW|>   1: 'labelB'|\\
% \ROW|>   2: 'labelA'.|\\
% \end{lthooksCode}
%    In order to recover exactly the original ordering,
%    next rules is declared:
%\begin{lthooksCode}
%   \ROW\cs{DeclareHookRule}|{MyName}{label_A}{before}{label_B}|\\
%\end{lthooksCode}
%
% \medskip
% Next example shows how to safely add temporary code to hooks while
% inside the document body.
%\begin{lthooksCode}
%   \ROW\cs{AddToHook}|{env/quote/begin}{\small}|\\
%   \ROW|\begin{quote}|\\
%   \ROW\TAB A quote set in a smaller typeface\\
%   \ROW|\end{quote}|\\
%   \ROW...\\
%   \ROW\cs{RemoveFromHook}|{env/quote/begin}|\\
%   \ROW... |% now back to normal for further quotes|
%\end{lthooksCode}
% No code label was provided either to add nor remove command:
% the \enquote{\texttt{top-level}} keyword is used by default
% for the label such that no other code is accidentally removed.
%
% Note that you can't cancel the font size command with
%\begin{lthooksCode}
%   \ROW\cs{AddToHook}|{env/quote/begin}{}|
%\end{lthooksCode}
% because it only adds a further empty chunk of code to
% the hook. Adding |\normalsize| would result in the hook
% containing |\small\normalsize| which is not efficient code.
%
%    In order to temporarily disable some code, \cs{RemoveFromHook}
%    is not suitable because it deletes stored code which is difficult
%    to undo. Instead, use the |voids| rule to prevent code execution
%    followed by a different rule to enable that code again
%    (see section~\ref{sec:Ordering-code-execution}).
%
% If the goal is to typeset in a smaller typeface only one quote
% here and there and not several consecutive quotes,
% \cs{AddToHookNext} should be preferred because the 	added code is
% automatically deleted once executed.
%
% \subsection{Extra code for next use only}
% \label{sec:Updating-code-for-hooks}
% \label{sec:Extra-code}
% Hooks also have transient code executed only on next use,
% and discarded afterwards.
% \begin{function}{
%   \AddToHookNext,
%   \hook_gput_next_code:nn,
% }
%   \begin{syntax}
%     \cs{AddToHookNext}\Arg{hook-spec}\Arg{code}
%    \cs{hook_gput_next_code:nn} \Arg{hook-spec} \Arg{code}
%   \end{syntax}
%    The extra \meta{code} is appended to a dedicated transient pool
%    of the specified hook\footnotemark. On next use of the hook,
%    all the code from the transient pool is removed,
%    then executed in due time and finally deleted.
%
%    For one time hooks already used at least once,
%    \meta{code} will never execute because using a consumed hook
%    is a do nothing operation.
%
%    The specified hook need not be declared prior to any code addition.
%    If such a hook is never declared, \meta{code} will never be
%    executed.
% \end{function}\footnotetext{In order to reorder or delete transient code chunks,
%  use an auxiliary hook.}
%    
% Next example shows how to safely add temporary code to hooks while
% inside the document body.
%\begin{lthooksCode}
%   \ROW\cs{AddToHookNext}|{env/quote/begin}{\small}|\\
%   \ROW|\begin{quote}|\\
%   \ROW\TAB A quote set in a smaller typeface\\
%   \ROW|\end{quote}|\\
%   \ROW... |% back to normal for further quotes|
%\end{lthooksCode}
% See command \cs{AddToHook} when several consecutive quote
% must be typeset in a smaller typeface.
%
% For practical reasons, the addition is cumulative like for
% \cs{AddToHook}. Moreover, it is possible to nest
% \cs{AddToHookNext} commands: for a normal hook,
%   \begin{lthooksCode}
%     \ROW\cs{AddToHookNext}\Arg{hook-spec}\verb={=\meta{code_1}^^A
%         \cs{AddToHookNext}\Arg{hook-spec}\Arg{code_2}\verb=}=
%   \end{lthooksCode}
%    results in \meta{code_1} being executed the next time the hook
%    is used, and \meta{code_2} being executed the next time after.
%
% \begin{function}{
%   \ClearHookNext,
%   \hook_gclear_next_code:n,
% }
%   \begin{syntax}
% \LEFT{\cs{ClearHookNext}\Arg{hook-spec}}^^A
%\RIGHT{\cs{hook_gclear_next_code:n} \Arg{hook-spec}}
%   \end{syntax}
%    Removes all code for the next use only.
%    \cs{ClearHookNext} can be used when the next use occurs in a
%    different situation than expected making previous code obsolete,
%    for example, when discarding a page with \cs{DiscardShipoutBox}
%    (but even then not always). This is a sensible command that needs
%    enough control on the execution flow.
% \end{function}
%
%
% \subsection{Declaring and using normal hooks}
%
%  Except for generic hooks detailed in section~\ref{sec:LaTeX-generic-hooks},
%  hooks have to be declared before they can be used effectively.
%  Here we see hooks without arguments, either direct or reversed.
%
% \begin{function}{
%   \NewHook,
%   \hook_new:n,
% }
%   \begin{syntax}
% \LEFT{\cs{NewHook}\Arg{hook-spec}}^^A
%\RIGHT{\cs{hook_new:n} \Arg{hook-spec}}
%   \end{syntax}
% Builds a \meta{hook-name} from \meta{hook-spec}.
% If a hook was already declared with that name, an error is raised
% and the command aborts, otherwise a new hook is declared.
% \end{function}
%
% \begin{function}{
%   \UseHook,
%   \hook_use:n,
% }
%   \begin{syntax}
% \LEFT{\cs{UseHook}\Arg{hook name\LHXStar}}^^A
%\RIGHT{\cs{hook_use:n} \Arg{hook name\LHXStar}}
%   \end{syntax}
%    A hook is usable means that it is either declared or a generic
%    hook not disabled.
%    This command does nothing if there is no usable hook for
%   \meta{hook name\LHXStar} or if the hook has already been consumed by
%    \cs{UseOneTimeHook} or similar functions.
%    Otherwise it makes an ordered copy of all the code chunks
%    previously added for \meta{hook name\LHXStar} and executes it.
%    Managing the order of execution of the various code chunks
%    is detailed in section \ref{sec:Ordering-code-execution}.
%    \emph{Executing} a hook means executing one of the
%    \cs[no-index]{Use...} commands, we may also say that a hook is
%    \cs[no-index]{Use...}'d.
%
%    Notice that executing a hook after |\begin{document}| is faster than before.
%
% \end{function}
%
% \subsection{One time hooks}
% \label{sec:One-time-hooks}
%
% Sometimes it is necessary to defer the execution of some code
% until a condition is fulfilled, for example to execute a task only
% once all the packages have been loaded or at the end of the document.
% Before the condition is realized, any code is stored in a hook for
% later use. Once the condition is realized, all the stored code is
% executed and after the condition is realized, any code added no
% longer needs to be stored and can execute immediately.
%
% A similar situation occurs when possibly many commands need the same
% initialization task. One possibility is to initialize even if none
% of the commands is ever used, which is inefficient coding.
% It is highly practical to initialize the  global state at the
% beginning of each command body. Such a pattern would be
% \begin{lthooksCode}
% \ROW|\newcommand{\MyCmd}{|\FILL{20}^^A
% \SEP|\newcommand{\MyCmdInit}{|\\
% \ROW\TAB|\MyCmdInit|\FILL{12}^^A
% \SEP\TAB|...|\\
% \ROW\TAB|...|\FILL{5}^^A
% \SEP\TAB|\renewcommand{\MyCmdInit}{}|\\
% \ROW|}|\FILL{1}^^A
% \SEP|}|
% \end{lthooksCode}
% Using a one time hook will also
% ensure that the initialization code is run exactly once,
% whichever command is executed first, but with more flexibility:
% \begin{lthooksCode}
% \ROW|\newcommand{\MyCmd}{|\FILL{20}^^A
% \SEP\cs{NewHook}|{MyCmd/Init}|\\
% \ROW\TAB\cs{UseOneTimeHook}|{MyCmd/Init}|\FILL{29}^^A
% \SEP\cs{AddToHook}|{MyCmd/Init}{|\\
% \ROW\TAB|...|\FILL{5}^^A
% \SEP\TAB|...|\\
% \ROW|}|\FILL{1}^^A
% \SEP|}|
% \end{lthooksCode}
%
%
% \begin{function}{
%   \UseOneTimeHook,
%   \hook_use_once:n,
% }
%   \begin{syntax}
% \LEFT{\cs{UseOneTimeHook}\Arg{hook name\LHXStar}}^^A
%\RIGHT{\cs{hook_use_once:n} \Arg{hook name\LHXStar}}
%   \end{syntax}
%   This command does nothing if there is no usable hook for
%   the given name or if the hook has already been consumed.
%    Otherwise, marks the hook as consumed and then works like
%   \cs{UseHook}. Next time it does nothing.
% \end{function}
%
%    Any labeled code added to a consumed hook, whatever method used
% (e.g., \cs{AddToHook}, \cs{AtBeginDocument}...\@),
%    is executed immediately instead of stored.
%    On the contrary, any extra code added for the next use only
%    will never be executed.
%
%    In particular this means that after
%\begin{lthooksCode}
%    \ROW\cs{AddToHook}|{|myHook|}{|\META{code_1}^^A
%      \cs{AddToHook}|{myHook}|\{\META{code_2}\}\META{code_3}|}|^^A
%      \footnote{Such a construct is sometimes used with
%    \cs{AtBeginDocument} which is why it is supported.}
%\end{lthooksCode}
%    \cs{UseOneTimeHook}|{myHook}| is reduced to the execution of
%    \texttt{\meta{code_1}\meta{code_2}\meta{code_3}}, and any
%    further attempt to use that hook again is a do nothing operation.
% On the opposit, \cs{UseHook}|{myHook}| is reduced to the execution of
%    \texttt{\meta{code_1}\meta{code_3}} while \meta{code_2} is
% appended to the chunk. Next \cs{UseHook}|{myHook}| is then reduced to
%    the execution of \texttt{\meta{code_1}\meta{code_3}\meta{code_2}}
%    while \meta{code_2} is appended once more to the chunk.
%    And the next \cs{UseHook}|{myHook}| is then reduced to
%    the execution of \texttt{\meta{code_1}\meta{code_3}\meta{code_2}\meta{code_2}}
%    while \meta{code_2} is appended once more to the chunk, etc.
%    In general, mixing \cs{UseHook} and \cs{UseOneTimeHook} for the same
%    hook should be avoided, but when done both do nothing
%    after the first \cs{UseOneTimeHook}.
%
%    Another coding pattern consists in defering the execution
%    of some instruction until some main command exists. If
%    \pkg{pkg1} and \pkg{pkg2} respectively contain
%\begin{lthooksCode}
%    \ROW|% pkg1:|\FILL{7}\SEP|% pkg2:|\\
%    \ROW\cs{newcommand}|\foo[1]{...}|^^A
%    \FILL{23}\SEP\cs{AddToHook}|{pkg1/on/foo:1}{\foo{bar}}| \\
%    \ROW\cs{NewHook}|{pkg1/on/foo:1}|\FILL{23}\SEP\\
%    \ROW\cs{UseOneTimeHook}|{pkg1/on/foo:1}|\FILL{30}\SEP\\
%\end{lthooksCode}
%    then if \pkg{pkg1} or \pkg{pkg2} is not loaded,
%    instruction \enquote{\cs{foo}|\{bar\}|} never executes.
%    On the contrary, it executes if both packages are loaded,
%    in whatever order.
%    Of course, \pkg{pkg1} must document the hook named
%    |pkg1/on/foo:1| if it is public.
%
%
% \subsection{Declaring and using hooks with arguments}
% \label{sec:Hooks-with-arguments}
%
%    Sometimes hooks need to know about contextual information.
%    It is possible to simply store this information in a macro
%    available to the hook but in many cases this is far from
%    sufficient. Hooks with arguments are a straightforward solution
%    to this problem.
%
%    A hook with arguments works mostly like a regular hook, and most
%    commands that work for regular hooks, also work for hooks that take
%    arguments.  The differences are when the hook is declared
%    (\cs{NewHookWithArguments} is used instead of \cs{NewHook} for example), then
%    code can be added with both \cs{AddToHook} and
%    \cs{AddToHookWithArguments}, and when the hook is used
%    (\cs{UseHookWithArguments} instead of \cs{UseHook}).
%    Below, the command argument \meta{n} is an integer
%    from 0 to 9, denoting a \emph{number of arguments}.
%
% Using hooks with arguments can be sharp because the number of
% given arguments must be correct as well as their type and meaning.
% Whereas the hook must be well documented,
% its name can also reflect its usage.
% A lightweight convention would be to use as component of the hook name
% at least \enquote{\texttt{/\#\meta{n}}} or a function signature when in L3.
% A more complete convention would be a name containing
% \enquote{\texttt{\#\meta{desc_1}\#...\#\meta{desc_{\meta{n}}}}}
% at the end of a component.
%
% \begin{function}{
%   \NewHookWithArguments,
%   \hook_new_with_args:nn,
% }
%   \begin{syntax}
%    \cs{NewHookWithArguments}\Arg{hook-spec}\Arg{n}
%    \cs{hook_new_with_args:nn} \Arg{hook-spec} \Arg{n}
%   \end{syntax}
%    Declares a hook like \cs{NewHook} does except that added
%    code chunks can refer to \meta{n} arguments
%    \texttt{\#1}, \texttt{\#2},... \texttt{\#\meta{n}}.
% \end{function}
%
% \medskip
%
% Commands \cs{AddToHook} and \cs{RemoveFromHook} can be used with
% hooks with arguments, there are also dedicated commands.
%
% \begin{function}{
%   \AddToHookWithArguments,
%   \hook_gput_code_with_args:nnn,
% }
%   \begin{syntax}
%     \cs{AddToHookWithArguments}\Arg{hook-spec}\oarg{label-spec}\Arg{\#\ code}
%     \cs{hook_gput_code_with_args:nnn} \Arg{hook-spec} \Arg{label-spec} \Arg{\#\ code}
%   \end{syntax}
%    Works like \cs{AddToHook}, except that \meta{\#\ code} can
%    access the arguments passed to the hook using \verb|#1|, \verb|#2|,
%    \ldots, \texttt{\#\meta{n}} where \meta{n} is less than
%    the eponym argument ever used when declaring the hook with
%    \cs{NewHookWithArguments} or derived command.
% \end{function}
%
%    This command does not take supplemental arguments, thus preventing
%    the immediate execution of \meta{\#\ code} due to the lack of argument values.
%    This is why one time hooks cannot be used with 
%    \cs{AddToHookWithArguments} and alike once consumed.
%
%    If macros are defined inside \meta{\#\ code},
%    their arguments are refered to with \enquote{\texttt{\#\#}}
%    instead of \enquote{\texttt{\#}}.
%    Next example defines a greetings command in a hook of
%    the document body, with \cs{AddToHook}:
%\begin{lthooksCode}[lineno]
%   \ROW\cs{NewHook}|{./greetings}|\\
%   \ROW...\\
%   \ROW\cs{AddToHook}|{./greetings}|\\
%   \ROW[format=\bfseries,mark=$\to$\;,
%   ]\TAB|{\def\greetings#1{Hello, #1!}}|\\
%   \ROW...\\
%   \ROW\cs{UseHook}|{./greetings}|\\
%   \ROW|\greetings{ET}|\\
%\end{lthooksCode}
%   A variation when \enquote{Hello} may be localized:
%   notice how \cs[no-index]{greetings} definition is different
%   on lines 4 above and below.
%\begin{lthooksCode}[lineno]
%   \ROW\cs{NewHookWithArguments}|{./greetings/#Hello}{1}|\\
%   \ROW...\\
%   \ROW\cs{AddToHookWithArguments}|{./greetings/#Hello}|\\
%   \ROW[format=\bfseries,mark=$\to$\;,
%   ]\TAB|{\def\greetings##1{#1, ##1!}}|\\
%   \ROW...\\
%   \ROW\cs{UseHookWithArguments}|{./greetings/#Hello}{1}{Hallo}|\\
%   \ROW|\greetings{ET}|
%\end{lthooksCode}
%    Here \verb|#1| refers to \enquote{Hallo}
%     whereas \verb|##1| refers to \enquote{ET}.
%
% \begin{function}{
%   \AddToHookNextWithArguments,
%   \hook_gput_next_code_with_args:nn,
% }
%   \begin{syntax}
%     \cs{AddToHookNextWithArguments}\Arg{hook-spec}\Arg{\#\ code}
%     \cs{hook_gput_next_code_with_args:nn} \Arg{hook-spec} \Arg{\#\ code}
%   \end{syntax}
%    Works like \cs{AddToHookNext}, except that \meta{\#\ code} can
%    access the arguments passed to the hook using \verb|#1|, \verb|#2|,
%    \ldots, \texttt{\#\meta{n}} where \meta{n} is less than
%    the eponym argument used when declaring the hook with
%    \cs{NewHookWithArguments} or similar command.
% \end{function}
%
% \begin{function}{
%   \UseHookWithArguments,
%   \hook_use:nnw,
% }
%   \begin{syntax}
%     \cs{UseHookWithArguments}\Arg{hook name\LHXStar}\Arg{n}\Arg{arg_1}\ldots\Arg{arg_{\text{\scriptsize\meta{n}}}}
%     \cs{hook_use:nnw} \Arg{hook name\LHXStar} \Arg{n} \Arg{arg_1}~...~\Arg{arg_{\text{\scriptsize\meta{n}}}}
%   \end{syntax}
%    Works like \cs{UseHook}, except that it passes to the code chunks
%    \meta{arg_1} for |#1|, \ldots, \meta{arg_{\meta{n}}} for |#|\metatt{n}.
%    The \meta{n} should at least equal the eponym argument used to declare the hook,
%    excess arguments are ignored.
%    If the hook is not declared, this command does nothing more than
%    consuming its \meta{n}$+2$ arguments.
%    A low-level \TeX{} error is raised when an argument number that
%    doesn't exist is referenced.
% \end{function}
%
% \begin{function}{
%   \UseOneTimeHookWithArguments,
%   \hook_use_once:nnw,
% }
%   \begin{syntax}
%     \cs{UseOneTimeHookWithArguments}\Arg{hook name\LHXStar}\Arg{n}\Arg{arg_1}...\Arg{arg_{\text{\scriptsize\meta{n}}}}
%     \cs{hook_use_once:nnw} \Arg{hook name\LHXStar} \Arg{n} \Arg{arg_1}~...~\Arg{arg_{\text{\scriptsize\meta{n}}}}
%   \end{syntax}
%    Works like \cs{UseOneTimeHook}, except that it passes to the code chunks
%    \meta{arg_1} for |#1|, \ldots, \meta{arg_{\meta{n}}} for |#|\metatt{n}.
%    The \meta{n} should at least equal the eponym argument used to declare the hook,
%    excess arguments are ignored.
%    If the hook is not declared, this command does nothing more than
%    consuming its \meta{n}$+2$ arguments.
%    A low-level \TeX{} error is raised when an argument number that
%    doesn't exist is referenced.
%
%    It should be noted that after a one-time hook is used, it is no
%    longer possible to use \cs{AddToHookWithArguments}\texttt{\Arg{n}} or similar with
%    that hook as soon as \meta{n}$>0$. \cs{AddToHook} continues to work as normal.
% \end{function}
%
% \subsection{Reversed hooks and mirrored hook pairs}
%   \label{sec:reversed-order}
%
%   Mirrored hook pairs solve a problem related to \LaTeX\ environments
%   and more generally to grouping. For example the contrived
%   package \pkg{mycolor} can typeset all the \env{quote} environments in blue, with
%\begin{lthooksCode}
%\ROW|\RequirePackage{color}|\\
%\ROW|\AddToHook{env/quote/begin}[begin{color}]{\begin{color}{blue}}|\\
%\ROW|\AddToHook{env/quote/end}  [end{color}]{\end{color}}|\\
%\end{lthooksCode}
%   |\begin{color}{blue}| is executed at the beginning of each \env{quote}
%   environment whereas |\end{color}| is executed at the end.
%   In parallel, contrived package \pkg{myitshape} can typeset all the \env{quote}
%   environments in italic, with
%\begin{lthooksCode}
%\ROW|\AddToHook{env/quote/begin}[begin{itshape}]{\begin{itshape}}|\\
%\ROW|\AddToHook{env/quote/end}  [end{itshape}]{\end{itshape}}|\\
%\end{lthooksCode}
%   If we load \pkg{mycolor} then \pkg{myitshape}, typesetting a \env{quote} environment
%   stops on the error
%\begin{lthooksCode}
%\ROW|! LaTeX Error: \begin{itshape} on input line ... ended by \end{color}.|\\
%\end{lthooksCode}
%   The \cs{ShowHook} command applied to each hook clearly explains the error,
%   the carefully chosen code chunk labels fitting that purpose,
%\begin{lthooksCode}
%\ROW|==> Hook: 'env/quote/begin'|\FILL{27}
%\SEP|==> Hook: 'env/quote/end'|\\
%\ROW|> ...|\FILL{5}
%\SEP|> ...|\\
%\ROW|> Execution order:|\FILL{18}
%\SEP|> Execution order:|\\
%\ROW|> 1: 'begin{color}'|\FILL{19}
%\SEP|> 1: 'end{color}'|\\
%\ROW|> 2: 'begin{itshape}'|\FILL{21}
%\SEP|> 2: 'end{itshape}'|\\
%\end{lthooksCode}
% The sequence of execution is
%\begin{lthooksCode}
%\ROW|...\begin{color}{blue}...\begin{itshape}...\end{color}...\end{itshape}...|\\
%\end{lthooksCode}
% Whereas it should be
%\begin{lthooksCode}
%\ROW|...\begin{color}{blue}...\begin{itshape}...\end{itshape}...\end{color}...|\\
%\end{lthooksCode}
% meaning that the second hook should be executed in reverse order.
% Loading \pkg{myitshape} before \pkg{mycolor} does not help: the error simply becomes
%\begin{lthooksCode}
%\ROW|! LaTeX Error: \begin{color} on input line ... ended by \end{itshape}.|\\
%\end{lthooksCode}
%
% In that situation, instead of \hook{env/quote/begin}
% and \hook{env/quote/end}, the generic hooks \hook{env/quote/before}
% and \hook{env/quote/after}, should be used because they form a
% \emph{pair of mirrored hooks}, the first one being \emph{normal}
% and the last one being \emph{reversed}.
%
%
% \subsubsection{Reversed hooks}
%
% \begin{function}{
%   \NewReversedHook,
%   \hook_new_reversed:n
% }
%   \begin{syntax}
%\LEFT{\cs{NewReversedHook} \Arg{hook-spec}}^^A
%\RIGHT{\cs{hook_new_reversed:n} \Arg{hook-spec}}
%   \end{syntax}
%     Declares a new hook like \cs{NewHook} and marks it
%     as \emph{reversed}.
%     Its labelled code chunks are in reverse order by default
%     (those added last are executed first).
% \end{function}
%
% \begin{function}{
%  \NewReversedHookWithArguments,
%  \hook_new_reversed_with_args:nn,
% }
%   \begin{syntax}
%     \cs{NewReversedHookWithArguments} \Arg{hook-spec} \Arg{n}
%     \cs{hook_new_reversed_with_args:nn} \Arg{hook-spec} \Arg{n}
%   \end{syntax}
%     Declares a new hook like \cs{NewHookWithArguments} and marks it
%     as \emph{reversed}.
%     Section~\ref{sec:Hooks-with-arguments} explains hooks with arguments.
% \end{function}
%
% \subsubsection{Mirrored hook pairs}
%
% A \emph{mirrored hook pair} binds a normal hook with a reversed hook,
% each one \emph{matching} the other. The reversed hook is always
% executed balancing a previous execution of the normal hook.
% Both hooks have the same owner and are not meant to be
% \cs[no-index]{Use...}'d by any other object.
% In general they are not one-time hooks, but that is not a requirement.
% Finally, two mirrored hook pairs cannot contain the same hook.
%
% Many mirrored hook pairs are built into \LaTeX. They are name
% \hook{\meta{...}/before} and \hook{\meta{...}/after}, as
% detailed in section \ref{sec:LaTeX-hooks}.
% Following this naming convention is good practice.
%
% \begin{function}{\NewMirroredHookPair,\hook_new_pair:nn}
%   \begin{syntax}
%     \cs{NewMirroredHookPair} \Arg{hook-spec} \Arg{mirror hook-spec}
%     \cs{hook_new_pair:nn} \Arg{hook-spec} \Arg{mirror hook-spec}
%   \end{syntax}
%     Executes
% \begin{lthooksCode}
% \ROW\cs{NewHook}\Arg{hook-spec}\\
% \ROW\cs{NewReversedHook}\Arg{mirror hook-spec}\\
% \end{lthooksCode}
% and binds the hooks together as a mirrored hook pair.
% \end{function}
%
% \begin{function}{\NewMirroredHookPairWithArguments,\hook_new_pair_with_args:nnn,}
%   \begin{syntax}
%     \cs{NewMirroredHookPairWithArguments}
%     ~~\Arg{hook-spec} \Arg{mirror hook-spec} \Arg{n}
%     \cs{hook_new_pair_with_args:nnn}
%     ~~\Arg{hook-spec} \Arg{mirror hook-spec} \Arg{n}
%   \end{syntax}
%   Executes
% \begin{lthooksCode}
% \ROW\cs{NewHookWithArguments}\Arg{hook-spec}\Arg{n}\\
% \ROW\cs{NewReversedHookWithArguments}\Arg{mirror hook-spec}\Arg{n}\\
% \end{lthooksCode}
% and binds the hooks together as a mirrored hook pair.
%   Section~\ref{sec:Hooks-with-arguments} explains hooks with arguments.
% \end{function}
%
% \medskip
%
% Hooks pertaining to mirrored hook pairs are generally managed in
% parallel for a stronger code design.
%
% \begin{function}[added = 2024-01-01]{
%   \AddToHookPair,
%   \hook_pair_gput_code:nnnn,
%   \AddToHookPairWithArguments,
%   \hook_pair_gput_code_with_args:nnnn
% }
% \begin{syntax}
%   \cs{AddToHookPair}\Arg{hook-spec}\oarg{label-spec}
%   \TAB\Arg{code}\Arg{other code}
%   \cs{hook_pair_gput_code:nnnn} \Arg{hook-spec} \Arg{label-spec}
%   \TAB\Arg{code} \Arg{other code}
%   \cs{AddToHookPairWithArguments}\Arg{hook-spec}\oarg{label-spec}
%   \TAB\Arg{code\LHXStar}\Arg{other code\LHXStar}
%   \cs{hook_pair_gput_code_with_args:nnnn} \Arg{hook-spec} \Arg{label-spec}
%   \TAB\Arg{code\LHXStar} \Arg{other code\LHXStar}
% \end{syntax}
% If the specified hook does not belong to a mirrored hook pair,
% an error is raised.
% Otherwise these are shortcuts to
% \begin{lthooksCode}
% \ROW \cs{AddToHook}\Arg{hook-spec}\oarg{label-spec}\Arg{code}\\
% \ROW \cs{AddToHook}\Arg{other hook-spec}\oarg{label-spec}\Arg{other code}\\
% \end{lthooksCode}
% and
% \begin{lthooksCode}
% \ROW \cs{AddToHookWithArguments}\Arg{hook-spec}\oarg{label-spec}\Arg{code\LHXStar}\\
% \ROW \cs{AddToHookWithArguments}\Arg{other hook-spec}\oarg{label-spec}\Arg{other code\LHXStar}\\
% \end{lthooksCode}
% where \meta{other hook-spec} specifies the other element of the mirrored hook pair.
%
% By symmetry, this is equivalent to
% \begin{lthooksCode}
% \ROW \cs{AddToHookPair}\Arg{other hook-spec}\oarg{label-spec}\Arg{other code}\Arg{code}\\
% \end{lthooksCode}
% and the same holds with arguments.
% \end{function}
%
% \begin{function}[added = 2024-01-01]{
%   \RemoveFromHookPair,
%   \hook_pair_gremove_code:nn
% }
% \begin{syntax}
%   \cs{RemoveFromHookPair}\Arg{hook-spec}\oarg{label-spec}
%   \cs{hook_pair_gremove_code:nn}\Arg{hook-spec}\Arg{label-spec}
% \end{syntax}
% If the specified hook does not belong to a mirrored hook pair,
% an error is raised.
% Otherwise this is a shortcut to
% \begin{lthooksCode}
% \ROW \cs{RemoveFromHook}\Arg{hook-spec}\oarg{label-spec}\\
% \ROW \cs{RemoveFromHook}\Arg{other hook-spec}\oarg{label-spec}\\
% \end{lthooksCode}
% where \meta{other hook-spec} specifies the other element of the mirrored hook pair.
% By symmetry, this is equivalent to
% \begin{lthooksCode}
% \ROW \cs{RemoveFromHookPair}\Arg{other hook-spec}\oarg{label-spec}\\
% \end{lthooksCode}
% \end{function}
%
% 
% \subsection{Generic hooks}
% \changes{v1.2?}{2024/01/01}{Section on generic hooks modified and moved (gh/638???)}
%
% Normally, hooks have to be explicitly declared before they are
% effectively used in code. This ensures that different packages are
% not using the same hook for unrelated purposes, something that would
% result in absolute chaos.
% However, some hooks are so general that declaring them beforehands
% is not efficient or even not possible, these are simply enabled on demand.
% The \LaTeX\ hook management system provides \emph{generic hooks}
% for that purpose.
% There are many sets of generic hooks built into \LaTeX,
% you just have to add your code to them.
% They are detailed in section \ref{sec:LaTeX-generic-hooks}.
%
%    If you want to provide your own generic hooks, you should 
%    use commands \cs{UseHook} or similar, but
%    \emph{without declaring the hook}. Then the hook is enabled
%    with next functions when necessary.
%    For example, the \pkg{babel} package provides hooks such as
%    \hook{babel/\META{language}/afterextras}.  However, language
%    support in \pkg{babel} is often done through external language
%    extensions. Thus doing the activation for all languages inside the
%    core \pkg{babel} code is not a viable approach. Instead it needs
%    to be done separately by each language extension (or by the user
%    who wants to use a particular hook).
%    Generic hooks defined in this way can't be reversed hooks,
%    this is a deliberate limitation to considerably speed up
%    the processing. But a generic hook code chunk can use
%    an auxiliary reversed hooks.
%
% \changes{v1.0p}{2021/08/20}{Documentation updates for generic hook commands (gh/638)}
%
% \begin{function}{
%   \ActivateGenericHook,
%   \hook_activate_generic:n,
% }
%   \begin{syntax}
% \LEFT{\cs{ActivateGenericHook}\Arg{hook-spec}}^^A
%\RIGHT{\cs{hook_activate_generic:n} \Arg{hook-spec}}
%   \end{syntax}
%  Does nothing if the specified hook is already declared or already activated,
%  prints a warning and aborts if the specified hook is disabled,
%  otherwise activates the hook in order to be able to execute
% its code.
% \end{function}
%
%
% \begin{function}{
%   \DisableGenericHook,
%   \hook_disable_generic:n,
% }
%   \begin{syntax}
% \LEFT{\cs{DisableGenericHook}\Arg{hook-spec}}^^A
%\RIGHT{\cs{hook_disable_generic:n} \Arg{hook-spec}}
%   \end{syntax}
%    Definitely disables a generic hook\footnotemark: any further attempt to add code to it
%    will result in an error and any use will not execute its code.
%    Activating a disabled hook issues a warning.
%
%    This is particularly usefull with generic command related hooks,
%    because some commands are not eligible to use hooks as explained in
%    section \ref{sec:Generic-hooks-for-commands} and
%    \texttt{ltcmdhooks-doc}.
%    
% \end{function}\footnotetext{In the 2020/06 release this command was
%    called \cs{DisableHook}, but that name was misleading as it
%    shouldn't be used to disable non-generic hooks.}
%
%
% \subsection{Ordering code execution}
% \label{sec:Ordering-code-execution}
% In general, code added to hooks by different label owners are
% independent from each other and the order in which they are
% executed is irrelevant. While this is true in most cases it is
% sometimes false, for example a code that relies on some package
% should execute only after the package has loaded.
% Moreover, in mirrored hook pairs the order in one hook
% influences the order in the second hook and breaks any independency.
%
% Before the \LaTeX\ hook management system was introduced,
% packages had to take elaborate precautions to determine if some other
% package got loaded and find some ways to alter its own behavior
% accordingly. In addition it was often the user's
% responsibility to load packages in the right order so that
% instructions were executed in the right order. And sometimes it
% was just impossible to resolve conflicts just changing the ordering.
%
% Now, rules are the means to precisely describe how labeled code
% chunks should be processed relatively to one another.
% Using a hook consists of ordering the code chunks by applying the
% rules to a default ordering, either direct or reversed, then execute
% the code chunks in the resulting order.
% \cs{ShowHook} and \cs{LogHook} give the execution order.
%
% \subsubsection{Default ordering}
% Before execution, the various code chunks follow a direct ordering:
% \begin{enumerate}
% \item low level code chunks in the order of the first time they were
% added,
% \item the \enquote{|top-level|} code chunk, if any, whenever it was
% first added,
% \end{enumerate}
% For reversed hooks, this ordered is reversed
% \begin{enumerate}
% \item the \enquote{|top-level|} code chunk, if any, whenever it was
% first added,
% \item low level code chunks in the inverse order of the first time
% they were added.
% \end{enumerate}
% The extra code for the next use only, if any, is always executed last.
%
%
% \subsubsection{Custom ordering}
% The custom ordering is obtained after the rules apply to
% the default ordering, either direct or reversed.
% \begin{function}{
%   \DeclareHookRule,
%   \hook_gset_rule:nnnn,
% }
%   \begin{syntax}
%     \cs{DeclareHookRule}\Arg{hook-spec}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}
%     \cs{hook_gset_rule:nnnn} \Arg{hook-spec} \Arg{label-spec_1} \Arg{relation} \Arg{label-spec_2}
%   \end{syntax}
%    Does nothing if both specified labels are identical, or if one of them
%    expands to \enquote{\hook{top-level}}, otherwise
%    declares a relation between specified \meta{label_1} and \meta{label_2}
%    for the specified hook.
%    The specifide hook does not needs to be declared before declaring the rule,
%    it does not even need to ever contain code chunks for any of the
%    specified labels.
% \end{function}
%
% \medskip
%
%    The supported relations are:
%    \begin{itemize}
%
%    \item[\texttt{before} or \texttt{\string<}:]
%
%      The code chunk for \meta{label_1} comes before the one for
%      \meta{label_2}.
%
%    \item[\texttt{after} or \texttt{\string>}:]
%      The code chunk for \meta{label_1} comes after the one for
%      \meta{label_2}.
%
%    \item[\texttt{incompatible-warning}:]
%
%      A warning is raised if the hook has code chunks for both
%      \meta{label_1} and \meta{label_2}.
%
%    \item[\texttt{incompatible-error}:]
%
%      An error is raised if the hook has code chunks for both
%      \meta{label_1} and \meta{label_2}, and none will
%      execute until the conflict is resolved.
%
%    \item[\texttt{voids}]
%
%      The code chunk for \meta{label_1} overwrites the one for
%     \meta{label_2}. If there is a code chunk for \meta{label_1}
%      it will execute and the one for \meta{label_2} won't, otherwise
%      the code chunk for \meta{label_2} will execute, if any.
%      This can be used, for example if one package is a
%      superset in functionality of another one and therefore wants to
%      replace the original code with its own version.
%
%    \item[\texttt{unrelated}]
%
%      The order of the code chunks for \meta{label_1} and
%      \meta{label_2} is irrelevant. This rule allows to cancel a
%      previous rule.
%
%    \end{itemize}
%    There can only be a single relation between two different labels
%    for a given hook, i.e., a later \cs{DeclareHookRule} overwrites
%    any previous declaration.
%
%    If \meta{hook-spec} expands to \enquote{\hook{??}} this declares a default
%    relation for all hooks that use the two labels,
%    more precisions in  \cs{DeclareDefaultHookRule} command below.
%
%    All the declared rules must be compatible with each other,
%    for example next codes will raise an error.
%    \begin{lthooksCode}
%    \ROW\cs{DeclareHookRule}|{MyHook}{labelA}<{labelB}|\\
%    \ROW\cs{DeclareHookRule}|{MyHook}{labelB}<{labelA}|\\
%    \end{lthooksCode}
%    Moreover, if there are many possibilities to fulfill the rules,
%    which one is used is undefined. For example, with
%    \begin{lthooksCode}
%    \ROW\cs{DeclareHookRule}|{MyHook}{labelA}<{labelB}|\\
%    \end{lthooksCode}
%    there are 3 possible orderings of the 3 labels
%    |labelA|, |labelB|, |labelC|:
% \begin{lthooksCode}
% \ROW|labelA < labelB < labelC|\\
% \ROW|labelA < labelC < labelB|\\
% \ROW|labelC < labelA < labelB|
% \end{lthooksCode}
%    Wich one is effective is not always the same,
%    even while typesetting one document\footnote{In very specific
%    situations, the effective ordering may differ between different
%    runs, eventually preventing a steady \TeX\ state from being achieved.}.
%
%    \medskip
%    Next example shows how some code is temporarily deactivated.
%    The generic hook |cmd/emph/after| is used to insert a \enquote{!}
%    after the argument of the |\emph| command.
%
% \begin{lthooksCode}[lineno]
% \ROW|\emph{W}|\\
% \ROW\cs{AddToHook}|{cmd/emph/after}[./on]{!}%|\\
% \ROW|\emph{W}|\\
% \ROW\cs{DeclareHookRule}|{cmd/emph/after}{./off}{voids}{./on}%|\\
% \ROW\cs{AddToHook}|{cmd/emph/after}[./off]{}%|\\
% \ROW|\emph{W}|\\
% \ROW[format=\bfseries,mark=$\to$\;,
% ]\cs{RemoveFromHook}|{cmd/emph/after}[./off]%|\\
% \ROW|\emph{W}|
% \end{lthooksCode}
%    Line 1 prints \enquote{W},
%    line 3 prints \enquote{W} followed by the \enquote{!},
%    added to the \hook{cmd/emph/after} hook at line 2.
%    Line 5 adds an empty code chunk that overrides the \enquote{|!|}
%    of line 2 due to the rule of line 5.
%    Line 6 prints like line 1.
%    Line 7 removes the code chunks that overrode the \enquote{|!|},
%    such that line 8 prints like line 3.
%
%    We get the same result if we replace line 7 with next line,
%    except that it might be slower due to the supplemental rule.
% \begin{lthooksCode}[lineno,first=7]
% \ROW[format=\bfseries,mark=$\to$\;,
% ]\cs{DeclareHookRule}|{cmd/emph/after}{./off}{unrelated}{./on}%|
% \end{lthooksCode}
%
% \begin{function}{\ClearHookRule}
%   \begin{syntax}
%     \cs{ClearHookRule}\Arg{hook-spec}\Arg{label-spec_1}\Arg{label-spec_2}
%   \end{syntax}
%    Synonym of each instruction amongst
% \begin{lthooksCode}
%    \ROW\cs{DeclareHookRule}\Arg{hook-spec}^^A
%    \Arg{label-spec_1}|{unrelated}|\Arg{label-spec_2}\\
%    \ROW\cs{hook_gset_rule:nnnn} \Arg{hook-spec}^^A
%    \Arg{label-spec_1} |{ unrelated }| \Arg{label-spec_2}
% \end{lthooksCode}
% \end{function}
%
% \begin{function}{
%   \DeclareDefaultHookRule,
%   \DeclareHookRule{??},
%   \hook_gset_rule:nnnn{??},
% }
%   \begin{syntax}
%     \cs{DeclareDefaultHookRule}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}
%     \cs{DeclareHookRule}|{??}|\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}
%     \cs{hook_gset_rule:nnnn} |{??}| \Arg{label-spec_1} \Arg{relation} \Arg{label-spec_2}
%   \end{syntax}
%    Does nothing if both specified labels are identical, or if one of them
%    expands to \enquote{\hook{top-level}}, otherwise
%    declares a relation between specified \meta{label_1} and \meta{label_2}
%    for all hooks.
%    Rules specific to a given hook take precedence over default
%    rules with the same labels.
%
%    The relations are the ones described for \cs{DeclareHookRule}
%    except for reversed hooks due to order reversal:
%    \begin{itemize}
%
%    \item[\texttt{before} or \texttt{\string<}:]
%
%      The code chunk for \meta{label_1} comes \emph{after} the one for
%      \meta{label_2} and not before.
%
%    \item[\texttt{after} or \texttt{\string>}:]
%      The code chunk for \meta{label_1} comes \emph{before} the one for
%      \meta{label_2} and not after.
%
%    \end{itemize}
%
%    Useful for cases where one package has a specific relation to
%    some other package, e.g., is \texttt{incompatible} or always
%    needs a special ordering \texttt{before} or \texttt{after}.
%
%    Declaring default rules is only supported in the main document
%    preamble. Nevertheless, a declaration somewhere else won't allways
%    raise an error for performance reasons.
% \end{function}
%
%
% \subsubsection{Ordering mirrored hooks}
% \label{sec:Ordering-mirrored-hooks}
%
% For a pair of mirrored hooks, things can become a bit tricky
% when rules get involved. In general, the same rules are added to both
% hooks, except for ordering rules that are reversed.
% For example, |env/quote/before| and |env/quote/after| form a
% mirrored hook pair that can be used to enclose the |quote|
% environment inside other environments. See a basic example in
% section \ref{sec:reversed-order}.
%
% It is recommanded to allways feed mirrored hooks in parallel,
% with the very same label using \cs[no-index]{AddToHookPair...}
% and \cs[no-index]{RemoveFromHookPair...}. Of course, one of the
% hooks can be fed with an empty code chunk. Moreover, the rules
% should also be declared in parallel. That way, the risk that the
% mirrored hooks are not perfectly balancing each other and break
% code is limited.
%
% \begin{function}[added=2024-01-01]{
%   \DeclareHookPairRule,
%   \hook_pair_gset_rule:nnnn,
% }
%   \begin{syntax}
%     \cs{DeclareHookPairRule}\\\TAB\Arg{hook-spec}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}
%     \cs{hook_pair_gset_rule:nnnn}\\\TAB\Arg{hook-spec} \Arg{label-spec_1} \Arg{relation} \Arg{label-spec_2}
%   \end{syntax}
% \end{function}
% Raises an error if the specified hook does not belong to
% a mirrored hook pair, otherwise executes
% \begin{lthooksCode}
% \ROW\cs{DeclareHookRule}\Arg{hook-spec}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}\\
% \ROW\cs{DeclareHookRule}\Arg{mirror hook-spec}\Arg{label-spec_1}\Arg{relation\LHXStar}\Arg{label-spec_2}
% \end{lthooksCode}
% where the mirror hook is the other element of the mirrored hook
% pair and \meta{relation\LHXStar} is the mirror of \meta{relation}
% according to:
% \begin{center}
% \begin{tabular}{|l|l|}
% \hline
% \meta{relation} & \meta{relation\LHXStar} \\\hline
% |before| & |after| \\\hline
% |after| & |before| \\\hline
% |incompatible-warning| & |incompatible-warning| \\\hline
% |incompatible-error| & |incompatible-error| \\\hline
% |voids| & |voids| \\\hline
% |unrelated| & |unrelated| \\\hline
% \end{tabular}
% \end{center}
%
% \begin{function}[added=2024-01-01]{\ClearMirroredHookRulePair}
%   \begin{syntax}
%     \cs{ClearMirroredHookRulePair}\Arg{hook-spec}\Arg{label-spec_1}\Arg{label-spec_2}
%   \end{syntax}
% Raises an error if the specified hook does not belong to a
% mirrored hook pair, otherwise synonym of each instruction amongst
% \begin{lthooksCode}
%    \ROW\cs{DeclareHookPairRule}
%    \ROW\TAB\Arg{hook-spec}\Arg{label-spec_1}|{unrelated}|\Arg{label-spec_2}\\
%    \ROW\cs{hook_pair_gset_rule:nnnn}\\
%    \ROW\TAB\Arg{hook-spec} \Arg{label-spec_1} |{unrelated}| \Arg{label-spec_2}
% \end{lthooksCode}
% \end{function}
%
%
% \subsection{Managing the \protect\meta{current name}}
% \label{sec:Managing-the-current-name}
%
% As explained in section \ref{sec:Command-arguments}, a single
% leading \enquote{|.|} in a \meta{hook-spec} or \meta{label-spec} argument is
% replaced by the \meta{current name}, which is generally a
% package name, the class name or \enquote{|top-level|},
% depending on the execution context.
% This is also the default value of the optional \meta{label-spec} argument
% when not provided.
% For example,
% inside the package \texttt{mypackage.sty}, the current name is
% \enquote{\hook{mypackage}}, so the instructions:
% \begin{lthooksCode}
%   \ROW|\NewHook   {./hook}|\\
%   \ROW|\AddToHook {./hook}[.]{code}     % |\IT{Same as }|\AddToHook{./hook}{code}|\\
%   \ROW|\AddToHook {./hook}[./sub]{code}|\\
%   \ROW|\DeclareHookRule{begindocument}{.}{before}{babel}|\\
%   \ROW|\AddToHook {file/foo.tex/after}{code}|\\
% \end{lthooksCode}
%    are equivalent to:
% \begin{lthooksCode}
%   \ROW|\NewHook   {mypackage/hook}|\\
%   \ROW|\AddToHook {mypackage/hook}[mypackage]{code}|\\
%   \ROW|\AddToHook {mypackage/hook}[mypackage/sub]{code}|\\
%   \ROW|\DeclareHookRule{begindocument}{mypackage}{before}{babel}|\\
%   \ROW|\AddToHook {file/foo.tex/after}{code}                  % |\IT{unchanged}
% \end{lthooksCode}
% If you definitely want a single literal leading \enquote{\hook{.}},
% let the whole \meta{hook-spec} or \meta{label-spec} be enclosed in two
% pairs of braces like in
% \begin{lthooksCode}
%   \ROW|\NewHook   {{./hook}}|\\
%   \ROW|\AddToHook {{./hook}}[{{.}}]{code}|\\
%   \ROW|\AddToHook {{./hook}}[{{./sub}}]{code}|\\
%   \ROW|\DeclareHookRule{begindocument}{{.}}{before}{babel}|\\
% \end{lthooksCode}
%
% Internally, \LaTeX\ manages a stack of names, starting with the
% reserved \enquote{|top-level|} name.
% The top element of this stack is the \meta{current name}.
% Next commands interact with this stack.
%
% \begin{function}[added = 2024-01-01]{
%   \PushHookCurrentName,
%   \PopHookCurrentName,
%   \hook_current_name_push:n,
%   \hook_current_name_pop:,
% }
%   \begin{syntax}
% \LEFT{\cs{PushHookCurrentName}\Arg{name}}^^A
%\RIGHT{\cs{hook_current_name_push:n} \Arg{name}}
% \LEFT{\TAB\meta{code}}^^A
%\RIGHT{\TAB\meta{code}}
% \LEFT{\cs{PopHookCurrentName}}^^A
%\RIGHT{\cs{hook_current_name_pop:}}
%   \end{syntax}
%   \cs{PushHookCurrentName} pushes \meta{name} to the top of the
%   name stack such that it becomes the \meta{current name}.
%   \cs{PopHookCurrentName} pops the top value from the stack such
%   that the \meta{current name} falls back to its previous value.
%   Both commands must be properly balanced.
%   An error is raised if the \meta{name} argument expands to the value
%   \enquote{|top-level|} which is reserved to the main document.
% \end{function}
%
%   \medskip
%   Loading a class or a package is like running
%   \begin{lthooksCode}
%     \ROW\cs{PushHookCurrentName}|{|\meta{package/class name}|}| \\
%     \ROW ~~\meta{whole package/class code}\\
%     \ROW\cs{PopHookCurrentName}
%   \end{lthooksCode}
%   and inside a package or class, the \meta{current name} is
%   initially the package or class name.
%
% Notice that when, for example, a package defines a hook inside a
% command body, this command may be executed after the package
% has loaded. In that case, the \meta{current name} has changed
% and the leading dot no longer refers to the original package,
% it may be replaced by the wrong value causing unexpected
% results.
%
%   The \LaTeX\ kernel commands related to file input like \cs{input}
%   and \cs{include} do not set the \meta{current name}.
%   Files inherit the \meta{current name} from the calling context,
%   and pass its value back to the caller when processed.
%
%   Packages that provide their own package-like interfaces
%   (Ti\textit{k}Z's \cs{usetikzlibrary}, for example) can use
%   \cs{PushHookCurrentName} and \cs{PopHookCurrentName} to set
%   dedicated labels and to emulate \cs{usepackage}-like hook behavior
%   within those contexts.
%
% \begin{function}[added = 2024-01-01]{
%   \SetHookCurrentName,
%   \hook_current_name_set:n,
% }
%   \begin{syntax}
% \LEFT{\cs{SetHookCurrentName}\Arg{name}}^^A
%\RIGHT{\cs{hook_current_name_set:n} \Arg{name}}
%   \end{syntax}
%   Replaces the top element of the name stack with \meta{name}
%   expanded value, such that it becomes the \meta{current name}.
%   The \meta{name} argument cannot expand to the value
%   \enquote{|top-level|} which is reserved to the main document.
%   Raises an error when directly used in the main document,
%   however it can be used there between balancing calls to
%   \cs{PushHookCurrentLabel} and \cs{PopHookCurrentLabel}.
%
%   This command is useful when a large package is composed of several
%   smaller packages, but all should share the same default hook or label name, so
%   \cs{SetHookCurrentName} can be used at the beginning of each
%   smaller package file.
% \end{function}
%
% \begin{function}[added = 2024-01-01]{
%   \DebugHookCurrentName,
% }
%   \begin{syntax}
% \cs{DebugHookCurrentName}
%   \end{syntax}
%   Expand to the \meta{current name}.
%   This function is not protected,
%   it is mainly usefull for debugging and testing purposes.
% \end{function}
%
% \medskip
%
%   Prior to version 2024-01-01, these commands were named
%   \cs{PushHookCurrentLabel}, \cs{PopHookCurrentLabel} and
%   \cs{SetHookCurrentLabel}. Old commands are still available but will
%   be deprecated in a forthcoming release.
%   No \LaTeX3 function was exposed.
%
%
% \subsection{Querying hooks}
% \label{sec:querying}
%
% In general, commands that represent simple data, like token lists,
% have three possible states: exist; exist and empty; and don't exist.
% On the contrary, hooks are entities that always exist:
% you can always add or remove code chunks to hooks and you can
% always define rules involving hooks, as long as it remains consistent.
% This allows package \pkg{pkg-B} to amend a hook defined in package \pkg{pkg-A},
% even if \pkg{pkg-A} is loaded after \pkg{pkg-B} or
% if \pkg{pkg-A} is never loaded at all. 
%
% Given these facts, a pragmatic question is whether a hook will execute
% code when used. For this we can test emptiness and usability.
%
% \begin{function}[EXP]{\IfHookEmptyTF}
%   \begin{syntax}
%     \cs{IfHookEmptyTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
% \end{function}
% \vskip-\baselineskip
% \begin{function}[pTF,EXP]{\hook_if_empty:n}
%   \begin{syntax}
%     \cs{hook_if_empty:nTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the hook with the given name is \emph{empty},
%   \emph{i.e.} any code ever added has been removed via
%   \cs{RemoveFromHook} or similar, or consumed on use for
%   \hook{next-only} code. Adding an empty code chunk to an empty
%   hook, makes it non empty, except for \hook{top-level} label.
%   Branches to either \meta{true code} or \meta{false code}
%   depending on the result.
%   \cs{ShowHook} output shows the emptiness.
% \end{function}
%
% \begin{function}[EXP]{\IfHookUsableTF}
%   \begin{syntax}
%     \cs{IfHookUsableTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
% \end{function}
% \vskip-\baselineskip
% \begin{function}[pTF,EXP,added=2024/01/01]{\hook_if_usable:n}
%   \begin{syntax}
%     \cs{hook_if_usable:nTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the hook with the given name is usable, \emph{i.e.}
%   has been declared with \cs{NewHook} (or some variant thereof),
%   or is a generic hook, either builtin or
%   explicitly activated with \cs{ActivateGenericHook},
%   and which was not disabled by \cs{DisableGenericHook}.
%   Branches to either \meta{true code} or \meta{false code}
%   depending on the result.
%   When a hook is usable, its code gets executed when
%   \cs{UseHook}-like commands are executed.
%   \cs{ShowHook} output displays an execution order exactly when
%   the hook is usable.
% \end{function}
%
% \begin{function}[EXP]{\IfHookPairedTF}
  %   \begin{syntax}
  %     \cs{IfHookPairedTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
  %   \end{syntax}
  % \end{function}
  % \vskip-\baselineskip
  % \begin{function}[EXP,pTF,added=2024/01/01]{\hook_if_paired:n}
  %   \begin{syntax}
  %     \cs{hook_if_paired:nTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
  %   \end{syntax}
  %   Tests if the named hook belongs to a mirrored hook pair, and
  %   branches to either \meta{true code} or \meta{false code} depending
  %   on the result.
  % Belonging to a mirrored hook pair means one of
  % \begin{itemize}
  % \item the hook has been explictly declare with
  % \cs{NewMirroredHookPair} or similar;
  % \item the hook belongs to a pair of \hook{\meta{...}/before} and
  % \hook{\meta{...}/after} builtin generic hooks.
  % \end{itemize}
  % \end{function}
  %
  % \begin{function}[EXP]{\IfGenericHookDisabledTF}
%   \begin{syntax}
%     \cs{IfGenericHookDisabledTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
% \end{function}
% \vskip-\baselineskip
% \begin{function}[pTF,EXP,added=2024/01/01]{\hook_if_generic_disabled:nTF}
%   \begin{syntax}
%     \cs{hook_if_generic_disabled:nTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the generic hook with the given name has been disabled
%   by \cs{DisableGenericHook} or similar.
%   Branches to either \meta{true code} or \meta{false code}
%   depending on the result.
%   \cs{ShowHook} output shows the disable status of a generic hook.
% \end{function}
%
% \begin{function}[EXP]{\IfHookConsumedTF}
%   \begin{syntax}
%     \cs{IfHookConsumedTF} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
% \end{function}
% \vskip-\baselineskip
% \begin{function}[EXP, pTF, added=2024/01/01]{\hook_if_consumed:n}
%   \begin{syntax}
%     \cs{hook_if_consumed:n} \Arg{hook-name\LHXStar} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the named hook has been consumed by a call to
%   \cs[no-index]{UseOneTimeHook...}, and
%   branches to either \meta{true code} or \meta{false code} depending
%   on the result.
% \end{function}
%
%
% \subsection{Displaying hook code}
%
%    If one has to adjust the code execution in a hook using a hook
%    rule it is helpful to get some information about the code
%    associated with a hook, its current order and the existing rules.
%
% \begin{function}{\ShowHook,\hook_show:n,\LogHook,\hook_log:n}
%   \begin{syntax}
% \LEFT{\cs{ShowHook} \Arg{hook-spec}}^^A
% \RIGHT{\cs{hook_show:n} \Arg{hook-spec}}
% \LEFT{\cs{LogHook} \Arg{hook-spec}}^^A
% \RIGHT{\cs{hook_log:n} \Arg{hook-spec}}
%   \end{syntax}
%   Displays information about the specified hook such as
%   \begin{itemize}
%   \item
%      the code chunks added to it, by label including
%      \enquote{\hook{top-level}}, and for next-only use,
%   \item
%      any default rules set up to order them,
%   \item
%      any rules set up to order them,
%   \item
%      the computed order in which the chunks are executed,
%   \end{itemize}
% \end{function}
%
%   \cs{LogHook} and \cs{hook_log:n} print the information to the |.log| file,
%   \cs{ShowHook} and \cs{hook_show:n} print them to the terminal/command window
%   and start \TeX's prompt (only in \cs{errorstopmode}) to wait for user action.
%
%
% \subsection{Debugging or testing hook code}
%
% \begin{function}{\DebugHooksOn,\hook_debug_on:,\DebugHooksOff,\hook_debug_off:}
%   \begin{syntax}
% \LEFT{\cs{DebugHooksOn}}^^A
% \RIGHT{\cs{hook_debug_on:}}
% \LEFT{\cs{DebugHooksOff}}^^A
% \RIGHT{\cs{hook_debug_off:}}
%   \end{syntax}
%    Turn the debugging of hook code on or off. This displays most changes
%    made to the hook data structures. The output is rather coarse and
%      primarily intended for debugging or testing purposes.
% \end{function}
%
% \begin{function}{\DebugPrintHook}
%   \begin{syntax}
%     \cs{DebugPrintHook} \Arg{hook-spec}
%   \end{syntax}
%    Prints information about the hook. The output is rather coarse and
%      primarily intended for debugging or testing purposes.
% \end{function}
%
%
% \subsection{Private \LaTeX{} kernel hooks}
%
%    There are a few places where it is absolutely essential for
%    \LaTeX{} to function correctly that code is executed in a precisely
%    defined order. Even that could have been implemented with the
%    hook management (by adding various rules to ensure the
%    appropriate ordering with respect to other code added by
%    packages). However, this makes every document unnecessary
%    slow, because there has to be sorting even though the result is
%    predetermined. Furthermore it forces package writers to
%    unnecessarily add such rules if they add further code to the hook
%    (or break \LaTeX{}).
%
%    For that reason such code is not using the hook management, but
%    instead private kernel commands directly before or after a public
%    hook with the following naming
%    convention: \cs{@kernel@before@\meta{hook}} or
%    \cs{@kernel@after@\meta{hook}}. For example, in
%    \cs{enddocument} you find
%\begin{lthooksCode}
%\ROW|\UseHook{enddocument}%|\\
%\ROW|\@kernel@after@enddocument|\\
%\end{lthooksCode}
%    which means first the user/package-accessible \hook{enddocument}
%    hook is executed and then the internal kernel hook. As their name
%    indicates these kernel commands should not be altered by third-party
%    packages, so please refrain from that in the interest of
%    stability and instead use the public hook next to it.\footnote{As
%    with everything in \TeX{} there is not enforcement of this rule,
%    and by looking at the code it is easy to find out how the kernel
%    adds to them. The main reason of this section is therefore to say
%    \enquote{please don't do that, this is unconfigurable code!}}
%
%
%
% \subsection{Legacy \LaTeXe{} interfaces}
%
% \newcommand\onetimetext{This is a one-time hook, so after it
%   is executed, all further
%   attempts to add code to it will execute such code immediately
%   (see section~\ref{sec:One-time-hooks}).}
%
%  \LaTeXe{} offered a small number of hooks together with commands to
%    add to them. They are listed here and are retained for backwards
%    compatibility.
%
%  With the new hook management, several additional hooks have been added
%    to \LaTeX\ and more will follow. See the next section for what
%    is already available.
%
%
% \begin{function}{\AtBeginDocument}
%   \begin{syntax}
%     \cs{AtBeginDocument} \oarg{label-spec} \Arg{code}
%   \end{syntax}
%   If used without the optional argument \meta{label-spec}, it works essentially
%    like before, i.e., it is adding \meta{code} to the hook
%    \hook{begindocument}
%    (which is executed inside \verb=\begin{document}=).
%    However, all code added this way is labeled with the label
%    \hook{top-level} (see section~\ref{sec:Managing-the-current-name})
%    if done outside of a package or class or with the
%    package/class name if called inside such a file
%    (see sections~\ref{sec:Command-arguments} and \ref{sec:Managing-the-current-name}).
%
%    This way one can add code to the hook using
%    \cs{AddToHook} or \cs{AtBeginDocument} using a different label
%    and explicitly order the code chunks as necessary, e.g., run some
%    code before or after another package's code.  When using the
%    optional argument the call is equivalent to running
%    \cs{AddToHook} \texttt{\{begindocument\}} \oarg{label}
%    \Arg{code}.
%
%    \cs{AtBeginDocument} is a wrapper around the \hook{begindocument}
%    hook (see section~\ref{sec:begindocument-hooks}), which is a
%    one-time hook.  As such, after the \hook{begindocument} hook is
%    executed at \verb=\begin{document}= any attempt to add \meta{code}
%    to this hook with \cs{AtBeginDocument} or with \cs{AddToHook} will
%    cause that \meta{code} to execute immediately instead.
%    See section~\ref{sec:One-time-hooks} for more on one-time hooks.
%
%    For important packages with known order requirement we may over
%    time add rules to the kernel (or to those packages) so that they
%    work regardless of the loading-order in the document.
% \end{function}
%
% \begin{function}{\AtEndDocument}
%   \begin{syntax}
%     \cs{AtEndDocument} \oarg{label} \Arg{code}
%   \end{syntax}
%   Like \cs{AtBeginDocument} but for the \hook{enddocument} hook.
% \end{function}
%
%    \bigskip
%
%    The few hooks that existed previously in \LaTeXe{} used internally
%    commands such as \cs{@begindocumenthook} and packages sometimes
%    augmented them directly rather than working through
%    \cs{AtBeginDocument}. For that reason there is currently support
%    for this, that is, if the system detects that such an internal
%    legacy hook command contains code it adds it to the new hook
%    system under the label \texttt{legacy} so that it doesn't get
%    lost.
%
%    However, over time the remaining cases of direct usage need
%    updating because in one of the future release of \LaTeX{} we will
%    turn this legacy support off, as it does unnecessary slow down
%    the processing.
%
%
% \section{\LaTeXe{} commands and environments augmented by hooks}
% \label{sec:LaTeX-hooks}
%
% \subsection{Builtin generic hooks}
% \label{sec:generic}
% \label{sec:LaTeX-generic-hooks}
%
% As stated earlier, all hooks must be declared with \cs{NewHook} or similar
% before they can be used, except generic hooks.
% \LaTeX2e\ provides us with sets of builtin generic hooks which names
% have the form \enquote{\meta{type}/\meta{variable part}/\meta{position}}.
%
% Each of the hooks above are detailed in the following sections and
% in linked documentation.
% ^^A^^A^^A \pho{Wouldn't it be better to document all hooks here?}
%
% \subsubsection{Generic hooks for all environments}
%
%    Every environment \meta{env}\footnote{\meta{env} is subject to usual restrictions on the environment name: only ascii letters, digits and \enquote{\texttt{*}}, as well as no leading \enquote{\texttt{end}}.} has four associated hooks coming
%    with it:
%    \begin{description}
%    \item[\hook{env/\meta{env}/before}]
%
%       This hook is executed as part of \cs{begin} as the very first
%       action, in particular prior to starting the environment group.
%       Its scope is therefore not restricted by the environment.
%
%    \item[\hook{env/\meta{env}/begin}]
%
%       This hook is executed as part of \cs{begin} directly in front
%       of the code specific to the environment start (i.e.,
%       the second argument of \cs{newenvironment} or
%       the third argument of \cs{NewDocumentEnvironment}).
%       Its scope is the environment body.
%
%    \item[\hook{env/\meta{env}/end}]
%
%       This hook is executed as part of \cs{end} directly in front of the
%       code specific to the end of the environment (i.e.,
%       the third argument of \cs{newenvironment}
%       or the fourth argument of \cs{NewDocumentEnvironment}).
%
%    \item[\hook{env/\meta{env}/after}]
%
%       This reversed hook is executed as part of \cs{end} after the
%       code specific to the environment end and after the environment
%       group has ended.
%       Its scope is therefore not restricted by the environment.
%       It is the mirror of the direct hook \hook{env/\meta{env}/before}.
%
%    \end{description}
%    Generic environment hooks are never one-time hooks even with
%    environments that are supposed to appear only once in a
%    document.
%
%    The hooks are only executed if
%    \texttt{\cs{begin}\Arg{env}...\cs{end}\Arg{env}} is used.
%    If the environment code is executed
%    via low-level calls to \cs[no-index]{\meta{env}} and \cs[no-index]{end\meta{env}}
%    (e.g., to avoid the environment grouping) they are not
%    available. If you want them available in code using this method,
%    you can emulate the sandard behavior with
%\begin{lthooksCode}
%\ROW\cs{UseHook}|{|\hook{env/quote/before}|}%|\\
%\ROW|\quote|\\
%\ROW\cs{UseHook}|{|\hook{env/quote/begin}|}%|\\
%\ROW|...|\\
%\ROW\cs{UseHook}|{|\hook{env/quote/end}|}%|\\
%\ROW|\endquote|\\
%\ROW\cs{UseHook}|{|\hook{env/quote/after}|}%|\\
%\end{lthooksCode}
%
%    Next commands to set environment hooks are available
%    for compatibility with existing packages. We recommend
%    directly using \cs{AddToHook} and the hook names instead.
%
%
% \begin{function}{\BeforeBeginEnvironment}
%   \begin{syntax}
%     \cs{BeforeBeginEnvironment} \oarg{label-spec} \Arg{env} \Arg{code}
%   \end{syntax}
%   Synonym of \cs{AddToHook}|{|\hook{env/\meta{env}/before}|}|\texttt{\oarg{label-spec}\Arg{code}}.
% \end{function}
%
% \begin{function}{\AtBeginEnvironment}
%   \begin{syntax}
%     \cs{AtBeginEnvironment} \oarg{label-spec} \Arg{env} \Arg{code}
%   \end{syntax}
%   Synonym of \cs{AddToHook}|{|\hook{env/\meta{env}/begin}|}|\texttt{\oarg{label-spec}\Arg{code}}.
% \end{function}
%
% \begin{function}{\AtEndEnvironment}
%   \begin{syntax}
%     \cs{AtEndEnvironment} \oarg{label-spec} \Arg{env} \Arg{code}
%   \end{syntax}
%   Synonym of \cs{AddToHook}|{|\hook{env/\meta{env}/end}|}|\texttt{\oarg{label-spec}\Arg{code}}.
% \end{function}
%
% \begin{function}{\AfterEndEnvironment}
%   \begin{syntax}
%     \cs{AfterEndEnvironment} \oarg{label-spec} \Arg{env} \Arg{code}
%   \end{syntax}
%   Synonym of \cs{AddToHook}|{|\hook{env/\meta{env}/after}|}|\texttt{\oarg{label-spec}\Arg{code}}.
% \end{function}
%
%
% \subsubsection{Generic hooks for commands}
% \label{sec:Generic-hooks-for-commands}
%    While executing the \cs{\meta{name}} command, the direct hook
%    \hook{cmd/\meta{name}/before} is executed before the command body.
%    Its mirror reverse hook \hook{cmd/\meta{name}/after} is executed
%    after the command body.
%    In practice there are restrictions, in particular
%    the \hook{.../after} hook does not always work. More precisions in
%    \texttt{ltcmdhooks-doc.pdf} or with code in
%    \texttt{ltcmdhooks-code.pdf}.
%
%
% \subsubsection{Generic hooks provided by file loading operations}
%
%    There are several hooks used during \LaTeX{}'s process of loading
%    file via its high-level interfaces such as \cs{input},
%    \cs{include}, \cs{usepackage}, \cs{documentclass},
%    \cs{RequirePackage}, etc. These
%    are documented in \texttt{ltfilehook-doc.pdf} or with code in
%    \texttt{ltfilehook-code.pdf}.
%
%
% \subsection{Hooks provided by \cs{begin}\texttt{\{document\}}}
% \label{sec:begindocument-hooks}
%
%    Until 2020 \cs{begin}\texttt{\{document\}} offered exactly one
%    hook that one could add to using
%    \cs{AtBeginDocument}. Experiences over the years have shown that
%    this single hook in one place was not enough and as part of
%    adding the general hook management system a number of additional
%    hooks have been added at this point. The places for these hooks have
%    been chosen to provide the same support as offered by external
%    packages, such as \pkg{etoolbox} and others that augmented
%    \cs{document} to gain better control.
%
%    Supported are now the following hooks (all of them one-time hooks):
%    \begin{description}
%
%
%    \item[\hook{begindocument/before}]
%
%      This hook is executed at the very start of \cs{document}, one can
%      think of it as a hook for code at the end of the preamble
%      section and this is how it is used by \pkg{etoolbox}'s
%      \cs{AtEndPreamble}.
%
%      \onetimetext
%
%    \item[\hook{begindocument}]
%
%      This hook is added to by using \cs{AddToHook}\texttt{\{begindocument\}}
%      or by using \cs{AtBeginDocument} and it is
%      executed after the \texttt{.aux} file has been read and most
%      initialization are done, so they can be altered and inspected by
%      the hook code. It is followed by a small number of further
%      initializations that shouldn't be altered and are therefore
%      coming later.
%
%      The hook should not be used to add material for typesetting as
%      we are still in \LaTeX's initialization phase and not in the
%      document body. If such material needs to be added to the document
%      body use the next hook instead.
%
%      \onetimetext
%
%    \item[\hook{begindocument/end}]
%
%      This hook is executed at the end of the \cs{document} code in
%      other words at the beginning of the document body. The only
%      command that follows it is \cs{ignorespaces}.
%
%      \onetimetext
%
%    \end{description}
%    The generic hooks executed by \cs{begin} also exist, i.e.,
%    \hook{env/document/before} and \hook{env/document/begin}, but
%    with this special environment it is better use the dedicated
%    one-time hooks above.
%
%
%
%
% \subsection{Hooks provided by \cs{end}\texttt{\{document\}}}
%
%    \LaTeXe{} has always provided \cs{AtEndDocument} to add code to the
%    \verb=\end{document}=, just in front of the code that
%    is normally executed there. While this was a big improvement over
%    the situation in \LaTeX\,2.09, it was not flexible enough for a
%    number of use cases and so packages, such as \pkg{etoolbox},
%    \pkg{atveryend} and others patched \cs{enddocument} to add
%    additional points where code could be hooked into.
%
%    Patching using packages is always problematical as leads to
%    conflicts (code availability, ordering of patches, incompatible
%    patches, etc.).  For this reason a number of additional hooks
%    have been added to the \cs{enddocument} code to allow packages
%    to add code in various places in a controlled way without the
%    need for overwriting or patching the core code.
%
%    Supported are now the following hooks (all of them one-time hooks):
%    \begin{description}
%
%    \item[\hook{enddocument}]
%
%      The hook associated with \cs{AtEndDocument}. It is immediately
%      called at the beginning of \cs{enddocument}.
%
%      When this hook is executed there may be still unprocessed
%      material (e.g., floats on the deferlist) and the hook may add
%      further material to be typeset. After it, \cs{clearpage} is
%      called to ensure that all such material gets typeset. If there
%      is nothing waiting the \cs{clearpage} has no effect.
%
%      \onetimetext
%
%    \item[\hook{enddocument/afterlastpage}]
%
%      As the name indicates this hook should not receive code that
%      generates material for further pages. It is the right place to
%      do some final housekeeping and possibly write out some
%      information to the \texttt{.aux} file (which is still open at
%      this point to receive data, but since there will be no more pages you
%      need to write to it using \cs{immediate}\cs{write}). It is also the
%      correct place to
%      set up any testing code to be run when the \texttt{.aux} file
%      is re-read in the next step.
%
%
%      After this hook has been executed the \texttt{.aux} file is
%      closed for writing and then read back in to do some tests
%      (e.g., looking for missing references or duplicated labels, etc.).
%
%      \onetimetext
%
%    \item[\hook{enddocument/afteraux}]
%
%      At this point, the \texttt{.aux} file has been reprocessed and so
%      this is a possible place for final checks and display of
%      information to the user. However, for the latter you might
%      prefer the next hook, so that your information is displayed after the
%      (possibly longish) list of files if that got requested via \cs{listfiles}.
%
%      \onetimetext
%
%    \item[\hook{enddocument/info}]
%
%      This hook is meant to receive code that write final information
%      messages to the terminal. It follows immediately after the
%      previous hook (so both could have been combined, but then
%      packages adding further code would always need to also supply
%      an explicit rule to specify where it should go.
%
%      This hook already contains some code added by the kernel (under
%      the labels \texttt{kernel/filelist} and
%      \texttt{kernel/warnings}), namely the list of files when
%      \cs{listfiles} has been used and the warnings for duplicate
%      labels, missing references, font substitutions etc.
%
%      \onetimetext
%
%    \item[\hook{enddocument/end}]
%
%      Finally, this hook is executed just in front of the final call
%      to \cs{@{}@end}.
%
%      \onetimetext % is it even possible to add code after this one?
%
%    \end{description}
%
%
%    There is also the hook \hook{shipout/lastpage}. This hook is
%    executed as part of the last \cs{shipout} in the document to
%    allow package to add final \cs{special}'s to that page. Where
%    this hook is executed in relation to those from the above list
%    can vary from document to document. Furthermore to determine correctly
%    which of the \cs{shipout}s is the last one, \LaTeX{} needs to be run
%    several times, so initially it might get executed on the wrong
%    page. See section~\ref{sec:shipout} for where to find the details.
%
%
%    It is in also possible to use the generic \hook{env/document/end}
%    hook which is executed by \cs{end}, i.e., just in front of the
%    first hook above. Note however that the other generic \cs{end}
%    environment hook, i.e., \hook{env/document/after} will never get
%    executed, because by that time \LaTeX{} has finished the document
%    processing.
%
%
%
%
% \subsection{Hooks provided by \cs{shipout} operations}
% \label{sec:shipout}
%
%    There are several hooks and mechanisms added to \LaTeX{}'s
%    process of generating pages. These are documented in
%    \texttt{ltshipout-doc.pdf} or with code in
%    \texttt{ltshipout-code.pdf}.
%
%
% \subsection{Hooks provided for paragraphs}
% \label{sec:para}
%
%    The paragraph processing has been augmented to include a number of
%    internal and public hooks. These are documented in
%    \texttt{ltpara-doc.pdf} or with code in
%    \texttt{ltpara-code.pdf}.
%
%
%
% \subsection{Hooks provided in NFSS commands}
%
%    In languages that need to support for more than one script in
%    parallel (and thus several sets of fonts, e.g., supporting both Latin and
%    Japanese fonts), NFSS font commands such as \cs{sffamily} need
%    to switch both the Latin family to ``Sans Serif'' and in addition
%    alter a second set of fonts.
%
%    To support this, several NFSS commands have hooks to which 
%    such support can be added.
%    \begin{description}
%
%    \item[\hook{rmfamily}]
%
%      After \cs{rmfamily} has done its initial checks and prepared a
%      font series update, this hook is executed before \cs{selectfont}.
%
%    \item[\hook{sffamily}]
%
%      This is like the \hook{rmfamily} hook, but for the \cs{sffamily} command.
%
%    \item[\hook{ttfamily}]
%
%      This is like the \hook{rmfamily} hook, but for the \cs{ttfamily} command.
%
%    \item[\hook{normalfont}]
%
%      The \cs{normalfont} command resets the font encoding, family, series
%      and shape to their document defaults. It then executes this
%      hook and finally calls \cs{selectfont}.
%
%    \item[\hook{expand@font@defaults}]
%
%      The internal \cs{expand@font@defaults} command expands and
%      saves the current defaults for the meta families (rm/sf/tt) and
%      the meta series (bf/md). If the NFSS machinery has been
%      augmented, e.g., for Chinese or Japanese fonts, then further
%      defaults may need to be set at this point. This can be done in
%      this hook which is executed at the end of this macro.
%
%    \item[\hook{bfseries/defaults}, \hook{bfseries}]
%
%      If the \cs{bfdefault} was explicitly changed by the user, its
%      new value is used to set the bf series defaults for the meta
%      families (rm/sf/tt) when \cs{bfseries} is called. The
%      \hook{bfseries/defaults} hook allows further adjustments to be made
%      in this case.  This hook is only executed if such a change is
%      detected. In contrast, the \hook{bfseries} hook is always
%      executed just before \cs{selectfont} is called to change to the
%      new series.
%
%
%    \item[\hook{mdseries/defaults}, \hook{mdseries}]
%
%       These two hooks are like the previous ones but they are in the
%      \cs{mdseries} command.
%
%    \item[\hook{selectfont}]
%
%      This hook is executed inside \cs{selectfont}, after the current
%      values for \textit{encoding}, \textit{family}, \textit{series},
%      \textit{shape}, and \textit{size} are evaluated and the new font
%      is selected (and if necessary loaded). After the hook has
%      executed, NFSS will still do any updates necessary for a new
%      \textit{size} (such as changing the size of \cs{strut}) and any
%      updates necessary to a change in \textit{encoding}.
%
%      This hook is intended for use cases where, in parallel to a
%      change in the main font, some other fonts need to be altered 
%      (e.g., in CJK processing where you may need to deal with several
%      different alphabets).
%
%    \end{description}
%
%
%
% \subsection{Hook provided by the mark mechanism}
%
%    See \texttt{ltmarks-doc.pdf} for details.
%    \begin{description}
%
%    \item[\hook{insertmark}]
%
%      This hook allows for a special setup while \cs{InsertMark}
%      inserts a mark. It is executed in group so local changes only
%      apply to the mark being inserted.
%
%    \end{description}
%
% \MaybeStop{\setlength\IndexMin{200pt}  \PrintIndex  }
%
%
% \section{The Implementation}
%
% In the sequel \meta{hook} stands for a hook name.
%
%    \begin{macrocode}
%<@@=hook>
%    \end{macrocode}
%
% \changes{v1.0i}{2021/03/18}{Use \cs{NewModuleRelease}.}
% \changes{v1.0n}{2021/05/24}{Use \cs{msg_...} instead of \cs{__kernel_msg...}}
%
%    \begin{macrocode}
%<*2ekernel|latexrelease>
\ExplSyntaxOn
%<latexrelease>\NewModuleRelease{2020/10/01}{lthooks}
%<latexrelease>                 {The~hook~management~system}
%    \end{macrocode}
%
%  \subsection{Debugging}
%
%  \begin{macro}{\g_@@_debug_bool}
%    Holds the current debugging state.
%    \begin{macrocode}
\bool_new:N \g_@@_debug_bool
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_debug_on:,\hook_debug_off:}
%  \begin{macro}{\@@_debug:n}
%  \begin{macro}{\@@_debug_gset:}
%    Turns debugging on and off by redefining \cs{@@_debug:n}.
%    \begin{macrocode}
\cs_new_eq:NN \@@_debug:n \use_none:n
\cs_new_protected:Npn \hook_debug_on:
  {
    \bool_gset_true:N \g_@@_debug_bool
    \@@_debug_gset:
  }
\cs_new_protected:Npn \hook_debug_off:
  {
    \bool_gset_false:N \g_@@_debug_bool
    \@@_debug_gset:
  }
\cs_new_protected:Npn \@@_debug_gset:
  {
    \cs_gset_protected:Npx \@@_debug:n ##1
      { \bool_if:NT \g_@@_debug_bool {##1} }
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{Borrowing from internals of other kernel modules}
%
%
% \begin{macro}[EXP]{\@@_str_compare:nn}
%   Private copy of \cs{__str_if_eq:nn}
% \InternalDetectionOff
%    \begin{macrocode}
\cs_new_eq:NN \@@_str_compare:nn \__str_if_eq:nn
%    \end{macrocode}
% \InternalDetectionOn
% \end{macro}
%
%  \subsection{Declarations}
%
%  \begin{macro}{\l_@@_tmpa_bool}
%    Scratch boolean used throughout the package.
%    \begin{macrocode}
\bool_new:N \l_@@_tmpa_bool
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\l_@@_return_tl,\l_@@_tmpa_tl,\l_@@_tmpb_tl}
%    Scratch variables used throughout the package.
%    \begin{macrocode}
\tl_new:N \l_@@_return_tl
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\g_@@_all_seq}
%    In a few places we need a list of all hook names ever defined so
%    we keep track of them in this sequence.
%    \begin{macrocode}
\seq_new:N \g_@@_all_seq
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\l_@@_cur_hook_tl}
%   Stores the name of the hook currently being sorted.
%    \begin{macrocode}
\tl_new:N \l_@@_cur_hook_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_work_prop}
%   A property list holding a copy of the
%   \cs[no-index]{g_@@_\meta{hook}_code_prop} of the hook being sorted
%   to work on, so that changes don't act destructively on the hook data
%   structure.
%    \begin{macrocode}
\prop_new:N \l_@@_work_prop
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\g_@@_used_prop}
%    All hooks that receive code (for use in debugging display).
%    \begin{macrocode}
\prop_new:N \g_@@_used_prop
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\g_@@_hook_curr_name_tl,\g_@@_name_stack_seq}
%   Default label used for hook commands, and a stack to keep track of
%   packages within packages.
%    \begin{macrocode}
\tl_new:N \g_@@_hook_curr_name_tl
\seq_new:N \g_@@_name_stack_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tmp:w}
%   Temporary macro for generic usage.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_@@_empty_tl}
% \begin{macro}{\c_@@_nine_parameters_tl}
%   An empty token list, and one containing nine parameters.
% \changes{v1.1a}{2023/04/06}
%         {Add auxiliary token lists (hook-args).}
%    \begin{macrocode}
\tl_const:Nn \c_@@_empty_tl { }
\tl_const:Nn \c_@@_nine_parameters_tl { #1#2#3#4#5#6#7#8#9 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{
%     \tl_gremove_once:Nx,
%     \tl_show:x,
%     \tl_log:x,
%     \tl_set:Ne,
%     \cs_replacement_spec:c,
%     \prop_put:Nne,
%     \str_count:e
%   }
%   Some variants of \pkg{expl3} functions.
%   \fmiinline{should probably be moved to expl3}
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_gremove_once:Nn { Nx }
\cs_generate_variant:Nn \tl_show:n { x }
\cs_generate_variant:Nn \tl_log:n { x }
\cs_generate_variant:Nn \tl_set:Nn { Ne }
\cs_generate_variant:Nn \cs_replacement_spec:N { c }
\cs_generate_variant:Nn \prop_put:Nnn { Nne }
\cs_generate_variant:Nn \str_count:n { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\s_@@_mark}
%   Scan mark used for delimited arguments.
%    \begin{macrocode}
\scan_new:N \s_@@_mark
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_use_none_delimit_by_s_mark:w,
%     \@@_use_i_delimit_by_s_mark:nw
%   }
%   Removes tokens until the next \cs{s_@@_mark}.
% \changes{v1.1a}{2023/04/06}
%         {Use standard naming scheme (hook-args).}
%    \begin{macrocode}
\cs_new:Npn \@@_use_none_delimit_by_s_mark:w #1 \s_@@_mark { }
\cs_new:Npn \@@_use_i_delimit_by_s_mark:nw #1 #2 \s_@@_mark {#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_set:cn}
%   Private copies of a few \pkg{expl3} functions.  \pkg{l3debug} will
%   only add debugging to the public names, not to these copies, so we
%   don't have to use \cs{debug_suspend:} and \cs{debug_resume:}
%   everywhere.
%
%   Functions like \cs{@@_tl_set:Nn} have to be redefined, rather than
%   copied because in \pkg{expl3} they use
%   \cs[no-index]{__kernel_tl_(g)set:Nx}, which is also patched by
%   \pkg{l3debug}.
% \changes{v1.0h}{2021/01/07}{Manually define some \pkg{l3tl} commands
%     to work around \pkg{expl3} changes}
% \changes{v1.1a}{2023/04/06}
%         {Clean-up unused variants (hook-args).}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_set:cn #1#2
  { \cs_set_nopar:cpx {#1} { \__kernel_exp_not:w {#2} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gset:Nn,\@@_tl_gset:Nx,
%               \@@_tl_gset:cn,\@@_tl_gset:co,\@@_tl_gset:cx}
%   Same as above.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gset:Nn #1#2
  { \cs_gset_nopar:Npx #1 { \__kernel_exp_not:w {#2} } }
\cs_new_protected:Npn \@@_tl_gset:Nx #1#2
  { \cs_gset_nopar:Npx #1 {#2} }
\cs_generate_variant:Nn \@@_tl_gset:Nn { c, co }
\cs_generate_variant:Nn \@@_tl_gset:Nx { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_tl_gput_right:Nn,
%     \@@_tl_gput_right:Ne,
%     \@@_tl_gput_right:cn,
%   }
%   Same as above.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gput_right:Nn #1#2
  { \@@_tl_gset:Nx #1 { \__kernel_exp_not:w \exp_after:wN { #1 #2 } } }
\cs_generate_variant:Nn \@@_tl_gput_right:Nn { Ne, cn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gput_left:Nn}
%   Same as above.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gput_left:Nn #1#2
  {
    \@@_tl_gset:Nx #1
      { \__kernel_exp_not:w {#2} \__kernel_exp_not:w \exp_after:wN {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gset_eq:NN}
%   Same as above.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tl_gset_eq:NN \tl_gset_eq:NN
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gclear:N,\@@_tl_gclear:c}
%   Same as above.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gclear:N #1
  { \@@_tl_gset_eq:NN #1 \c_empty_tl }
\cs_generate_variant:Nn \@@_tl_gclear:N { c }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Providing new hooks}
%
% \subsubsection{The data structures of a hook}
%
% \DescribeMacro{\g_@@_\meta{hook}_code_prop}
% \DescribeMacro{\@@\textvisiblespace\meta{hook}}
% \DescribeMacro{\g_@@_\meta{hook}_reversed_tl}
% \DescribeMacro{\g_@@_\meta{hook}_declared_tl}
% \DescribeMacro{\g_@@_\meta{hook}_parameter_tl}
% \DescribeMacro{\@@_next\textvisiblespace\meta{hook}}
% \DescribeMacro{\@@_toplevel\textvisiblespace\meta{hook}}
%    Hooks have a name (called \meta{hook} in the description below)
%    and for each hook we have to
%    provide a number of data structures. These are
%    \begin{description}
%    \item[\cs{g_@@_\meta{hook}_code_prop}] A property list holding the code
%    for the hook in separate chunks. The keys are by default the
%    package names that add code to the hook, but it is possible
%    for packages to define other keys.
%
%    \item[{\cs[no-index]{g_@@_\meta{hook}_rule_\meta{label_1}\string|\meta{label_2}_tl}}]
%    A token list holding the relation between \meta{label_1} and
%    \meta{label_2} in the hook.  The \meta{labels} are lexically
%    (reverse) sorted to ensure that two labels always point to the same
%    token list.  For global rules, \meta{hook} is \texttt{??}.
%
%    \item[\cs{@@\textvisiblespace\meta{hook}}] The code that is actually executed
%    when the hook is called in the document is stored in this token
%    list. It is constructed from the code chunks applying the
%    information.
%    This token list is named like that so that in case of an error
%    inside the hook, the reported token list in the error is shorter,
%    and to make it simpler to normalize hook names in
%    \cs{@@_make_name:n}.
%
%    \item[\cs{g_@@_\meta{hook}_reversed_tl}] Some hooks are
%    \enquote{reversed}.  This token list stores a |-| for such hook
%    so that it can be identified.  The |-| character is used because
%    $\meta{reversed}1$ is $+1$ for normal hooks and $-1$ for reversed
%    ones.
%
%    \item[{\cs[no-index]{g_@@_\meta{hook}_declared_tl}}] This token
%    list serves as a marker for the hook being officially declared. Its
%    existence is tested to raise an error in case another declaration
%    is attempted.
%
%    \item[{\cs[no-index]{c_@@_\meta{hook}_parameter_tl}}] This token
%    list stores the parameter text for a declared hook (its existence
%    almost completely intersects the token list above), which is used
%    for managing hooks with arguments.
%
%    \item[\cs{@@_toplevel\textvisiblespace\meta{hook}}] This token list stores the code
%    inserted in the hook from the user's document, in the |top-level|
%    label.  This label is special, and doesn't participate in sorting.
%    Instead, all code is appended to it and executed after (or before,
%    if the hook is reversed) the normal
%    hook code, but before the |next| code chunk.
%
%    \item[\cs{@@_next\textvisiblespace\meta{hook}}] Finally there is
%    extra code (normally empty) that is used on the next invocation
%    of the hook (and then deleted). This can be used to define some
%    special behavior for a single occasion from within the document.
%    This token list follows the same naming scheme than the main
%    \cs{@@\textvisiblespace\meta{hook}} token list.  It is called
%    \cs{@@_next\textvisiblespace\meta{hook}} rather than
%    \cs[no-index]{@@\textvisiblespace next_\meta{hook}} because
%    otherwise a hook whose name is |next_|\meta{hook} would clash
%    with the next code-token list of the hook called \meta{hook}.
%
%    \end{description}
%
%
% \subsubsection{On the existence of hooks}
% \label{sec:existence}
%
%    A hook may be in different states of existence. Here we give an
%    overview of the internal commands to set up hooks and explain how the
%    different states are distinguished. The actual implementation
%    then follows in subsequent sections.
%
%    One problem we have to solve is that we need to be able to add
%    code to hooks (e.g., with \cs{AddToHook}) even if that code has
%    not yet been declared. For example, one package needs to write
%    into a hook of another package, but that package may not get
%    loaded, or is loaded only later. Another problem is that most hooks, 
%    but not the generic hooks, require a declaration.
%
%    We therefore distinguish the following states for a hook, which
%    are managed by four different tests: structure existence
%    (\cs{@@_if_structure_exist:nTF}), creation
%    (\cs{@@_if_usable:nTF}), declaration (\cs{@@_if_declared:nTF})
%    and disabled or not (\cs{@@_if_disabled:nTF})
%    \begin{description}
%    \setlist[itemize]{leftmargin=5cm,format=\cs}
%    \item[not existing]
%
%       Nothing is known about the hook so far. This state can be
%       detected with \cs{@@_if_structure_exist:nTF}
%       (which uses the  false branch).
%
%       In this state the hook can be declared, disabled, rules can be
%       defined or code could be added to it, but it is not possible
%       to use the hook (with \cs{UseHook}).
%
%    \item[basic data structure set up]
%
%       A hook is this state when its basic data structure has been
%       set up (using \cs{@@_init_structure:n}). The data structure setup happens
%       automatically when commands such as \cs{AddToHook}  are used
%       and the hook is at that point in state \enquote{not existing}.
%
%       In this state the four tests give the following results:
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      returns |true|.
%       \item [@@_if_usable:nTF]   returns |false|.
%       \item [@@_if_declared:nTF]  returns |false|.
%       \item [@@_if_disabled:nTF]  returns |false|.
%     \end{itemize}
%
%       The allowed actions are the same as in the \enquote{not
%       existing} state.
%
%    \item[declared]
%
%       A hook is in this state it is not disabled and was explicitly declared (e.g.,
%       with \cs{NewHook}). In this case the four tests give the
%       following results:
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      returns |true|.
%       \item [@@_if_usable:nTF]   returns |true|.
%       \item [@@_if_declared:nTF]  returns |true|.
%       \item [@@_if_disabled:nTF]  returns |false|.
%     \end{itemize}
%
%    \item[usable]
%
%       A hook is in this state if it is not disabled, was not
%       explicitly declared but nevertheless is allowed to be used
%       (with \cs{UseHook} or \cs{hook_use:n}). This state is only
%       possible for generic hooks as they do not need to be
%       declared. Therefore such hooks move directly from state
%       \enquote{not existing} to \enquote{usable} the moment a
%       declaration such as \cs{AddToHook} wants to add to the hook
%       data structure.  In this state the tests give the following
%       results:
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      returns |true|.
%       \item [@@_if_usable:nTF]   returns |true|.
%       \item [@@_if_declared:nTF]  returns |false|.
%       \item [@@_if_disabled:nTF]  returns |false|.
%     \end{itemize}
%
%
%    \item[disabled]
%
%       A generic hook in any state is moved to this state when
%       \cs{DisableGenericHook} is used. This changes the tests to give the
%       following results:
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      \emph{unchanged}.
%       \item [@@_if_usable:nTF]   returns |false|.
%       \item [@@_if_declared:nTF]  returns |true|.
%       \item [@@_if_disabled:nTF]  returns |true|.
%     \end{itemize}
%       The  structure test is unchanged (if the hook was unknown before it is
%       |false|, otherwise |true|). The usable test returns |false| so that
%       any \cs{UseHook} will bypass the hook from now on. The
%       declared test returns true so that any further \cs{NewHook}
%       generates an error and the disabled test returns true so that
%       \cs{AddToHook} can return an error.
% \fmiinline{maybe it should do this only after begin document?}
%
%    \end{description}
%
%
%
%
% \subsubsection{Setting hooks up}
%
%
%  \begin{macro}{
%    \hook_new:n,
%    \hook_new_with_args:nn
%  }
%  \begin{macro}{\@@_new:nn}
%    The \cs{hook_new:n} declaration declares a new hook and expects
%    the \meta{hook-name} as its argument, e.g.,
%    \hook{begindocument}.
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_new_with_args:nn} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new:n #1
  { \@@_normalize_hook_args:Nn \@@_new:nn {#1} { 0 } }
\cs_new_protected:Npn \hook_new_with_args:nn #1 #2
  { \@@_normalize_hook_args:Nn \@@_new:nn {#1} {#2} }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_new:nn #1 #2
  {
%    \end{macrocode}
%   We check if the hook was already \emph{explicitly} declared with
%   \cs{hook_new:n}, and if it already exists we complain, otherwise set
%   the \enquote{created} flag for the hook so that it errors next time
%   \cs{hook_new:n} is used.
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \tl_new:c { g_@@_#1_declared_tl }
        \cs_undefine:c { @@~#1 }
        \cs_undefine:c { c_@@_#1_parameter_tl }
        \@@_make_usable:nn {#1} {#2}
%    \end{macrocode}
%   In case there is already code in a hook, but it's undeclared, run
%   \cs{@@_update_hook_code:n} to make it ready to be executed (see test
%   \texttt{lthooks-034}).
% \changes{v1.1a}{2023/04/06}
%         {Update hook code after declaring.}
%    \begin{macrocode}
        \@@_update_hook_code:n {#1}
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new:n #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_new:n {#1} }
%<latexrelease>\cs_undefine:N \@@_new:nn
%<latexrelease>\cs_gset_protected:Npn \@@_new:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_declared:nTF {#1}
%<latexrelease>      { \msg_error:nnn { hooks } { exists } {#1} }
%<latexrelease>      {
%<latexrelease>        \tl_new:c { g_@@_#1_declared_tl }
%<latexrelease>        \@@_make_usable:n {#1}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_new_with_args:nn #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
%
%  \begin{macro}{\@@_make_usable:nn}
%
%    This initializes all hook data structures for the hook but if
%    used on its own doesn't mark the hook as declared (as
%    \cs{hook_new:n} does, so a later \cs{hook_new:n} on that hook will
%    not result in an error.  This command is internally used by
%    \cs{hook_gput_code:nnn} when adding code to a generic hook.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_make_usable:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_make_usable:nn #1 #2
  {
%    \end{macrocode}
%   Now we check if the hook's data structure can be safely created
%   without \pkg{expl3} raising errors, then
%   we add the hook name to the list of all hooks and
%   allocate the necessary data structures for the new hook,
%   otherwise just do nothing.
%    \begin{macrocode}
    \@@_if_usable:nF {#1}
      {
        \seq_gput_right:Nn \g_@@_all_seq {#1}
%    \end{macrocode}
%    Here we'll define the \cs[no-index]{c_@@_\meta{hook}_parameter_tl}
%    to hold a run of parameters up to the number of arguments of the
%    hook (\verb|#2|).
%    \begin{macrocode}
        \__kernel_cs_parm_from_arg_count:nnF
          { \tl_const:cn { c_@@_#1_parameter_tl } } {#2}
          {
            \msg_error:nnnn { hooks } { too-many-args } {#1} {#2}
            \tl_const:cx { c_@@_#1_parameter_tl }
              { \exp_not:V \c_@@_nine_parameters_tl }
          }
%    \end{macrocode}
%    After that, use \cs{@@_normalise_cs_args:nn} to correct the number
%    of parameters of the macros
%    \cs[no-index]{@@_toplevel\textvisiblespace\meta{hook}} and
%    \cs[no-index]{@@_next\textvisiblespace\meta{hook}}.  We need to be
%    able to add
%    code with arguments to a hook without prior knowledge of the number
%    of arguments of that hook, so \pkg{lthooks} assumes~9 until the
%    hook is properly declared and the number of arguments is known.
%    \cs{@@_normalise_cs_args:nn} does the normalisation by using the
%    \cs[no-index]{c_@@_\meta{hook}_parameter_tl} defined just above.
%    \begin{macrocode}
        \@@_normalise_cs_args:nn { _toplevel } {#1}
        \@@_normalise_cs_args:nn { _next } {#1}
%    \end{macrocode}
%    This is only used by the actual code of the current hook, so
%    declare it normally:
%    \begin{macrocode}
        \@@_code_gset:nn {#1} { }
%    \end{macrocode}
%    Now ensure that the base data structure for the hook exists:
%    \begin{macrocode}
        \@@_init_structure:n {#1}
%    \end{macrocode}
%    The call to \cs{@@_normalise_code_pool:n} will correct any improper
%    reference to arguments that don't exist in the hook, raising a
%    low-level \TeX{} error and doubling the offending parameter tokens.
%    It has to be done after \cs{@@_init_structure:n} because it
%    operates on \cs[no-index]{g_@@_\meta{hook}_code_prop}.
%    \begin{macrocode}
        \@@_normalise_code_pool:n {#1}
%    \end{macrocode}
%    The \cs{g_@@_\meta{hook}_labels_clist} holds the sorted list of
%    labels (once it got sorted). This is used only for debugging.
%    These are defined conditionally, in case \cs{@@_make_usable:nn}
%    is being used to redefine a hook.
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
        \clist_if_exist:cF { g_@@_#1_labels_clist }
          {
            \clist_new:c { g_@@_#1_labels_clist }
%    \end{macrocode}
%    Some hooks should reverse the default order of code chunks. To
%    signal this we have a token list which is empty for normal hooks
%    and contains a \verb=-= for reversed hooks.
%    \begin{macrocode}
            \tl_new:c { g_@@_#1_reversed_tl }
          }
%    \end{macrocode}
%    The above is all in L3 convention, but we also provide an
%    interface to legacy \LaTeXe{} hooks of the form \cs{@...hook},
%    e.g., \cs{@begindocumenthook}.
%    there have been a few of them and they have been added to
%    using \cs{g@addto@macro}. If there exists such a macro matching
%    the name of the new hook, i.e.,
%    \cs[no-index]{@\meta{hook}hook} and it is not empty then
%    we add its contents as a code chunk under the label \texttt{legacy}.
%    \begin{quote}
%       \textbf{Warning: this support will vanish in future releases!}
%    \end{quote}
%
%    \begin{macrocode}
        \@@_include_legacy_code_chunk:n {#1}
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_make_usable:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_make_usable:nn
%<latexrelease>\cs_gset_protected:Npn \@@_make_usable:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cF { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \seq_gput_right:Nn \g_@@_all_seq {#1}
%<latexrelease>        \tl_new:c { @@~#1 }
%<latexrelease>        \@@_init_structure:n {#1}
%<latexrelease>        \clist_new:c { g_@@_#1_labels_clist }
%<latexrelease>        \tl_new:c { g_@@_#1_reversed_tl }
%<latexrelease>        \@@_include_legacy_code_chunk:n {#1}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\@@_init_structure:n}
%    This function declares the basic data structures for a hook
%    without explicit declaring the hook itself.  This is needed to
%    allow adding to undeclared hooks.  Here it is unnecessary to
%    check whether all variables exist, since all three are declared
%    at the same time (either all of them exist, or none).
%
%    It creates the hook code pool
%    (\cs[no-index]{g_@@_\meta{hook}_code_prop}) and the |top-level|
%    and |next| token lists.  A hook is initialized with
%    \cs{@@_init_structure:n} the first time anything is added to it.
%    Initializing a hook just with \cs{@@_init_structure:n} will not
%    make it usable with \cs{hook_use:n}.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_init_structure:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_init_structure:n #1
  {
    \@@_if_structure_exist:nF {#1}
      {
        \prop_new:c { g_@@_#1_code_prop }
        \@@_toplevel_gset:nn {#1} { }
        \@@_next_gset:nn {#1} { }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_init_structure:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_init_structure:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nF {#1}
%<latexrelease>      {
%<latexrelease>        \prop_new:c { g_@@_#1_code_prop }
%<latexrelease>        \tl_new:c { @@_toplevel~#1 }
%<latexrelease>        \tl_new:c { @@_next~#1 }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{
%    \hook_new_reversed:n,
%    \hook_new_reversed_with_args:nn
%  }
%  \begin{macro}{\@@_new_reversed:nn}
%
%    Declare a new hook. The default ordering of code chunks is
%    reversed, signaled by setting the token list to a minus sign.
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_new_reversed_with_args:nn} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_reversed_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new_reversed:n #1
  { \@@_normalize_hook_args:Nn \@@_new_reversed:nn {#1} { 0 } }
\cs_new_protected:Npn \hook_new_reversed_with_args:nn #1 #2
  { \@@_normalize_hook_args:Nn \@@_new_reversed:nn {#1} {#2} }
\cs_new_protected:Npn \@@_new_reversed:nn #1 #2
  {
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \@@_new:nn {#1} {#2}
        \tl_gset:cn { g_@@_#1_reversed_tl } { - }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_reversed_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new_reversed:n #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_new_reversed:n {#1} }
%<latexrelease>\cs_undefine:N \@@_new_reversed:nn
%<latexrelease>\cs_gset_protected:Npn \@@_new_reversed:n #1
%<latexrelease>  {
%<latexrelease>    \@@_new:n {#1}
%<latexrelease>    \tl_gset:cn { g_@@_#1_reversed_tl } { - }
%<latexrelease>  }
%<latexrelease>\cs_undefine:N \@@_new_reversed:nn
%<latexrelease>\cs_gset_protected:Npn \hook_new_reversed_with_args:nn #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\c_@@_pair_\meta{hook}_tl}
% Contains the matching hook if \meta{hook} corresponds to a hook pair.
% \end{macro}
%  \begin{macro}{\hook_new_pair:nn,\hook_new_pair_with_args:nnn}
%    A shorthand for declaring a normal and a matching reversed hook in one go.
%    \cs[no-index]{c_@@_pair_\meta{hook}_tl} contains
%    \meta{mirror hook}.
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_new_pair_with_args:nnn} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_pair_with_args:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new_pair:nn #1#2
  { \@@_normalize_hook_args:Nnn \@@_new_pair:nnn {#1} {#2} { 0 } }
\cs_new_protected:Npn \hook_new_pair_with_args:nnn #1#2#3
  { \@@_normalize_hook_args:Nnn \@@_new_pair:nnn {#1} {#2} {#3} }
\cs_new_protected:Npn \@@_new_pair:nnn #1 #2 #3
  {
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \@@_if_declared:nTF {#2}
          { \msg_error:nnn { hooks } { exists } {#2} }
          {
            \@@_new:nn {#1} {#3}
            \@@_new_reversed:nn {#2} {#3}
            \tl_const:cn { c_@@_pair_#1_tl } { #2 }
            \tl_const:cn { c_@@_pair_#2_tl } { #1 }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_pair_with_args:nnn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new_pair:nn #1#2
%<latexrelease>  {
%<latexrelease>    \hook_new:n {#1}
%<latexrelease>    \hook_new_reversed:n {#2}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_new_pair_with_args:nnn #1#2#3
%<latexrelease>  { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\@@_include_legacy_code_chunk:n}
%    The \LaTeX{} legacy concept for hooks uses with hooks the
%    following naming scheme in the code: \cs{@...hook}.
%
%    If this macro is not empty we add it under the label
%    \texttt{legacy} to the current hook and then empty it globally.
%    This way packages or classes directly manipulating commands such
%    as \cs{@begindocumenthook} still get their hook data added.
%    \begin{quote}
%       \textbf{Warning: this support will vanish in future releases!}
%    \end{quote}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_include_legacy_code_chunk:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_include_legacy_code_chunk:n #1
  {
%    \end{macrocode}
%    If the macro doesn't exist (which is the usual case) then nothing
%    needs to be done.
%    \begin{macrocode}
    \tl_if_exist:cT { @#1hook }
      {
%    \end{macrocode}
%    Of course if the legacy hook exists but is empty, there is no need
%    to add anything under \texttt{legacy} the legacy label.
%    \begin{macrocode}
        \tl_if_empty:cF { @#1hook }
          {
%    \end{macrocode}
%    Here we set \cs{@@_replacing_args_false:} because no legacy code
%    will reference hook arguments.
% \changes{v1.1b}{2023/04/16}
%         {\cs{@@_replacing_args_false:} in
%          \cs{@@_include_legacy_code_chunk:n}.}
%    \begin{macrocode}
            \@@_replacing_args_false:
            \use:e
              {
                \@@_hook_gput_code_do:nnn {#1} { legacy }
                  { \exp_not:v { @#1hook } }
              }
            \@@_replacing_args_reset:
%    \end{macrocode}
%    Once added to the hook, we need to clear it otherwise it might
%    get added again  later if the hook data gets updated.
%    \begin{macrocode}
            \@@_tl_gclear:c { @#1hook }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_include_legacy_code_chunk:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_include_legacy_code_chunk:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @#1hook }
%<latexrelease>      {
%<latexrelease>        \tl_if_empty:cF { @#1hook }
%<latexrelease>          {
%<latexrelease>            \exp_args:Nnnv \@@_hook_gput_code_do:nnn
%<latexrelease>              {#1} { legacy } { @#1hook }
%<latexrelease>            \@@_tl_gclear:c { @#1hook }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Disabling and providing hooks}
%
% \changes{v1.0p}{2021/08/20}{Renames of generic hook commands (gh/638)}
%
% \begin{macro}{\hook_disable_generic:n}
% \begin{macro}{\@@_disable:n}
% \begin{macro}[pTF]{\@@_if_disabled:n}
%
%    Disables a hook by creating its
%    \cs[no-index]{g_@@_\meta{hook}_declared_tl} so that the hook
%    errors when used with \cs{hook_new:n}, then it undefines
%    \cs{@@\textvisiblespace\meta{hook}} so that it may not be executed.
%
%    This does not clear any code that may be already stored in the
%    hook's structure, but doesn't allow adding more code.
%    \cs{@@_if_disabled:nTF} uses that specific combination to check
%    if the hook is disabled.
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\hook_disable_generic:n}
%<latexrelease>                 {Disable~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \hook_disable_generic:n #1
  { \@@_normalize_hook_args:Nn \@@_disable:n {#1} }
\cs_new_protected:Npn \@@_disable:n #1
  {
    \tl_gclear_new:c { g_@@_#1_declared_tl }
    \cs_undefine:c { @@~#1 }
  }
\prg_new_conditional:Npnn \@@_if_disabled:n #1 { p, T, F, TF }
  {
    \bool_lazy_and:nnTF
        { \tl_if_exist_p:c { g_@@_#1_declared_tl } }
        { ! \cs_if_exist_p:c { @@~#1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_new_conditional:Npnn \hook_if_generic_disabled:n #1 { p, T, F, TF }
  {
    \bool_lazy_and:nnTF
        { \tl_if_exist_p:c { g_@@_#1_declared_tl } }
        { ! \cs_if_exist_p:c { @@~#1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_disable_generic:n}
%<latexrelease>                 {Disable~hooks}
%<latexrelease>
%<latexrelease>\cs_new_protected:Npn \hook_disable_generic:n #1 {}
%<latexrelease>
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hook_activate_generic:n}
% \begin{macro}{\@@_activate_generic:n}
%    The \cs{hook_activate_generic:n} declaration declares a new hook if it
%    wasn't declared already, in which case it only checks that the
%    already existing hook is not a reversed hook.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \hook_activate_generic:n #1
  { \@@_normalize_hook_args:Nn \@@_activate_generic:nn {#1} {   } }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_activate_generic:nn #1 #2
  {
%    \end{macrocode}
%    If the hook to be activated was disabled we warn (for now --- this
%    may change).
%    \begin{macrocode}
    \@@_if_disabled:nTF {#1}
      { \msg_warning:nnn { hooks } { activate-disabled } {#1} }
%    \end{macrocode}
%    Otherwise we check if the hook is not declared, and if it isn't,
%    figure out if it's reversed or not, then declare it accordingly.
%    \begin{macrocode}
      {
        \@@_if_declared:nF {#1}
          {
            \tl_new:c { g_@@_#1_declared_tl }
            \@@_make_usable:nn {#1} { 0 }
            \tl_gset:cx { g_@@_#1_reversed_tl }
              { \@@_if_generic_reversed:nT {#1} { - } }
%    \end{macrocode}
%    Reflect that we have activated the generic hook and set its
%    execution code.
% \changes{v1.0v}{2022/06/15}{Ensure that a newly activated generic hook
%               gets its execution code set}
%    \begin{macrocode}
            \@@_update_hook_code:n {#1}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \@@_activate_generic:nn #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_disabled:nTF {#1}
%<latexrelease>      { \msg_warning:nnn { hooks } { activate-disabled } {#1} }
%<latexrelease>      {
%<latexrelease>        \@@_if_declared:nF {#1}
%<latexrelease>          {
%<latexrelease>            \tl_new:c { g_@@_#1_declared_tl }
%<latexrelease>            \@@_make_usable:n {#1}
%<latexrelease>            \tl_gset:cx { g_@@_#1_reversed_tl }
%<latexrelease>              { \@@_if_generic_reversed:nT {#1} { - } }
%<latexrelease>            \@@_update_hook_code:n {#1}
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \hook_activate_generic:n #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Parsing a label}
%
% \begin{macro}[EXP]{\@@_parse_label_default:n}
%   This macro checks if a label was given (not \cs{c_novalue_tl}), and
%   if so, tries to parse the label looking for a leading \verb|.| to
%   replace by \cs{@@_currname_or_default:}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_label_default:n #1
  {
    \tl_if_novalue:nTF {#1}
      { \@@_currname_or_default: }
      { \tl_trim_spaces_apply:nN {#1} \@@_parse_dot_label:n }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_parse_dot_label:n}
% \begin{macro}[EXP]{
%     \@@_parse_dot_label:w,
%     \@@_parse_dot_label_cleanup:w,
%     \@@_parse_dot_label_aux:w
%   }
%   Start by checking if the label is empty, which raises an error, and
%   uses the fallback value.  If not,
%   split the label at a \verb|./|, if any, and check if no tokens are
%   before the \verb|./|, or if the only character is a \verb|.|.
%   If these requirements are fulfilled, the leading
%   \verb|.| is replaced with \cs{@@_currname_or_default:}.  Otherwise
%   the label is returned unchanged.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_dot_label:n #1
  {
    \tl_if_empty:nTF {#1}
      {
        \msg_expandable_error:nn { hooks } { empty-label }
        \@@_currname_or_default:
      }
      {
        \str_if_eq:nnTF {#1} { . }
          { \@@_currname_or_default: }
          { \@@_parse_dot_label:w #1 ./ \s_@@_mark }
      }
  }
\cs_new:Npn \@@_parse_dot_label:w #1 ./ #2 \s_@@_mark
  {
    \tl_if_empty:nTF {#1}
      { \@@_parse_dot_label_aux:w #2 \s_@@_mark }
      {
        \tl_if_empty:nTF {#2}
          { \@@_make_name:n {#1} }
          { \@@_parse_dot_label_cleanup:w #1 ./ #2 \s_@@_mark }
      }
  }
\cs_new:Npn \@@_parse_dot_label_cleanup:w #1 ./ \s_@@_mark {#1}
\cs_new:Npn \@@_parse_dot_label_aux:w #1 ./ \s_@@_mark
  { \@@_currname_or_default: / \@@_make_name:n {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_currname_or_default:}
%   This uses \cs{g_@@_hook_curr_name_tl} if it is set, otherwise it tries
%   \cs{@currname}.  If neither is set, it raises an error and uses the
%   fallback value \verb|label-missing|.
%    \begin{macrocode}
\cs_new:Npn \@@_currname_or_default:
  {
    \tl_if_empty:NTF \g_@@_hook_curr_name_tl
      {
        \tl_if_empty:NTF \@currname
          {
            \msg_expandable_error:nnn { latex2e } { should-not-happen }
              { Empty~default~label. }
            \@@_make_name:n { label-missing }
          }
          { \@currname }
      }
      { \g_@@_hook_curr_name_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_make_name:n,\@@_make_name:w}
%   This provides a standard sanitization of a hook's name.
%   It uses \cs{cs:w} to build a control sequence out of the hook name,
%   then uses \cs{cs_to_str:N} to get the string representation of that,
%   without the escape character.  \cs{cs:w}-based expansion is used
%   instead of |e|-based because Unicode characters don't behave well
%   inside \cs{expanded}.  The macro adds the \cs[no-index]{@@\textvisiblespace} prefix to the
%   hook name to reuse the hook's code token list to build the csname
%   and avoid leaving \enquote{public} control sequences defined
%   (as~\cs[no-index]{relax}) in TeX's memory.
%    \begin{macrocode}
\cs_new:Npn \@@_make_name:n #1
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \@@_make_name:w
    \exp_after:wN \token_to_str:N \cs:w @@~ #1 \cs_end:
  }
\exp_last_unbraced:NNNNo
\cs_new:Npn \@@_make_name:w #1 \tl_to_str:n { @@~ } { }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalize_hook_args:Nn}
% \begin{macro}{\@@_normalize_hook_args:Nnn}
% \begin{macro}{\@@_normalize_hook_rule_args:Nnnnn}
% \begin{macro}{\@@_normalize_hook_args_aux:Nn}
%   This is the standard route for normalizing hook and label arguments.  The main
%   macro does the entire operation within a group so that csnames made
%   by \cs{@@_make_name:n} are wiped off before continuing.  This means
%   that this function cannot be used for \cs{hook_use:n}!
%    \begin{macrocode}
\cs_new_protected:Npn \@@_normalize_hook_args_aux:Nn #1 #2
  {
    \group_begin:
    \use:e
      {
        \group_end:
        \exp_not:N #1 #2
      }
  }
\cs_new_protected:Npn \@@_normalize_hook_args:Nn #1 #2
  {
    \@@_normalize_hook_args_aux:Nn #1
      { { \@@_parse_label_default:n {#2} } }
  }
\cs_new_protected:Npn \@@_normalize_hook_args:Nnn #1 #2 #3
  {
    \@@_normalize_hook_args_aux:Nn #1
      {
        { \@@_parse_label_default:n {#2} }
        { \@@_parse_label_default:n {#3} }
      }
  }
\cs_new_protected:Npn \@@_normalize_hook_rule_args:Nnnnn #1 #2 #3 #4 #5
  {
    \@@_normalize_hook_args_aux:Nn #1
      {
        { \@@_parse_label_default:n {#2} }
        { \@@_parse_label_default:n {#3} }
        { \tl_trim_spaces:n {#4} }
        { \@@_parse_label_default:n {#5} }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hook_current_name_push:n,\@@_curr_name_push_aux:n}
% \begin{macro}{\hook_current_name_pop:}
% \begin{macro}{\@@_end_document_label_check:}
%   The token list \cs{g_@@_hook_curr_name_tl} stores the name of the
%   current package/file to be used as the default label in hooks.
%   Providing a consistent interface is tricky because packages can
%   be loaded within packages, and some packages may not use
%   \cs{SetHookCurrentName} to change the default label (in which
%   case \cs{@currname} is used).
%
%   To pull that one off, we keep a stack that contains the default
%   label for each level of input.  The bottom of the stack contains the
%   default label for the |top-level| (this stack should never go
%   empty). If we're building the format, set the default label to be
%   |top-level|:
%    \begin{macrocode}
\tl_gset:Nn \g_@@_hook_curr_name_tl { top-level }
%    \end{macrocode}
%
%   Then, in case we're in \pkg{latexrelease} we push something on
%   the stack to support roll forward.  But in some rare cases,
%   \pkg{latexrelease} may be loaded inside another package (notably
%   \pkg{platexrelease}), so we'll first push the |top-level| entry:
%   \changes{v1.0i}{2021/03/18}
%           {Only add \texttt{top-level} if not already there.}
%    \begin{macrocode}
%<latexrelease>\seq_if_empty:NT \g_@@_name_stack_seq
%<latexrelease>  { \seq_gput_right:Nn \g_@@_name_stack_seq { top-level } }
%    \end{macrocode}
%   then we dissect the \cs{@currnamestack}, adding \cs{@currname} to
%   the stack:
% \changes{v1.0f}{2020/11/24}{Support for roll forward (gh/434)}
%    \begin{macrocode}
%<latexrelease>\cs_set_protected:Npn \@@_tmp:w #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \quark_if_recursion_tail_stop:n {#1}
%<latexrelease>    \seq_gput_right:Nn \g_@@_name_stack_seq {#1}
%<latexrelease>    \@@_tmp:w
%<latexrelease>  }
%<latexrelease>\exp_after:wN \@@_tmp:w \@currnamestack
%<latexrelease>  \q_recursion_tail \q_recursion_tail
%<latexrelease>  \q_recursion_tail \q_recursion_stop
%    \end{macrocode}
%   and finally set the default label to be the \cs{@currname}:
%   \changes{v1.0i}{2021/03/18}
%           {Remove the (empty) \enquote{top-level} from \cs{@currnamestack}.}
%    \begin{macrocode}
%<latexrelease>\tl_gset:Nx \g_@@_hook_curr_name_tl { \@currname }
%<latexrelease>\seq_gpop_right:NN \g_@@_name_stack_seq \l_@@_tmpa_tl
%    \end{macrocode}
%
%   Two commands keep track of the stack: when a file is input,
%   \cs{hook_current_name_push:n} pushes the current default label onto the
%   stack and sets the new default label (all in one go):
%    \begin{macrocode}
\cs_new_protected:Npn \hook_current_name_push:n #1
  { \exp_args:Nx \@@_curr_name_push_aux:n { \@@_make_name:n {#1} } }
\cs_new_protected:Npn \@@_curr_name_push_aux:n #1
  {
    \tl_if_blank:nTF {#1}
      { \msg_error:nn { hooks } { no-default-label } }
      {
        \str_if_eq:nnTF {#1} { top-level }
          {
            \msg_error:nnnnn { hooks } { set-top-level }
              { to } { PushDefaultHookLabel } {#1}
          }
          {
            \seq_gpush:NV \g_@@_name_stack_seq \g_@@_hook_curr_name_tl
            \tl_gset:Nn \g_@@_hook_curr_name_tl {#1}
          }
      }
  }
%    \end{macrocode}
%   and when an input is over, the topmost item of the stack is popped,
%   since that label will not be used again, and \cs{g_@@_hook_curr_name_tl}
%   is updated to equal the now topmost item of the stack:
%    \begin{macrocode}
\cs_new_protected:Npn \hook_current_name_pop:
  {
    \seq_gpop:NNTF \g_@@_name_stack_seq \l_@@_return_tl
      { \tl_gset_eq:NN \g_@@_hook_curr_name_tl \l_@@_return_tl }
      { \msg_error:nn { hooks } { extra-pop-label } }
  }
%    \end{macrocode}
%
%   At the end of the document we want to check if there was no
%   \cs{hook_current_name_push:n} without a matching \cs{hook_current_name_pop:}
%   (not a critical error, but it might indicate that something else is
%   not quite right):
%    \begin{macrocode}
\tl_gput_right:Nn \@kernel@after@enddocument@afterlastpage
  { \@@_end_document_label_check: }
\cs_new_protected:Npn \@@_end_document_label_check:
  {
    \seq_gpop:NNT \g_@@_name_stack_seq \l_@@_return_tl
      {
        \msg_error:nnx { hooks } { missing-pop-label }
          { \g_@@_hook_curr_name_tl }
        \tl_gset_eq:NN \g_@@_hook_curr_name_tl \l_@@_return_tl
        \@@_end_document_label_check:
      }
  }
%    \end{macrocode}
%
%   The token list \cs{g_@@_hook_curr_name_tl} is but a mirror of the
%   top of the stack.
%
% \begin{macro}{\hook_current_name_set:n,\@@_gset_curr_name:n}
%   Now define a wrapper that replaces the top of the stack with the
%   argument, and updates \cs{g_@@_hook_curr_name_tl} accordingly.
%    \begin{macrocode}
\cs_new_protected:Npn \hook_current_name_set:n #1
  {
    \seq_if_empty:NTF \g_@@_name_stack_seq
      {
        \msg_error:nnnnn { hooks } { set-top-level }
          { for } { SetHookCurrentName } {#1}
      }
      {
        \exp_args:Nx \@@_gset_curr_name:n { \@@_make_name:n {#1} }
      }
  }
\cs_new_protected:Npn \@@_gset_curr_name:n #1
  {
    \str_if_eq:nnTF {#1} { top-level }
      {
        \msg_error:nnnnn { hooks } { set-top-level }
          { to } { SetHookCurrentName } {#1}
      }
      { \tl_gset:Nn \g_@@_hook_curr_name_tl {#1} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Adding or removing hook code}
%
% \begin{macro}{
%   \hook_gput_code:nnn,
%   \hook_gput_code_with_args:nnn,
% }
% \begin{macro}{
%   \@@_gput_code:nnn,
%   \@@_gput_code_store:nnn,
%   \@@_hook_gput_code_do:nnn,
%   \@@_prop_gput_labeled_cleanup:nnn,
%   \@@_prop_gput_labeled_do:Nnnn
% }
%    With \cs{hook_gput_code:nnn}\Arg{hook-spec}\Arg{label-spec}\Arg{code} a
%    chunk of \meta{code} is added to an existing hook labeled
%    after \meta{label-spec}.
% \changes{v1.0o}{2021/07/22}{Do not queue removals (gh/625)}
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_gput_code_with_args:nnn} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gput_code:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gput_code:nnn #1 #2 #3
  {
    \@@_replacing_args_false:
    \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} {#3}
    \@@_replacing_args_reset:
  }
\cs_new_protected:Npn \hook_gput_code_with_args:nnn #1 #2 #3
  {
    \@@_replacing_args_true:
    \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} {#3}
    \@@_replacing_args_reset:
  }
%    \end{macrocode}
%
%   If \cs{AddToHookWithArguments} was used, do some sanity checking,
%   and if it's not possible to use arguments at this point, fall back
%   to regular \cs{AddToHook} by using \cs{@@_replacing_args_false:}.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_code:nnn #1 #2 #3
  {
    \@@_chk_args_allowed:nn {#1} { AddToHook }
%    \end{macrocode}
%   Then check if the code should be executed immediately, rather than
%   stored:
% \changes{v1.0r}{2021/09/06}{Use dedicated conditional (gh/606)}
%    \begin{macrocode}
    \@@_if_execute_immediately:nTF {#1}
      {
%    \end{macrocode}
%   \cs{AddToHookWithArguments} can't be used on one-time hooks (that
%   were already used).
%    \begin{macrocode}
        \@@_if_replacing_args:TF
          {
            \msg_error:nnnn { hooks } { one-time-args }
              {#1} { AddToHook }
          }
          { }
        \use:n
      }
      { \@@_gput_code_store:nnn {#1} {#2} }
          {#3}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_code_store:nnn #1 #2 #3
  {
%    \end{macrocode}
%    Then check if the hook is usable.
%    \begin{macrocode}
    \@@_if_usable:nTF {#1}
%    \end{macrocode}
%    If so we simply add (or append) the new code to the property list
%    holding different chunks for the hook. At \verb=\begin{document}=
%    this is then sorted into a token list for fast execution.
%    \begin{macrocode}
      {
        \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
%    \end{macrocode}
%    However, if there is an update within the document we need to alter
%    this execution code which is done by
%    \cs{@@_update_hook_code:n}. In the preamble this does nothing.
%    \begin{macrocode}
        \@@_update_hook_code:n {#1}
      }
%    \end{macrocode}
%
%    If the hook is not usable, before giving up, check if it's not
%    disabled and otherwise try to declare it as a generic hook, if its
%    name matches one of the valid patterns.
%    \begin{macrocode}
      {
        \@@_if_disabled:nTF {#1}
          { \msg_error:nnn { hooks } { hook-disabled } {#1} }
          { \@@_try_declaring_generic_hook:nnn {#1} {#2} {#3} }
      }
  }
%    \end{macrocode}
%
%    This macro will unconditionally add a chunk of code to the given hook.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_hook_gput_code_do:nnn #1 #2 #3
  {
%    \end{macrocode}
%    However, first some debugging info if debugging is enabled:
%    \begin{macrocode}
    \@@_debug:n{\iow_term:x{****~ Add~ to~
                      \@@_if_usable:nF {#1} { undeclared~ }
                      hook~ #1~ (#2)
                      \on@line\space <-~ \tl_to_str:n{#3}} }
%    \end{macrocode}
%    Then try to get the code chunk labeled \verb=#2= from the hook.
%    If there's code already there, then append \verb=#3= to that,
%    otherwise just put \verb=#3=.  If the current label is |top-level|,
%    the code is added to a dedicated token list
%    \cs{@@_toplevel\textvisiblespace\meta{hook}} that goes at the end of the
%    hook (or at the beginning, for a reversed hook), just before
%   \cs[no-index]{@@_next\textvisiblespace\meta{hook}}.
%    \begin{macrocode}
    \str_if_eq:nnTF {#2} { top-level }
      {
        \str_if_eq:eeTF { top-level } { \@@_currname_or_default: }
          {
%    \end{macrocode}
%   If the hook's basic structure does not exist, we need to declare it
%   with \cs{@@_init_structure:n}.
%    \begin{macrocode}
            \@@_init_structure:n {#1}
%    \end{macrocode}
%   Then append to the \verb|_toplevel| container for the hook.
%    \begin{macrocode}
            \@@_cs_gput_right:nnn { _toplevel } {#1} {#3}
          }
          { \msg_error:nnn { hooks } { misused-top-level } {#1} }
      }
      {
%    \end{macrocode}
%   When adding to the code pool, we have to double hashes if
%   \cs{AddToHook} was used (\verb|replacing_args| is false), so that
%   later it is turned into a single parameter token, rather than a
%   parameter to the hook macro.
%    \begin{macrocode}
        \exp_args:Nx \@@_prop_gput_labeled_cleanup:nnn
          {
            \@@_if_replacing_args:TF
              { \exp_not:n }
              { \@@_double_hashes:n }
                {#3}
          }
          {#1} {#2}
      }
  }
%    \end{macrocode}
%
%   Adds code to a hook's code pool.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_gput_labeled_cleanup:nnn #1 #2 #3
  {
    \tl_set:Nn \l_@@_return_tl {#1}
    \@@_if_replacing_args:TF
      {
        \@@_if_usable:nT {#2}
          {
            \@@_set_normalise_fn:nn {#2}
              { Invalid~code~added~\msg_line_context: }
            \@@_normalise_fn:nn {#3} {#1}
            \prop_get:NnN \l_@@_work_prop {#3} \l_@@_return_tl
          }
      }
      { }
    \exp_args:NcV \@@_prop_gput_labeled_do:Nnn
      { g_@@_#2_code_prop } \l_@@_return_tl {#3}
  }
\cs_new_protected:Npn \@@_prop_gput_labeled_do:Nnn #1 #2 #3
  {
    \prop_get:NnNTF #1 {#3} \l_@@_return_tl
      { \prop_gput:Nno #1 {#3} { \l_@@_return_tl #2 } }
      { \prop_gput:Nnn #1 {#3} {#2} }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gput_code:nnn}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \hook_gput_code:nnn #1 #2
%<latexrelease>  { \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} }
%<latexrelease>\cs_gset_protected:Npn \@@_gput_code:nnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_if_execute_immediately:nTF {#1}
%<latexrelease>      {#3}
%<latexrelease>      {
%<latexrelease>        \@@_if_usable:nTF {#1}
%<latexrelease>          {
%<latexrelease>            \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
%<latexrelease>            \@@_update_hook_code:n {#1}
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_if_disabled:nTF {#1}
%<latexrelease>              { \msg_error:nnn { hooks } { hook-disabled } {#1} }
%<latexrelease>              { \@@_try_declaring_generic_hook:nnn {#1} {#2} {#3} }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_hook_gput_code_do:nnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_debug:n{\iow_term:x{****~ Add~ to~
%<latexrelease>                      \@@_if_usable:nF {#1} { undeclared~ }
%<latexrelease>                      hook~ #1~ (#2)
%<latexrelease>                      \on@line\space <-~ \tl_to_str:n{#3}} }
%<latexrelease>    \str_if_eq:nnTF {#2} { top-level }
%<latexrelease>      {
%<latexrelease>        \str_if_eq:eeTF { top-level } { \@@_currname_or_default: }
%<latexrelease>          {
%<latexrelease>            \@@_init_structure:n {#1}
%<latexrelease>            \@@_tl_gput_right:cn { @@_toplevel~#1 } {#3}
%<latexrelease>          }
%<latexrelease>          { \msg_error:nnn { hooks } { misused-top-level } {#1} }
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \prop_get:cnNTF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
%<latexrelease>          {
%<latexrelease>            \prop_gput:cno { g_@@_#1_code_prop } {#2}
%<latexrelease>              { \l_@@_return_tl #3 }
%<latexrelease>          }
%<latexrelease>          { \prop_gput:cnn { g_@@_#1_code_prop } {#2} {#3} }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_gput_code_with_args:nnn #1#2#3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_chk_args_allowed:nn}
%   This macro checks if it is possible to add code with references to
%   a hook's arguments for hook \verb|#1|.  It only does something if
%   the function being run is \verb|replacing_args|.  This macro will
%   error if the hook is declared and takes no arguments, then it will
%   set \cs{@@_replacing_args_false:} so that the macro which called it
%   will add the code normally.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_chk_args_allowed:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_chk_args_allowed:nn #1 #2
  {
    \@@_if_replacing_args:TF
      {
        \@@_if_declared:nT {#1}
          { \tl_if_empty:cT { c_@@_#1_parameter_tl } { \use_ii:nn } }
        \use_none:n
          {
            \msg_error:nnnn { hooks } { without-args } {#1} {#2}
            \@@_replacing_args_false:
          }
      }
      { }
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_chk_args_allowed:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_chk_args_allowed:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_gput_undeclared_hook:nnn}
%   Often it may happen that a package $A$ defines a hook \verb=foo=,
%   but package $B$, that adds code to that hook, is loaded before $A$.
%   In such case we need to add code to the hook before its declared.
%   An implicitly declared hook doesn't have arguments (in principle),
%   so use \cs{c_false_bool} here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_undeclared_hook:nnn #1 #2 #3
  {
    \@@_init_structure:n {#1}
    \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_try_declaring_generic_hook:nnn,
%               \@@_try_declaring_generic_next_hook:nn}
%
%   These entry-level macros just pass the arguments along to the
%   common \cs{@@_try_declaring_generic_hook:nNNnn} with the right
%   functions to execute when some action is to be taken.
%
%   The wrapper \cs{@@_try_declaring_generic_hook:nnn} then defers
%   \cs{hook_gput_code:nnn} if the generic hook was declared, or to
%   \cs{@@_gput_undeclared_hook:nnn} otherwise (the hook was tested for
%   existence before, so at this point if it isn't generic, it doesn't
%   exist).
%
%   The wrapper \cs{@@_try_declaring_generic_next_hook:nn} for
%   next-execution hooks does the same: it defers the code to
%   \cs{hook_gput_next_code:nn} if the generic hook was declared, or
%   to \cs{@@_gput_next_do:nn} otherwise.
% \changes{v1.0p}{2021/08/25}{Standardise generic hook names (gh/648)}
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_try_declaring_generic_hook:nnn #1
  {
    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
      \@@_gput_code:nnn
      \@@_gput_undeclared_hook:nnn
        {#1}
  }
\cs_new_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
  {
    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
      \@@_gput_next_code:nn
      \@@_gput_next_do:nn
        {#1}
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_gset_protected:Npn \@@_try_declaring_generic_hook:nnn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      \hook_gput_code:nnn
%<latexrelease>      \@@_gput_undeclared_hook:nnn
%<latexrelease>        {#1}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      \hook_gput_next_code:nn
%<latexrelease>      \@@_gput_next_do:nn
%<latexrelease>        {#1}
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook:nnn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:nNNnn {#1}
%<latexrelease>      \hook_gput_code:nnn \@@_gput_undeclared_hook:nnn
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:nNNnn {#1}
%<latexrelease>      \hook_gput_next_code:nn \@@_gput_next_do:nn
%<latexrelease>  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_try_declaring_generic_hook:nNNnn,
%               \@@_try_declaring_generic_hook_split:nNNnn}
%
%   \cs{@@_try_declaring_generic_hook:nNNnn}
%   now splits the hook name
%   at the first \texttt{/} (if any) and first checks if it is a
%   file-specific hook (they require some normalization) using
%   \cs{@@_if_file_hook:wTF}. If not then check it is one of a
%   predefined set for generic names. We also split off the second
%   component to see if we have to make a reversed hook.  In either case
%   the function returns \meta{true} for a generic hook and \meta{false}
%   in other cases.
%
% \changes{v1.0s}{2021/09/28}
%                {Correct usage of older \cs{@@_if_file_hook:wTF} (gh/675)}
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook:nNNnn #1
%<latexrelease>  {
%<latexrelease>    \@@_if_file_hook:wTF #1 / \s_@@_mark
%<latexrelease>      {
%<latexrelease>        \exp_args:Ne \@@_try_declaring_generic_hook_split:nNNnn
%<latexrelease>          { \exp_args:Ne \@@_file_hook_normalize:n {#1} }
%<latexrelease>      }
%<latexrelease>      { \@@_try_declaring_generic_hook_split:nNNnn {#1} }
%<latexrelease>  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook_split:nNNnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      { #2 }
%<latexrelease>      { #3 } {#1}
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\@@_try_declaring_generic_hook:wn}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Hooks~with~args}
\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
  {
    \@@_if_generic:nTF {#5}
      {
        \@@_if_usable:nF {#5}
          {
%    \end{macrocode}
%    If the hook doesn't exist yet we check if it is a \texttt{cmd}
%    hook and if so we attempt patching the command in addition to
%    declaring the hook.
%
%    For some commands this will not be possible, in which case
%    \cs{@@_patch_cmd_or_delay:Nnn} (defined in \texttt{ltcmdhooks})
%    will generate an appropriate error message.
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
            \str_if_eq:nnT {#1} { cmd }
              {
                \@@_try_put_cmd_hook:n {#5}
                \@@_make_usable:nn {#5} { 9 }
                \use_none:nnn
              }
%    \end{macrocode}
%
%    Declare the hook always even if it can't really be used (error
%    message generated elsewhere).
%
%    Here we use \cs{@@_make_usable:nn}, so that a \cs{hook_new:n} is
%    still possible later.  Generic hooks (except \hook{cmd} hooks) take
%    no arguments, so use zero as the second argument.
%    \begin{macrocode}
            \@@_make_usable:nn {#5} { 0 }
          }
        \@@_if_generic_reversed:nT {#5}
          { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
        \prg_return_true:
      }
      {
%    \end{macrocode}
%
%    Generic hooks are all named \meta{type}/\meta{name}/\meta{place},
%    where \meta{type} and \meta{place} are predefined
%    (\cs{c_@@_generic_\meta{type}/./\meta{place}_tl}), and \meta{name}
%    is the variable component.  Older releases had some hooks with the
%    \meta{name} in the third part, so the code below supports that
%    syntax for a while, with a warning.
%
%    The \cs{exp_after:wN} |...| \cs{exp:w} trick is there to remove the
%    conditional structure inserted by
%    \cs{@@_try_declaring_generic_hook:wnTF} and thus allow access to the
%    tokens that follow it, as is needed to keep things going.
%
%    When the deprecation cycle ends, the lines below should all be
%    replaced by \cs{prg_return_false:}.
%    \begin{macrocode}
        \@@_if_deprecated_generic:nTF {#5}
          {
            \@@_deprecated_generic_warn:n {#5}
            \exp_after:wN \@@_declare_deprecated_generic:NNn
            \exp:w % \exp_end:
          }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
%
% \begin{macro}{
%     \@@_deprecated_generic_warn:Nn,
%     \@@_deprecated_generic_warn:Nw,
%   }
%   \cs{@@_deprecated_generic_warn:n} will issue a deprecation warning
%   for a given hook, and mark that hook such that the warning will not
%   be issued again (multiple warnings can be issued, but only once per
%   hook).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_deprecated_generic_warn:n #1
  { \@@_deprecated_generic_warn:w #1 \s_@@_mark }
\cs_new_protected:Npn \@@_deprecated_generic_warn:w
    #1 / #2 / #3 \s_@@_mark
  {
    \if_cs_exist:w @@~#1/#2/#3 \cs_end: \else:
      \msg_warning:nnnnn { hooks } { generic-deprecated } {#1} {#2} {#3}
    \fi:
    \cs_gset_eq:cN { @@~#1/#2/#3 } \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_do_deprecated_generic:Nn,
%     \@@_do_deprecated_generic:Nw,
%     \@@_declare_deprecated_generic:NNw,
%     \@@_declare_deprecated_generic:NNw,
%   }
%   Now that the user has been told about the deprecation, we proceed by
%   swapping \meta{name} and \meta{place} and adding the code to the
%   correct hook.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_do_deprecated_generic:Nn #1 #2
  { \@@_do_deprecated_generic:Nw #1 #2 \s_@@_mark }
\cs_new_protected:Npn \@@_do_deprecated_generic:Nw #1
         #2 / #3 / #4 \s_@@_mark
  { #1 { #2 / #4 / #3 } }
\cs_new_protected:Npn \@@_declare_deprecated_generic:NNn #1 #2 #3
  { \@@_declare_deprecated_generic:NNw #1 #2 #3 \s_@@_mark }
\cs_new_protected:Npn \@@_declare_deprecated_generic:NNw #1 #2
    #3 / #4 / #5 \s_@@_mark
  {
    \@@_try_declaring_generic_hook:wnTF #3 / #5 / #4 / \scan_stop:
        { #3 / #5 / #4 }
      #1 #2 { #3 / #5 / #4 }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \@@_if_generic:nTF {#5}
%<latexrelease>      {
%<latexrelease>        \@@_if_usable:nF {#5}
%<latexrelease>          {
%<latexrelease>            \str_if_eq:nnT {#1} { cmd }
%<latexrelease>              { \@@_try_put_cmd_hook:n {#5} }
%<latexrelease>            \@@_make_usable:n {#5}
%<latexrelease>          }
%<latexrelease>        \@@_if_generic_reversed:nT {#5}
%<latexrelease>          { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>        \prg_return_true:
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \@@_if_deprecated_generic:nTF {#5}
%<latexrelease>          {
%<latexrelease>            \@@_deprecated_generic_warn:n {#5}
%<latexrelease>            \exp_after:wN \@@_declare_deprecated_generic:NNn
%<latexrelease>            \exp:w % \exp_end:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Support~cmd~hooks}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#2}
%<latexrelease>      { \prg_return_false: }
%<latexrelease>      {
%<latexrelease>        \prop_if_in:NnTF \c_@@_generics_prop {#1}
%<latexrelease>          {
%<latexrelease>            \@@_if_usable:nF {#5}
%<latexrelease>              {
%<latexrelease>                \str_if_eq:nnT {#1} { cmd }
%<latexrelease>                  { \@@_try_put_cmd_hook:n {#5} }
%<latexrelease>                \@@_make_usable:n {#5}
%<latexrelease>              }
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_reversed_ii_prop {#2}
%<latexrelease>              { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              {
%<latexrelease>                \prop_if_in:NnT \c_@@_generics_reversed_iii_prop {#3}
%<latexrelease>                  { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              }
%<latexrelease>            \prg_return_true:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Support~cmd~hooks}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#2}
%<latexrelease>      { \prg_return_false: }
%<latexrelease>      {
%<latexrelease>        \prop_if_in:NnTF \c_@@_generics_prop {#1}
%<latexrelease>          {
%<latexrelease>            \@@_if_declared:nF {#5} { \hook_new:n {#5} }
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_reversed_ii_prop {#2}
%<latexrelease>              { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              {
%<latexrelease>                \prop_if_in:NnT \c_@@_generics_reversed_iii_prop {#3}
%<latexrelease>                  { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              }
%<latexrelease>            \prg_return_true:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\@@_if_file_hook:w}
%   \cs{@@_if_file_hook:wTF} checks if the argument is a valid
%   file-specific hook (not, for example, |file/before|, but
%   |file/foo.tex/before|).  If it is a file-specific hook, then it
%   executes the \meta{true} branch, otherwise \meta{false}.
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_if_file_hook:w}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_if_file_hook:w}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prg_new_conditional:Npnn \@@_if_file_hook:w
%<latexrelease>    #1 / #2 / #3 \s_@@_mark { TF }
%<latexrelease>  {
%<latexrelease>    \str_if_eq:nnTF {#1} { file }
%<latexrelease>      {
%<latexrelease>        \bool_lazy_or:nnTF
%<latexrelease>            { \tl_if_empty_p:n {#3} }
%<latexrelease>            { \str_if_eq_p:nn {#3} { / } }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>          {
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_file_prop {#2}
%<latexrelease>              { \prg_return_true: }
%<latexrelease>              { \prg_return_false: }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>      { \prg_return_false: }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_file_hook_normalize:n}
% \begin{macro}[EXP]{\@@_strip_double_slash:n,\@@_strip_double_slash:w}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_file_hook_normalize:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%   When a file-specific hook is found, before being declared it is
%   lightly normalized by \cs{@@_file_hook_normalize:n}.  The current
%   implementation just replaces two consecutive slashes (|//|) by a
%   single one, to cope with simple cases where the user did something
%   like \verb|\def\input@path{{./mypath/}}|, in which case a hook would
%   have to be \verb|\AddToHook{file/./mypath//file.tex/after}|.
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_file_hook_normalize:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new:Npn \@@_file_hook_normalize:n #1
%<latexrelease>  { \@@_strip_double_slash:n {#1} }
%<latexrelease>\cs_new:Npn \@@_strip_double_slash:n #1
%<latexrelease>  { \@@_strip_double_slash:w #1 // \s_@@_mark }
%    \end{macrocode}
%   This function is always called after testing if the argument is a
%   file hook with \cs{@@_if_file_hook:wTF}, so we can assume it has
%   three parts (it is either \verb|file/.../before| or
%   \verb|file/.../after|), so we use \verb|#1/#2/#3 //| instead of just
%   \verb|#1 //| to prevent losing a slash if the file name is empty.
%   \changes{v1.0h}{2021/01/07}{Assume hook name has at least three
%     nonempty parts (gh/464)}
%    \begin{macrocode}
%<latexrelease>\cs_new:Npn \@@_strip_double_slash:w #1/#2/#3 // #4 \s_@@_mark
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#4}
%<latexrelease>      { #1/#2/#3 }
%<latexrelease>      { \@@_strip_double_slash:w #1/#2/#3 / #4 \s_@@_mark }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{
%    \c_@@_generic_cmd/./before_tl,\c_@@_generic_cmd/./after_tl,
%    \c_@@_generic_env/./before_tl,\c_@@_generic_env/./after_tl,
%    \c_@@_generic_file/./before_tl,\c_@@_generic_file/./after_tl,
%    \c_@@_generic_package/./before_tl,\c_@@_generic_package/./after_tl,
%    \c_@@_generic_class/./before_tl,\c_@@_generic_class/./after_tl,
%    \c_@@_generic_include/./before_tl,\c_@@_generic_include/./after_tl,
%    \c_@@_generic_env/./begin_tl,\c_@@_generic_env/./end_tl,
%    \c_@@_generic_include/./end_tl
%  }
%    Token lists defining the possible generic hooks.  We don't provide
%    any user interface to this as this is meant to be static.
%    \begin{description}
%    \item[\texttt{cmd}]
%      The generic hooks used for commands.
%    \item[\texttt{env}]
%      The generic hooks used in \cs{begin} and \cs{end}.
%    \item[\texttt{file}, \texttt{package}, \texttt{class}, \texttt{include}]
%      The generic hooks used when loading a file
%    \end{description}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\c_@@_generics_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
\clist_map_inline:nn { cmd , env , file , package , class , include }
  {
    \tl_const:cn { c_@@_generic_#1/./before_tl } { + }
    \tl_const:cn { c_@@_generic_#1/./after_tl  } { - }
  }
\tl_const:cn { c_@@_generic_env/./begin_tl } { + }
\tl_const:cn { c_@@_generic_env/./end_tl   } { + }
%    \end{macrocode}
%
% \changes{v1.0t}{2022/04/01}{Support generic \texttt{include/.../excluded} hooks}
%    \begin{macrocode}
\tl_const:cn { c_@@_generic_include/./end_tl } { - }
\tl_const:cn { c_@@_generic_include/./excluded_tl } { + }
%    \end{macrocode}
%
%   Deprecated generic hooks:
%    \begin{macrocode}
\clist_map_inline:nn { file , package , class , include }
  {
    \tl_const:cn { c_@@_deprecated_#1/./before_tl } { }
    \tl_const:cn { c_@@_deprecated_#1/./after_tl  } { }
  }
\tl_const:cn { c_@@_deprecated_include/./end_tl } { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_generics_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_prop
%<latexrelease>     {cmd=,env=,file=,package=,class=,include=}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\c_@@_generics_reversed_ii_prop,
%                \c_@@_generics_reversed_iii_prop,
%                \c_@@_generics_file_prop}
%    The following generic hooks are supposed to use reverse ordering
%    (the |ii| and |iii| names are kept for the deprecation cycle):
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\c_@@_generics_reversed_ii_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_generics_reversed_ii_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_reversed_ii_prop {after=,end=}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_reversed_iii_prop {after=}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_file_prop {before=,after=}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{
%     \c_@@_parameter_cmd/./before_tl,\c_@@_parameter_cmd/./after_tl,
%   }
%   Token lists defining the number of arguments for a given type of
%   generic hook.
% \changes{v1.1d}{2023/05/21}
%         {Token lists added (cmd-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\c_@@_parameter_cmd/./before_tl}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
%   \hook{cmd} hooks are declared with 9 arguments because they have a
%   variable number of arguments (depending on the command they are
%   attached to), so we use the maximum here.
%    \begin{macrocode}
\tl_const:cn { c_@@_parameter_cmd/./before_tl } { #1#2#3#4#5#6#7#8#9 }
\tl_const:cn { c_@@_parameter_cmd/./after_tl }  { #1#2#3#4#5#6#7#8#9 }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_parameter_cmd/./before_tl}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\hook_gremove_code:nn}
% \begin{macro}{\@@_gremove_code:nn}
%
%    With \cs{hook_gremove_code:nn}\Arg{hook-spec}\Arg{label-spec} any code
%    for the \meta{hook-name} built after \meta{hook-spec}
%    stored under the \meta{label-name} built after \meta{label-spec} is removed.
% \changes{v1.0o}{2021/07/22}{Do not queue removals (gh/625)}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gremove_code:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gremove_code:nn #1 #2
  { \@@_normalize_hook_args:Nnn \@@_gremove_code:nn {#1} {#2} }
\cs_new_protected:Npn \@@_gremove_code:nn #1 #2
  {
%    \end{macrocode}
%    First check that the hook code pool exists.  \cs{@@_if_usable:nTF}
%    isn't used here because it should be possible to remove code from a
%    hook before its defined (see section~\ref{sec:querying}).
%    \begin{macrocode}
    \@@_if_structure_exist:nTF {#1}
      {
%    \end{macrocode}
%    Then remove the chunk and run \cs{@@_update_hook_code:n} so
%    that the execution token list reflects the change if we are after
%    \verb=\begin{document}=.
%
%    If all code is to be removed, clear the code pool
%    \cs{g_@@_\meta{hook}_code_prop}, the top-level code
%    \cs{@@_toplevel\textvisiblespace\meta{hook}}, and the next-execution code
%    \cs{@@_next\textvisiblespace\meta{hook}}.
%    \begin{macrocode}
        \str_if_eq:nnTF {#2} {*}
          {
            \prop_gclear:c { g_@@_#1_code_prop }
            \@@_toplevel_gset:nn {#1} { }
            \@@_next_gset:nn {#1} { }
          }
          {
%    \end{macrocode}
%    If the label is |top-level| then clear the token list, as all code
%    there is under the same label.
%    \begin{macrocode}
            \str_if_eq:nnTF {#2} { top-level }
              { \@@_toplevel_gset:nn {#1} { } }
              {
                \prop_gpop:cnNF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
                  { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
              }
          }
%    \end{macrocode}
%    Finally update the code, if the hook exists.
%    \begin{macrocode}
        \@@_if_usable:nT {#1}
          { \@@_update_hook_code:n {#1} }
      }
%    \end{macrocode}
%
%    If the code pool for this hook doesn't exist, show a warning:
%    \begin{macrocode}
      {
        \@@_if_deprecated_generic:nTF {#1}
          {
            \@@_deprecated_generic_warn:n {#1}
            \@@_do_deprecated_generic:Nn \@@_gremove_code:nn {#1} {#2}
          }
          { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gremove_code:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_gremove_code:nn #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nTF {#1}
%<latexrelease>      {
%<latexrelease>        \str_if_eq:nnTF {#2} {*}
%<latexrelease>          {
%<latexrelease>            \prop_gclear:c { g_@@_#1_code_prop }
%<latexrelease>            \@@_tl_gclear:c { @@_toplevel~#1 }
%<latexrelease>            \@@_tl_gclear:c { @@_next~#1 }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \str_if_eq:nnTF {#2} { top-level }
%<latexrelease>              { \@@_tl_gclear:c { @@_toplevel~#1 } }
%<latexrelease>              {
%<latexrelease>                \prop_gpop:cnNF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
%<latexrelease>                  { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>        \@@_if_usable:nT {#1}
%<latexrelease>          { \@@_update_hook_code:n {#1} }
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \@@_if_deprecated_generic:nTF {#1}
%<latexrelease>          {
%<latexrelease>            \@@_deprecated_generic_warn:n {#1}
%<latexrelease>            \@@_do_deprecated_generic:Nn \@@_gremove_code:nn {#1} {#2}
%<latexrelease>          }
%<latexrelease>          { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_cs_gput_right:nnn}
% \begin{macro}{\@@_cs_gput_right_fast:nnn,\@@_cs_gput_right_slow:nnn}
% \begin{macro}{\@@_code_gset_auxi:nnnn,\@@_code_gset_auxi:eeen}
%   This macro is used to append code to the \verb|toplevel| and
%   \verb|next| token lists, trating them correctly depending on their
%   number of arguments, and depending if the code being added should
%   have parameter tokens understood as parameters, or doubled to be
%   stored as parameter tokens.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
% \changes{v1.1e}{2023/06/06}
%         {Short-circuit when the hook is declared without args (gh1078).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_cs_gput_right:nnn}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
%   Check if the current hook is declared and takes no arguments.  In
%   this case, we short-circuit and use the simpler and much faster
%   approach that doesn't require hash-doubling.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cs_gput_right:nnn #1 #2
  {
    \if:w T
        \@@_if_declared:nF {#2} { F }
        \tl_if_empty:cF { c_@@_#2_parameter_tl } { F }
          T
      \exp_after:wN \@@_cs_gput_right_fast:nnn
    \else:
      \exp_after:wN \@@_cs_gput_right_slow:nnn
    \fi:
        {#1} {#2}
  }
\cs_new_protected:Npn \@@_cs_gput_right_fast:nnn #1 #2 #3
  { \cs_gset:cpx { @@#1~#2 } { \exp_not:v { @@#1~#2 } \exp_not:n {#3} } }
\cs_new_protected:Npn \@@_cs_gput_right_slow:nnn #1 #2 #3
  {
%    \end{macrocode}
%   The auxiliary \cs{@@_code_gset_auxi:eeen} just does the assignment
%   at the end.  Its first argument is the parameter text of the macro,
%   which is chosen here depending if
%   \cs[no-index]{c_@@_\meta{hook}_parameter_tl} exists, if the hook is
%   declared, and if it's a generic hook.
%    \begin{macrocode}
    \cs_if_exist:cF { @@#1~#2 }
      { \@@_code_gset_aux:nnn {#1} {#2} { } }
    \@@_code_gset_auxi:eeen
      {
        \@@_if_declared:nTF {#2}
          { \tl_use:c { c_@@_#2_parameter_tl } }
          {
            \@@_if_generic:nTF {#2}
              { \@@_generic_parameter:n {#2} }
              { \c_@@_nine_parameters_tl }
          }
      }
%    \end{macrocode}
%   Here we take the existing code in the macro, expand it with as many
%   arguments as it takes, then double the hashes so the code can be
%   reused. \pho{Maybe can be improved. The case of adding to an empty
%     cs can be optimised by quickly checking \cs{cs_replacement_spec}.}
%    \begin{macrocode}
      {
        \exp_args:NNo \exp_args:No \@@_double_hashes:n
          {
            \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
              { \@@_braced_cs_parameter:n { @@#1~#2 } }
          }
      }
%    \end{macrocode}
%   Now the new code:  if we are replacing arguments, then hashes are
%   left untouched, otherwise they are doubled.
%    \begin{macrocode}
      {
        \@@_if_replacing_args:TF
          { \exp_not:n }
          { \@@_double_hashes:n }
            {#3}
      }
%    \end{macrocode}
%   And finally, the csname which we'll define with all the above.
%    \begin{macrocode}
      { @@#1~#2 }
  }
%    \end{macrocode}
%
%   And as promised, the auxiliary that does the definition.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_code_gset_auxi:nnnn #1 #2 #3 #4
  { \cs_gset:cpn {#4} #1 { #2 #3 } }
\cs_generate_variant:Nn \@@_code_gset_auxi:nnnn { eeen }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_cs_gput_right:nnn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_cs_gput_right:nnn
%<latexrelease>\cs_undefine:N \@@_cs_gput_right_fast:nnn
%<latexrelease>\cs_undefine:N \@@_cs_gput_right_slow:nnn
%<latexrelease>\cs_undefine:N \@@_code_gset_auxi:nnnn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{
%     \@@_code_gset:nn,\@@_code_gset:ne,
%     \@@_toplevel_gset:nn,
%     \@@_next_gset:nn,
%     \@@_code_gset_aux:nnn
%   }
%   These macros define
%   \cs[no-index]{@@\meta{type}\textvisiblespace\meta{hook}} (with
%   \meta{type} being \verb|_next|, \verb|_toplevel|, or empty) with the
%   given code and the parameters stored in
%   \cs[no-index]{c_@@_\meta{hook}_parameter_tl} (or none, if that
%   doesn't exist).
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_code_gset:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_code_gset:nn
  { \@@_code_gset_aux:nnn { } }
\cs_new_protected:Npn \@@_toplevel_gset:nn
  { \@@_code_gset_aux:nnn { _toplevel } }
\cs_new_protected:Npn \@@_next_gset:nn
  { \@@_code_gset_aux:nnn { _next } }
\cs_new_protected:Npn \@@_code_gset_aux:nnn #1 #2 #3
  {
    \cs_gset:cpn { @@#1~#2 \exp_last_unbraced:Ne }
      { \@@_parameter:n {#2} }
      {#3}
  }
\cs_generate_variant:Nn \@@_code_gset:nn { ne }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_code_gset:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_code_gset:nn
%<latexrelease>\cs_undefine:N \@@_toplevel_gset:nn
%<latexrelease>\cs_undefine:N \@@_next_gset:nn
%<latexrelease>\cs_undefine:N \@@_code_gset_aux:nnn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalise_cs_args:nn}
%   This macro normalises the parameters of the macros
%   \cs[no-index]{@@\meta{type}\textvisiblespace\meta{hook}} to take the
%   right number of arguments after a hook is declared.  At this point
%   we know \cs[no-index]{c_@@_\meta{hook}_parameter_tl} exists, so use
%   that to count the arguments and use that as \meta{parameter text}
%   for the newly (re)defined macro.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_normalise_cs_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_normalise_cs_args:nn #1 #2
  {
    \cs_if_exist:cT { @@#1~#2 }
      {
        \@@_code_gset_auxi:eeen
          { \tl_use:c { c_@@_#2_parameter_tl } }
          {
            \exp_args:NNo \exp_args:No \@@_double_hashes:n
              {
                \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
                  { \@@_braced_cs_parameter:n { @@#1~#2 } }
              }
          }
          { }
          { @@#1~#2 }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_normalise_cs_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_normalise_cs_args:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalise_code_pool:n}
% \begin{macro}{\@@_set_normalise_fn:nn}
%   This one's a bit of a hack.  It takes a hook, and iterates over its
%   code pool (\cs[no-index]{g_@@_\meta{hook}_code_prop}), redefining
%   each code label to use only valid arguments.  This is used when, for
%   example, a code is added referencing arguments \verb|#1| and
%   \verb|#2|, but the hook has only \verb|#1|.  In this example, every
%   reference to \verb|#2| is changed to \verb|##2|.  This is done
%   because otherwise \TeX{} will throw a low-level error every time
%   some change happens to the hook (code is added, a rule is set, etc),
%   which can get quite repetitive for no good reason.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_normalise_code_pool:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_normalise_code_pool:n #1
  {
%    \end{macrocode}
%   First, call \cs{@@_set_normalise_fn:nn} with the hook name to set
%   everything up, then we'll loop over the
%   hook's code pool applying the normalisation above.  After that's
%   done, copy the temporary property list back to the hook's.
%    \begin{macrocode}
    \@@_set_normalise_fn:nn {#1} { Offending~label:~'##1' }
    \prop_clear:N \l_@@_work_prop
    \prop_map_function:cN { g_@@_#1_code_prop } \@@_normalise_fn:nn
    \prop_gset_eq:cN { g_@@_#1_code_prop } \l_@@_work_prop
  }
%    \end{macrocode}
%
%   The sole purpose of this function is to define
%   \cs{@@_normalise_fn:nn}, which will then do the correcting of the
%   code being added to the hook.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_normalise_fn:nn #1 #2
  {
%    \end{macrocode}
%   To start, we define two auxiliary token lists.
%   \cs[no-index]{l_@@_tmpb_tl} contains:
%\begin{lthooksCode}
%\ROW|{\c__hook_hashes_tl 1}|\\
%\ROW|{\c__hook_hashes_tl 2}|\\
%\ROW|...|\\
%\ROW|{\c__hook_hashes_tl 9}|\\
%\end{lthooksCode}
%    \begin{macrocode}
    \cs_set:Npn \@@_tmp:w ##1##2##3##4##5##6##7##8##9 { }
    \tl_set:Ne \l_@@_tmpb_tl
      { \@@_braced_cs_parameter:n { @@_tmp:w } }
    \group_begin:
      \@@_tl_set:cn { c_@@_hash_tl } { \exp_not:N \c_@@_hashes_tl }
      \use:e
        {
    \group_end:
    \tl_set:Nn \exp_not:N \l_@@_tmpb_tl { \l_@@_tmpb_tl }
        }
%    \end{macrocode}
%   And \cs[no-index]{l_@@_tmpa_tl} contains:
%\begin{lthooksCode}
%\ROW|{\c__hook_hash_tl 1}|\\
%\ROW|{\c__hook_hash_tl 2}|\\
%\ROW|...|\\
%\ROW|{\c__hook_hash_tl |\meta{n}|}|\\
%\end{lthooksCode}
%   with \meta{n} being the number of arguments declared for the hook.
%    \begin{macrocode}
    \exp_last_unbraced:NNf
    \cs_set:Npn \@@_tmp:w { \@@_parameter:n {#1} } { }
    \tl_set:Ne \l_@@_tmpa_tl { \@@_braced_cs_parameter:n { @@_tmp:w } }
%    \end{macrocode}
%   Now this function does the fun part.  It is meant to be used with
%   \cs{prop_map_function:NN}, taking a label name in \verb|##1| and the
%   code stored in that label in \verb|##2|.
%    \begin{macrocode}
    \cs_gset_protected:Npx \@@_normalise_fn:nn ##1 ##2
      {
%    \end{macrocode}
%   Here we'll define two auxiliary macros:  the first one throws an
%   error when it detects an invalid argument reference.  It piggybacks
%   on \TeX's low-level \enquote{Illegal parameter number} error, but it
%   defines a weirdly-named control sequence so that the error comes out
%   nicely formatted.  For example, if the label \enquote{badpkg} adds
%   some code that references argument \verb|#3| in the hook
%   \enquote{foo}, which takes only two arguments, the error will be:
%\begin{lthooksCode}
%\ROW|! Illegal parameter number in definition of hook 'foo'.|\\
%\ROW|(hooks)             Offending label: 'badpkg'.|\\
%\ROW|<to be read again> |\\
%\ROW|                   3|\\
%\end{lthooksCode}
%   At the point of this definition, the error is raised if the code
%   happens to reference an invalid argument.  If it was possible to
%   detect that this definition raised no error, the next step would be
%   unnecessary.  We'll do all this in a group so this weird definition
%   doesn't leak out, and set \cs{tex_escapechar:D} to $-1$ so this hack
%   shows up extra nice in the case of an error.
%    \begin{macrocode}
        \group_begin:
          \int_set:Nn \tex_escapechar:D { -1 }
          \cs_set:cpn
              {
                hook~'#1'. ^^J
                (hooks) \prg_replicate:nn { 13 } { ~ }
                #2 % more message text
              }
              \exp_not:v { c_@@_#1_parameter_tl }
            {##2}
        \group_end:
%    \end{macrocode}
%   This next macro, with a much less fabulous name, takes always nine
%   arguments, and it just transfers the code \verb|##2| under the label
%   \verb|##1| to the temporary property list.  The first \meta{n}
%   arguments are taken from \cs[no-index]{l_@@_tmpa_tl}, and the other
%   $9-\meta{n}$ taken from \cs[no-index]{l_@@_tmpb_tl} (which contains
%   twice as many \verb|#| tokens as the former).  Then,
%   \cs{@@_double_hashes:n} is used to double non-argument hashes, and
%   expand the \cs{c_@@_hash_tl} and \cs{c_@@_hashes_tl} to the actual
%   parameter tokens.
%    \begin{macrocode}
        \cs_set:Npn \exp_not:N \@@_tmp:w
            \exp_not:V \c_@@_nine_parameters_tl
          {
            \prop_put:Nne \exp_not:N \l_@@_work_prop
              {##1} { \exp_not:N \@@_double_hashes:n {##2} }
          }
%    \end{macrocode}
%   This next macro, with a much less fabulous name, takes always nine
%   arguments, and it just transfers the code \verb|##2| under the label
%   \verb|##1| to the temporary property list.  The first \meta{n}
%   arguments are taken from \cs[no-index]{l_@@_tmpa_tl}, and the other
%   $9-\meta{n}$ taken from \cs[no-index]{l_@@_tmpb_tl} (which contains
%   twice as many \verb|#| tokens as the former).  Then,
%   \cs{@@_double_hashes:n} is used to double non-argument hashes, and
%   expand the \cs{c_@@_hash_tl} and \cs{c_@@_hashes_tl} to the actual
%   parameter tokens.
%    \begin{macrocode}
        \exp_not:N \@@_tmp:w
          \exp_not:V \l_@@_tmpa_tl
          \exp_args:No \exp_not:o
            { \exp_after:wN \@@_tmp:w \l_@@_tmpb_tl }
      }
  }
\cs_new_eq:NN \@@_normalise_fn:nn ?
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_normalise_code_pool:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_normalise_code_pool:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_cs_if_empty:c}
%   Check if the expansion of a control sequence is empty by looking at
%   its replacement text.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_cs_if_empty:c}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \@@_cs_if_empty:c #1 { p, T, F, TF }
  {
    \if:w \scan_stop: \@@_replacement_spec:c {#1} \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new:Npn \@@_replacement_spec:c #1
  {
    \exp_args:Nc \token_if_macro:NT {#1}
      { \cs_replacement_spec:c {#1} }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_cs_if_empty:c}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_cs_if_empty:c
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_braced_cs_parameter:n}
% \begin{macro}{\@@_braced_hidden_loop:w}
% \begin{macro}{\@@_cs_parameter_count:N}
% \begin{macro}{\@@_cs_parameter_count:w,\@@_cs_end:w}
%   Looks at the \meta{parameter text} of a control sequence, and
%   returns a run of \enquote{hidden} braced parameters for that macro.
%   This works as long as the macros take a simple run of zero to nine
%   arguments.  The parameters are \enquote{hidden} because the
%   parameter tokens are returned inside \cs{c_@@_hash_tl} instead of
%   explicitly, so that \cs{@@_double_hashes:n} won't touch these.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_braced_cs_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_braced_cs_parameter:n #1
  {
    \exp_last_unbraced:Ne \@@_braced_hidden_loop:w
      { \exp_args:Nc \@@_cs_parameter_count:N {#1} } ? \s_@@_mark
  }
\cs_new:Npn \@@_braced_hidden_loop:w #1
  {
    \if:w ? #1
      \@@_use_i_delimit_by_s_mark:nw
    \fi:
    { \exp_not:N \c_@@_hash_tl #1 }
    \@@_braced_hidden_loop:w
  }
\cs_new:Npn \@@_cs_parameter_count:N #1
  {
    \exp_last_unbraced:Nf \@@_cs_parameter_count:w
      { \token_if_macro:NT #1 { \cs_parameter_spec:N #1 } }
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      \s_@@_mark
  }
\cs_new:Npn \@@_cs_parameter_count:w #1#2 #3#4 #5#6 #7#8
  { #2 #4 #6 #8 \@@_cs_parameter_count:w }
\cs_new:Npn \@@_cs_end:w #1 \s_@@_mark { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%   This function can't be undefined when rolling back because it's used
%   at the end of this module to adequate the hook data structures to
%   previous versions.
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_braced_cs_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_braced_parameter:n}
% \begin{macro}{\@@_braced_real_loop:w}
%   This one is used in simpler cases, where no special handling of
%   hashes is required.  This is used only inside
%   \cs{@@_initialize_hook_code:n}, so it assumes
%   \cs[no-index]{c_@@_\meta{hook}_parameter_tl} is defined, but should
%   work otherwise.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_braced_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_braced_parameter:n #1
  {
    \if_case:w
      \int_eval:n
        { \exp_args:Nv \str_count:n { c_@@_#1_parameter_tl } / 3 }
      \exp_stop_f:
    \or: {##1}
    \or: {##1} {##2}
    \or: {##1} {##2} {##3}
    \or: {##1} {##2} {##3} {##4}
    \or: {##1} {##2} {##3} {##4} {##5}
    \or: {##1} {##2} {##3} {##4} {##5} {##6}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8} {##9}
    \else:
      \msg_expandable_error:nnn { latex2e } { should-not-happen }
        { Invalid~parameter~spec. }
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_braced_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_braced_parameter:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_parameter:n}
%   This is just a shortcut to \verb|e|- or \verb|f|-expand to the
%   \meta{parameter text} of the hook.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_parameter:n #1
  {
    \cs:w c_@@_
    \tl_if_exist:cTF { c_@@_#1_parameter_tl }
      { #1_parameter } { empty }
    _tl \cs_end:
  }
\cs_new:Npn \@@_generic_parameter:n #1
  { \@@_generic_parameter:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_generic_parameter:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist_use:cF { c_@@_parameter_#1/./#3_tl }
      { \c_@@_empty_tl }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_parameter:n
%<latexrelease>\cs_undefine:N \@@_generic_parameter:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Adding or removing code for mirrored hook pairs}
%
% \begin{macro}[pTF]{\hook_if_paired:n}
% This function tests whether the hook argument was declared by
% \cs{NewMirroredHookPair} or \cs{NewMirroredHookPairWithArguments},
% when not builtin generic.
% Further testing the reversibility will determine if the hook
% is the first or the last element of the pair.
%
% When builtin generic, if the generic hook name ends with either 
% \hook{/before} or \hook{/after}, complete the mirrored pair
% with the matching \hook{before\string|after} name.
% If the \hook{.../after} hook is generic reversed,
% this is a hook pair.
%    \begin{macrocode}
\prg_new_conditional:Npnn \hook_if_paired:n #1 { T, TF }
  {
    \tl_if_exist:cTF { c_@@_pair_#1_tl }
      { \prg_return_true: }
      { \@@_if_paired:w #1 / / / \s_@@_mark }
  }
\cs_new:Npn \@@_if_paired:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \bool_lazy_or:nnTF
      { \str_if_eq_p:nn { #3 } { before } }
      { \str_if_eq_p:nn { #3 } { after  } }
      {
        \@@_if_generic_reversed:nTF { #1/#2/after }
          {
            \tl_const:cn
              { c_@@_pair_#1/#2/before_tl } { #1/#2/after }
            \tl_const:cn
              { c_@@_pair_#1/#2/after_tl } { #1/#2/before }
            \prg_return_true:
          }
          { \prg_return_false: }
      }
      {
        \tl_if_empty:nTF { #3 }
          {
            \bool_lazy_or:nnTF
              { \str_if_eq_p:nn { #2 } { before } }
              { \str_if_eq_p:nn { #2 } { after  } }
              {
                \@@_if_reversed:nTF { #1/after }
                  {
                    \tl_const:cn
                      { c_@@_pair_#1/before_tl } { #1/after }
                    \tl_const:cn
                      { c_@@_pair_#1/after_tl } { #1/before }
                    \prg_return_true:
                  }
                  { \prg_return_false: }
              }
              { \prg_return_false: }
          }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \IfHookPairedTF
% }
% The \LaTeXe\ API.
%    \begin{macrocode}
\cs_set_eq:NN \IfHookPairedTF \hook_if_paired:nTF
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \hook_pair_gput_code:nnnn,
%   \hook_pair_gput_code_with_args:nnnn
% }
% Adding code to pairs.
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_normalize_hook_args:Nnn { Nvn }
\cs_new_protected:Npn \hook_pair_gput_code:nnnn #1 #2 #3 #4
  {
    \hook_if_paired:nTF { #1 }
      {
        \@@_replacing_args_false:
        \@@_normalize_hook_args:Nnn \@@_gput_code:nnn
          {#1} {#2} {#3}
        \@@_normalize_hook_args:Nvn \@@_gput_code:nnn
          { c_@@_pair_#1_tl } {#2} {#4}
        \@@_replacing_args_reset:
      }
      {
        \msg_error:nnn { hooks } { missing-pair } {#1}
      }
  }
\cs_new_protected:Npn \hook_pair_gput_code_with_args:nnnn #1 #2 #3 #4
  {
    \hook_if_paired:nTF { #1 }
      {
        \@@_replacing_args_true:
        \@@_normalize_hook_args:Nnn \@@_gput_code:nnn
          {#1} {#2} {#3}
        \@@_normalize_hook_args:Nvn \@@_gput_code:nnn
          { c_@@_pair_#1_tl } {#2} {#4}
        \@@_replacing_args_reset:
      }
      {
        \msg_error:nnn { hooks } { missing-pair } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \hook_pair_gremove_code:nn
% }
% Removing code to pairs.
%    \begin{macrocode}
\cs_new_protected:Npn \hook_pair_gremove_code:nn #1 #2
  {
    \hook_if_paired:nTF { #1 }
      {
        \@@_normalize_hook_args:Nvn \@@_gremove_code:nn
          { c_@@_pair_#1_tl } {#2}
        \@@_normalize_hook_args:Nnn \@@_gremove_code:nn
          {#1} {#2}
      }
      {
        \msg_error:nnn { hooks } { missing-pair } {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%  \subsection{Setting rules for hooks code}
%
% \begin{macro}{
%     \g_@@_??_code_prop,
%     \@@~??,
%     \g_@@_??_reversed_tl,
%     \c_@@_??_parameter_tl,
%   }
%
%    Initially these variables simply used an empty ``label'' name (not
%    two question marks). This was a bit unfortunate, because then
%    \texttt{l3doc} complains about \verb=__= in the middle of a
%    command name when trying to typeset the documentation. However
%    using a ``normal'' name such as \texttt{default} has the
%    disadvantage of that being not really distinguishable from a real
%    hook name. I now have settled for \texttt{??} which needs some
%    gymnastics to get it into the csname, but since this is used a
%    lot, the code should be fast, so this is not done with \texttt{c}
%    expansion in the code later on.
%
%    \cs{@@\textvisiblespace??} isn't used, but it has to be defined to
%    trick the code into thinking that \texttt{??} is actually a hook.
%    \begin{macrocode}
\prop_new:c { g_@@_??_code_prop }
\prop_new:c { @@~?? }
%    \end{macrocode}
%
%    Default rules are always given in normal ordering (never in
%    reversed ordering). If such a rule is applied to a reversed
%    hook it behaves as if the rule is reversed (e.g.,
%    \texttt{after} becomes \texttt{before})
%    because those rules are applied first and then the order is reversed.
%    \begin{macrocode}
\tl_new:c { g_@@_??_reversed_tl }
%    \end{macrocode}
%
%    The parameter text for the \enquote{default} hook is empty.
% \changes{v1.1a}{2023/04/06}
%         {Token list added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\c_@@_??_parameter_tl}
%<latexrelease>                 {Hooks~with~args}
\tl_const:cn { c_@@_??_parameter_tl } { }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_??_parameter_tl}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:c { c_@@_??_parameter_tl }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_gset_rule:nnnn}
%  \begin{macro}{\@@_gset_rule:nnnn}
%    With
%    \cs{hook_gset_rule:nnnn}\Arg{hook-spec}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}
%    a relation is defined between the two code labels for the specified
%    hook.  The special hook \texttt{??} stands for \emph{any}
%    hook, which sets a default rule (to be used if no other relation
%    between the two labels exist).
%    \begin{macrocode}
\cs_new_protected:Npn \hook_gset_rule:nnnn #1#2#3#4
  {
    \@@_normalize_hook_rule_args:Nnnnn \@@_gset_rule:nnnn
      {#1} {#2} {#3} {#4}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2022/06/01}{\@@_gset_rule:nnnn}
%<latexrelease>                 {Refuse~setting~rule~for~one-time~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gset_rule:nnnn #1#2#3#4
  {
    \@@_if_deprecated_generic:nT {#1}
      {
        \@@_deprecated_generic_warn:n {#1}
        \@@_do_deprecated_generic:Nn \@@_gset_rule:nnnn {#1}
          {#2} {#3} {#4}
        \@@_use_none_delimit_by_s_mark:w
      }
    \@@_if_execute_immediately:nT {#1}
      {
        \msg_error:nnnnnn { hooks } { rule-too-late }
          {#1} {#2} {#3} {#4}
        \@@_use_none_delimit_by_s_mark:w
      }
%    \end{macrocode}
%    First we ensure the basic data structure of the hook exists:
%    \begin{macrocode}
    \@@_init_structure:n {#1}
%    \end{macrocode}
%    Then we clear any previous relationship between both labels.
%    \begin{macrocode}
    \@@_rule_gclear:nnn {#1} {#2} {#4}
%    \end{macrocode}
%    Then we call the function to handle the given rule. Throw an error if the
%    rule is invalid.
%    \begin{macrocode}
    \cs_if_exist_use:cTF { @@_rule_#3_gset:nnn }
      {
          {#1} {#2} {#4}
        \@@_update_hook_code:n {#1}
      }
      {
        \msg_error:nnnnnn { hooks } { unknown-rule }
          {#1} {#2} {#3} {#4}
      }
    \s_@@_mark
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_gset_rule:nnnn}
%<latexrelease>                 {Refuse~setting~rule~for~one-time~hooks}
%<latexrelease>\cs_new_protected:Npn \@@_gset_rule:nnnn #1#2#3#4
%<latexrelease>  {
%<latexrelease>    \@@_if_deprecated_generic:nT {#1}
%<latexrelease>      {
%<latexrelease>        \@@_deprecated_generic_warn:n {#1}
%<latexrelease>        \@@_do_deprecated_generic:Nn \@@_gset_rule:nnnn {#1}
%<latexrelease>          {#2} {#3} {#4}
%<latexrelease>        \exp_after:wN \use_none:nnnnnnnnn \use_none:n
%<latexrelease>      }
%<latexrelease>    \@@_init_structure:n {#1}
%<latexrelease>    \@@_rule_gclear:nnn {#1} {#2} {#4}
%<latexrelease>    \cs_if_exist_use:cTF { @@_rule_#3_gset:nnn }
%<latexrelease>      {
%<latexrelease>          {#1} {#2} {#4}
%<latexrelease>        \@@_update_hook_code:n {#1}
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \msg_error:nnnnnn { hooks } { unknown-rule }
%<latexrelease>          {#1} {#2} {#3} {#4}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_rule_before_gset:nnn, \@@_rule_after_gset:nnn,
%               \@@_rule_<_gset:nnn, \@@_rule_>_gset:nnn}
%    Then we add the new rule.  We need to normalize the rules here to
%    allow for faster processing later.  Given a pair of labels
%    $l_A$ and $l_B$, the rule $l_A>l_B$ is the same as $l_B<l_A$
%    only presented differently.  But by normalizing the
%    forms of the rule to a single representation, say, $l_B<l_A$, reduces
%    the time spent looking for the rules later considerably.
%
%    Here we do that normalization by using \cs[no-index]{(pdf)strcmp} to
%    lexically sort labels $l_A$ and $l_B$ to a fixed order.  This order
%    is then enforced every time these two labels are used together.
%
%    Here we use \cs{@@_label_pair:nn}~\Arg{hook}~\Arg{l_A}~\Arg{l_B}
%    to build a string \texttt{$l_B$\string|$l_A$} with a fixed order, and
%    use \cs{@@_label_ordered:nnTF} to apply the correct rule to the pair
%    of labels, depending if it was sorted or not.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_before_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
      { \@@_label_ordered:nnTF {#2} {#3} { < } { > } }
  }
\cs_new_eq:cN { @@_rule_<_gset:nnn } \@@_rule_before_gset:nnn
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_after_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#3} {#2} _tl }
      { \@@_label_ordered:nnTF {#3} {#2} { < } { > } }
  }
\cs_new_eq:cN { @@_rule_>_gset:nnn } \@@_rule_after_gset:nnn
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_rule_voids_gset:nnn}
%   This rule removes (clears, actually) the code from label |#3| if
%   label |#2| is in the hook |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_voids_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
      { \@@_label_ordered:nnTF {#2} {#3} { -> } { <- } }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{
%     \@@_rule_incompatible-error_gset:nnn,
%     \@@_rule_incompatible-warning_gset:nnn,
%   }
%   These relations make an error/warning if labels |#2| and |#3| appear
%   together in hook |#1|.
%    \begin{macrocode}
\cs_new_protected:cpn { @@_rule_incompatible-error_gset:nnn } #1#2#3
  { \@@_tl_gset:cn { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
                   { xE } }
\cs_new_protected:cpn { @@_rule_incompatible-warning_gset:nnn } #1#2#3
  { \@@_tl_gset:cn { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
                   { xW } }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_rule_unrelated_gset:nnn, \@@_rule_gclear:nnn}
%    Undo a setting. \cs{@@_rule_unrelated_gset:nnn} doesn't need to do anything,
%    since we use \cs{@@_rule_gclear:nnn} before setting any rule.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_unrelated_gset:nnn #1#2#3 { }
\cs_new_protected:Npn \@@_rule_gclear:nnn #1#2#3
  { \cs_undefine:c { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl } }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_label_pair:nn}
%   Ensure that the lexically greater label comes first.
%    \begin{macrocode}
\cs_new:Npn \@@_label_pair:nn #1#2
  {
    \if_case:w \@@_str_compare:nn {#1} {#2} \exp_stop_f:
           #1 | #1 %  0
    \or:   #1 | #2 % +1
    \else: #2 | #1 % -1
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_label_ordered:nn}
%   Check that labels |#1| and |#2| are in the correct order (as
%   returned by \cs{@@_label_pair:nn}) and if so return true, else
%   return false.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_label_ordered:nn #1#2 { TF }
  {
    \if_int_compare:w \@@_str_compare:nn {#1} {#2} > 0 \exp_stop_f:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_if_label_case:nnnnn}
%   To avoid doing the string comparison twice in \cs{@@_initialize_single:NNn}
%   (once with \cs{str_if_eq:nn} and again with \cs{@@_label_ordered:nn}),
%   we use a three-way branching macro that will compare |#1| and |#2|
%   and expand to \cs{use_i:nnn} if they are equal, \cs{use_ii:nn} if
%   |#1| is lexically greater, and \cs{use_iii:nn} otherwise.
%    \begin{macrocode}
\cs_new:Npn \@@_if_label_case:nnnnn #1#2
  {
    \cs:w use_
      \if_case:w \@@_str_compare:nn {#1} {#2}
         i \or: ii \else: iii \fi: :nnn
    \cs_end:
  }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@@_update_hook_code:n}
%    Before \verb=\begin{document}=  this does nothing, in the body it
%    reinitializes the hook code using the altered data.
%    \begin{macrocode}
\cs_new_eq:NN \@@_update_hook_code:n \use_none:n
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@@_initialize_all:}
%    Initialize all known hooks (at \verb=\begin{document}=), i.e.,
%    update the fast execution token lists to hold the necessary code
%    in the right order.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_all:}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_all:
  {
%    \end{macrocode}
%    First we change \cs{@@_update_hook_code:n} which so far was a
%    no-op to now initialize one hook. This way any later updates to
%    the hook will run that code and also update the execution token
%    list.
%    \begin{macrocode}
    \cs_gset_eq:NN \@@_update_hook_code:n \@@_initialize_hook_code:n
%    \end{macrocode}
%    Now we loop over all hooks that have been defined and update each
%    of them.  Here we have to determine if the hook has arguments so
%    that auxiliaries know what to do with hashes.  We look at
%    \cs[no-index]{c_@@_\meta{hook}_parameter_tl}, if it has any
%    parameters, and set \verb|replacing_args| accordingly.
%    \begin{macrocode}
    \@@_debug:n { \prop_gclear:N \g_@@_used_prop }
    \seq_map_inline:Nn \g_@@_all_seq
      {
        \tl_if_empty:cTF { c_@@_##1_parameter_tl }
          { \@@_replacing_args_false: }
          { \@@_replacing_args_true: }
        \@@_update_hook_code:n {##1}
        \@@_replacing_args_reset:
      }
%    \end{macrocode}
%    If we are debugging we show results hook by hook for all hooks
%    that have data.
%    \begin{macrocode}
    \@@_debug:n
      {
        \iow_term:x { ^^J All~initialized~(non-empty)~hooks: }
        \prop_map_inline:Nn \g_@@_used_prop
          {
            \iow_term:x
              { ^^J ~ ##1 ~ -> ~ \cs_replacement_spec:c { @@~##1 } ~ }
          }
      }
%    \end{macrocode}
%    After all hooks are initialized we change the ``use'' to just
%    call the hook code and not initialize it (as it was done in the
%    preamble.
%    \begin{macrocode}
    \@@_post_initialization_defs:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_all:}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_initialize_all:
%<latexrelease>  {
%<latexrelease>    \cs_gset_eq:NN \@@_update_hook_code:n \@@_initialize_hook_code:n
%<latexrelease>    \@@_debug:n { \prop_gclear:N \g_@@_used_prop }
%<latexrelease>    \seq_map_inline:Nn \g_@@_all_seq
%<latexrelease>      { \@@_update_hook_code:n {##1} }
%<latexrelease>    \@@_debug:n
%<latexrelease>      {
%<latexrelease>        \iow_term:x{^^JAll~ initialized~ (non-empty)~ hooks:}
%<latexrelease>        \prop_map_inline:Nn \g_@@_used_prop
%<latexrelease>          {
%<latexrelease>            \iow_term:x
%<latexrelease>              { ^^J ~ ##1 ~ -> ~ \cs_replacement_spec:c { @@~##1 } ~ }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \cs_gset_eq:NN \hook_use:n \@@_use_initialized:n
%<latexrelease>    \cs_gset_eq:NN \@@_preamble_hook:n \use_none:n
%<latexrelease>  }
%<@@=>
%<latexrelease>\cs_gset_eq:NN \@expl@@@initialize@all@@
%<latexrelease>               \__hook_initialize_all:
%<@@=hook>
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\@@_initialize_hook_code:n}
%    Initializing or reinitializing the fast execution hook code. In
%    the preamble this is selectively done in case a hook gets used
%    and at \verb=\begin{document}= this is done for all hooks and
%    afterwards only if the hook code changes.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_hook_code:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_hook_code:n #1
  {
    \@@_debug:n
      { \iow_term:x { ^^J Update~code~for~hook~'#1' \on@line :^^J } }
%    \end{macrocode}
%    This does the sorting and the updates.
%    First thing we do is to check if a legacy hook macro exists and
%    if so we add it to the hook under the label \texttt{legacy}. This
%    might make the hook non-empty so we have to do this before
%    the then following test.
%    \begin{macrocode}
    \@@_include_legacy_code_chunk:n {#1}
%    \end{macrocode}
%    If there aren't any code
%    chunks for the current hook, there is no point in even starting
%    the sorting routine so we make a quick test for that and in that
%    case just update \cs{@@\textvisiblespace\meta{hook}} to hold the |top-level| and
%    |next| code chunks. If there are code chunks we call
%    \cs{@@_initialize_single:NNn} and pass to it ready made csnames
%    as they are needed several times inside. This way we save a bit
%    on processing time if we do that up front.
% \changes{v1.0u}{2022/05/17}{Refuse sorting one-time hooks (gh/818).}
%    \begin{macrocode}
    \@@_if_usable:nT {#1}
      {
        \prop_if_empty:cTF { g_@@_#1_code_prop }
          {
            \@@_code_gset:ne {#1}
              {
%    \end{macrocode}
%   The hook may take arguments, so we add a run of braced parameters
%   after the \verb|_next| and \verb|_toplevel| macros, so that the
%   arguments passed to the hook are forwarded to them.
%    \begin{macrocode}
                \exp_not:c { @@_toplevel~#1 } \@@_braced_parameter:n {#1}
                \exp_not:c { @@_next~#1 } \@@_braced_parameter:n {#1}
              }
          }
          {
%    \end{macrocode}
%    By default the algorithm sorts the code chunks and then saves the
%    result in a token list for fast execution; this is done by adding the code chunks
%    one after another, using \cs{tl_gput_right:NV}. When we sort code for
%    a reversed hook, all we have to do is to add the code chunks in
%    the opposite order into the token list. So all we have to do
%    in preparation is to change two definitions that are used later on.
%    \begin{macrocode}
            \@@_if_reversed:nTF {#1}
              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_left:Nn
                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_left:NV  }
              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_right:Nn
                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_right:NV }
%    \end{macrocode}
%
%    When sorting, some relations (namely \verb|voids|) need to
%    act destructively on the code property lists to remove code that
%    shouldn't appear in the sorted hook token list, so we make a copy
%    of the code property list that we can safely work on without
%    changing the main one.
%    \begin{macrocode}
            \prop_set_eq:Nc \l_@@_work_prop { g_@@_#1_code_prop }
            \@@_initialize_single:ccn
              { @@~#1 } { g_@@_#1_labels_clist } {#1}
%    \end{macrocode}
%    For debug display we want to keep track of those hooks that
%    actually got code added to them, so we record that in plist. We
%    use a plist to ensure that we record each hook name only once,
%    i.e., we are only interested in storing the keys and the value is
%    arbitrary.
%    \begin{macrocode}
            \@@_debug:n
              { \exp_args:NNx \prop_gput:Nnn \g_@@_used_prop {#1} { } }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_hook_code:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_initialize_hook_code:n #1
%<latexrelease>  {
%<latexrelease>    \@@_debug:n
%<latexrelease>      { \iow_term:x { ^^J Update~code~for~hook~'#1' \on@line :^^J } }
%<latexrelease>    \@@_include_legacy_code_chunk:n {#1}
%<latexrelease>    \@@_if_usable:nT {#1}
%<latexrelease>      {
%<latexrelease>        \prop_if_empty:cTF { g_@@_#1_code_prop }
%<latexrelease>          {
%<latexrelease>            \@@_tl_gset:co { @@~#1 }
%<latexrelease>              {
%<latexrelease>                \cs:w @@_toplevel~#1 \exp_after:wN \cs_end:
%<latexrelease>                \cs:w @@_next~#1 \cs_end:
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_if_reversed:nTF {#1}
%<latexrelease>              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_left:Nn
%<latexrelease>                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_left:NV  }
%<latexrelease>              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_right:Nn
%<latexrelease>                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_right:NV }
%<latexrelease>            \prop_set_eq:Nc \l_@@_work_prop { g_@@_#1_code_prop }
%<latexrelease>            \@@_initialize_single:ccn
%<latexrelease>              { @@~#1 } { g_@@_#1_labels_clist } {#1}
%<latexrelease>            \@@_debug:n
%<latexrelease>              { \exp_args:NNx \prop_gput:Nnn \g_@@_used_prop {#1} { } }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}[EXP]{\@@_tl_csname:n,\@@_seq_csname:n}
%   It is faster to pass a single token and expand it when necessary
%   than to pass a bunch of character tokens around.
%   \fmiinline{note to myself: verify}
%    \begin{macrocode}
\cs_new:Npn \@@_tl_csname:n #1 { l_@@_label_#1_tl }
\cs_new:Npn \@@_seq_csname:n #1 { l_@@_label_#1_seq }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}{\l_@@_labels_seq,\l_@@_labels_int,\l_@@_front_tl,
%      \l_@@_rear_tl,\l_@@_label_0_tl}
%
%    For the sorting I am basically implementing Knuth's algorithm for
%    topological sorting as given in TAOCP volume 1 pages 263--266.
%    For this algorithm we need a number of local variables:
%    \begin{itemize}
%    \item
%       List of labels used in the current hook to label code chunks:
%    \begin{macrocode}
\seq_new:N \l_@@_labels_seq
%    \end{macrocode}
%    \item
%      Number of labels used in the current hook. In Knuth's algorithm
%      this is called $N$:
%    \begin{macrocode}
\int_new:N \l_@@_labels_int
%    \end{macrocode}
%    \item
%      The sorted code list to be build is managed using two pointers
%      one to the front of the queue and one to the rear. We model this
%      using token list pointers. Knuth calls them $F$ and $R$:
%    \begin{macrocode}
\tl_new:N \l_@@_front_tl
\tl_new:N \l_@@_rear_tl
%    \end{macrocode}
%    \item
%      The data for the start of the queue is kept in this token list,
%      it corresponds to what Don calls \texttt{QLINK[0]} but since we
%      aren't manipulating individual words in memory it is slightly
%      differently done:
%    \begin{macrocode}
\tl_new:c { \@@_tl_csname:n { 0 } }
%    \end{macrocode}
%
%    \end{itemize}
%  \end{macro}
%
%
%  \begin{macro}{\@@_initialize_single:NNn,\@@_initialize_single:ccn}
%
%    \cs{@@_initialize_single:NNn} implements the sorting of the code
%    chunks for a hook and saves the result in the token list for fast
%    execution (\verb=#4=). The arguments are \meta{hook-code-plist},
%    \meta{hook-code-tl}, \meta{hook-top-level-code-tl},
%    \meta{hook-next-code-tl},
%    \meta{hook-ordered-labels-clist} and \meta{hook-name} (the latter
%    is only used for debugging---the \meta{hook-rule-plist} is accessed
%    using the \meta{hook}).
%
%    The additional complexity compared to Don's algorithm is that we
%    do not use simple positive integers but have arbitrary
%    alphanumeric labels. As usual Don's data structures are chosen in
%    a way that one can omit a lot of tests and I have mimicked that as
%    far as possible. The result is a restriction I do not test for at
%    the moment: a label can't be equal to the number 0!
%  \fmiinline{Needs checking for, just in case ... maybe}
%
%    ^^A #1 <- \@@~#1
%    ^^A #2 <- \g_@@_#1_labels_clist
%    ^^A #3 <- #1
%
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_single:NNn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_single:NNn #1#2#3
  {
%    \end{macrocode}
%    Step T1: Initialize the data structure \ldots
%    \begin{macrocode}
    \seq_clear:N \l_@@_labels_seq
    \int_zero:N  \l_@@_labels_int
%    \end{macrocode}
%
%    Store the name of the hook:
%    \begin{macrocode}
    \tl_set:Nn \l_@@_cur_hook_tl {#3}
%    \end{macrocode}
%
%    We loop over the property list holding the code and record all
%    the labels listed there. Only the rules for those labels are of interest
%    to us. While we are at it we count them (which gives us the $N$
%    in Knuth's algorithm).  The prefix |label_| is added to the variables
%    to ensure that labels named |front|, |rear|, |labels|, or |return|
%    don't interact with our code.
%    \begin{macrocode}
    \prop_map_inline:Nn \l_@@_work_prop
       {
         \int_incr:N \l_@@_labels_int
         \seq_put_right:Nn \l_@@_labels_seq {##1}
         \@@_tl_set:cn { \@@_tl_csname:n {##1} } { 0 }
         \seq_clear_new:c { \@@_seq_csname:n {##1} }
       }
%    \end{macrocode}
%    Steps T2 and T3: Here we sort the relevant rules into the data structure\ldots
%
%    This loop constitutes a square matrix of the labels in
%    \cs{l_@@_work_prop} in the
%    vertical and the horizontal directions.  However, since the rule
%    $l_A\meta{rel}l_B$ is the same as $l_B\meta{rel}^{-1}l_A$ we can cut
%    the loop short at the diagonal of the matrix (\emph{i.e.}, when
%    both labels are equal), saving a good amount of time.  The way the
%    rules were set up (see the implementation of \cs{@@_rule_before_gset:nnn}
%    above) ensures that we have no rule in the ignored side of the
%    matrix, and all rules are seen.  The rules are applied in
%    \cs{@@_apply_label_pair:nnn}, which takes the properly-ordered pair
%    of labels as argument.
%    \begin{macrocode}
    \prop_map_inline:Nn \l_@@_work_prop
      {
        \prop_map_inline:Nn \l_@@_work_prop
          {
            \@@_if_label_case:nnnnn {##1} {####1}
              { \prop_map_break: }
              { \@@_apply_label_pair:nnn {##1} {####1} }
              { \@@_apply_label_pair:nnn {####1} {##1} }
                  {#3}
          }
      }
%    \end{macrocode}
%    Now take a breath, and look at the data structures that have
%    been set up:
%    \begin{macrocode}
    \@@_debug:n { \@@_debug_label_data:N \l_@@_work_prop }
%    \end{macrocode}
%
%
%    Step T4:
%    \begin{macrocode}
    \tl_set:Nn \l_@@_rear_tl { 0 }
    \tl_set:cn { \@@_tl_csname:n { 0 } } { 0 }
    \seq_map_inline:Nn \l_@@_labels_seq
      {
        \int_compare:nNnT { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
            {
              \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } }{##1}
              \tl_set:Nn \l_@@_rear_tl {##1}
            }
      }
    \tl_set_eq:Nc \l_@@_front_tl { \@@_tl_csname:n { 0 } }
%    \end{macrocode}
%
%    \begin{macrocode}
    \@@_tl_gclear:N #1
    \clist_gclear:N #2
%    \end{macrocode}
%
%    The whole loop gets combined in steps T5--T7:
%    \begin{macrocode}
    \bool_while_do:nn { ! \str_if_eq_p:Vn \l_@@_front_tl { 0 } }
      {
%    \end{macrocode}
%    This part is step T5:
%    \begin{macrocode}
        \int_decr:N \l_@@_labels_int
        \prop_get:NVN \l_@@_work_prop \l_@@_front_tl \l_@@_return_tl
        \exp_args:NNV \@@_tl_gput:Nn #1 \l_@@_return_tl
%    \end{macrocode}
%
%    \begin{macrocode}
        \@@_clist_gput:NV #2 \l_@@_front_tl
        \@@_debug:n{ \iow_term:x{Handled~ code~ for~ \l_@@_front_tl} }
%    \end{macrocode}
%
%    This is step T6, except that we don't use a pointer $P$ to move
%    through the successors, but instead use \verb=##1= of the mapping
%    function.
%    \begin{macrocode}
        \seq_map_inline:cn { \@@_seq_csname:n { \l_@@_front_tl } }
          {
            \tl_set:cx { \@@_tl_csname:n {##1} }
                       { \int_eval:n
                           { \cs:w \@@_tl_csname:n {##1} \cs_end: - 1 }
                       }
            \int_compare:nNnT
                { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
                {
                  \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } } {##1}
                  \tl_set:Nn \l_@@_rear_tl            {##1}
                }
          }
%    \end{macrocode}
%    and here is step T7:
%    \begin{macrocode}
        \tl_set_eq:Nc \l_@@_front_tl
                      { \@@_tl_csname:n { \l_@@_front_tl } }
%    \end{macrocode}
%
%    This is step T8: If we haven't moved the code for all labels
%    (i.e., if \cs{l_@@_labels_int} is still greater than zero) we
%    have a loop and our partial order can't be flattened out.
%    \begin{macrocode}
      }
    \int_compare:nNnF \l_@@_labels_int = 0
      {
        \iow_term:x{====================}
        \iow_term:x{Error:~ label~ rules~ are~ incompatible:}
%    \end{macrocode}
%
%    This is not really the information one needs in the error case
%    but it will do for now \ldots \fmiinline{improve output on a rainy day}
%    \begin{macrocode}
        \@@_debug_label_data:N \l_@@_work_prop
        \iow_term:x{====================}
      }
%    \end{macrocode}
%    After we have added all hook code to \verb=#1=, we finish it off
%    by adding extra code for the |top-level| (\verb=#2=) and for one
%    time execution (\verb=#3=).  These should normally be empty.  The
%    |top-level| code is added with \cs{@@_tl_gput:Nn} as that might
%    change for a reversed hook (then |top-level| is the very first code
%    chunk added).  The |next| code is always added last (to the right).
%   The hook may take arguments, so we add a run of braced parameters
%   after the \verb|_next| and \verb|_toplevel| macros, so that the
%   arguments passed to the hook are forwarded to them.
%    \begin{macrocode}
    \exp_args:NNe \@@_tl_gput:Nn #1
      { \exp_not:c { @@_toplevel~#3 } \@@_braced_parameter:n {#3} }
    \@@_tl_gput_right:Ne #1
      { \exp_not:c { @@_next~#3 } \@@_braced_parameter:n {#3} }
    \use:e
      {
        \cs_gset:cpn { @@~#3 } \use:c { c_@@_#3_parameter_tl }
          { \exp_not:V #1 }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_initialize_single:NNn { cc }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_single:NNn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_initialize_single:NNn #1#2#3
%<latexrelease>  {
%<latexrelease>    \seq_clear:N \l_@@_labels_seq
%<latexrelease>    \int_zero:N  \l_@@_labels_int
%<latexrelease>    \tl_set:Nn \l_@@_cur_hook_tl {#3}
%<latexrelease>    \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>       {
%<latexrelease>         \int_incr:N \l_@@_labels_int
%<latexrelease>         \seq_put_right:Nn \l_@@_labels_seq {##1}
%<latexrelease>         \@@_tl_set:cn { \@@_tl_csname:n {##1} } { 0 }
%<latexrelease>         \seq_clear_new:c { \@@_seq_csname:n {##1} }
%<latexrelease>       }
%<latexrelease>    \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>      {
%<latexrelease>        \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>          {
%<latexrelease>            \@@_if_label_case:nnnnn {##1} {####1}
%<latexrelease>              { \prop_map_break: }
%<latexrelease>              { \@@_apply_label_pair:nnn {##1} {####1} }
%<latexrelease>              { \@@_apply_label_pair:nnn {####1} {##1} }
%<latexrelease>                  {#3}
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \@@_debug:n { \@@_debug_label_data:N \l_@@_work_prop }
%<latexrelease>    \tl_set:Nn \l_@@_rear_tl { 0 }
%<latexrelease>    \tl_set:cn { \@@_tl_csname:n { 0 } } { 0 }
%<latexrelease>    \seq_map_inline:Nn \l_@@_labels_seq
%<latexrelease>      {
%<latexrelease>        \int_compare:nNnT { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
%<latexrelease>            {
%<latexrelease>              \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } }{##1}
%<latexrelease>              \tl_set:Nn \l_@@_rear_tl {##1}
%<latexrelease>            }
%<latexrelease>      }
%<latexrelease>    \tl_set_eq:Nc \l_@@_front_tl { \@@_tl_csname:n { 0 } }
%<latexrelease>    \@@_tl_gclear:N #1
%<latexrelease>    \clist_gclear:N #2
%<latexrelease>    \bool_while_do:nn { ! \str_if_eq_p:Vn \l_@@_front_tl { 0 } }
%<latexrelease>      {
%<latexrelease>        \int_decr:N \l_@@_labels_int
%<latexrelease>        \prop_get:NVN \l_@@_work_prop \l_@@_front_tl \l_@@_return_tl
%<latexrelease>        \exp_args:NNV \@@_tl_gput:Nn #1 \l_@@_return_tl
%<latexrelease>        \@@_clist_gput:NV #2 \l_@@_front_tl
%<latexrelease>        \@@_debug:n{ \iow_term:x{Handled~ code~ for~ \l_@@_front_tl} }
%<latexrelease>        \seq_map_inline:cn { \@@_seq_csname:n { \l_@@_front_tl } }
%<latexrelease>          {
%<latexrelease>            \tl_set:cx { \@@_tl_csname:n {##1} }
%<latexrelease>                       { \int_eval:n
%<latexrelease>                           { \cs:w \@@_tl_csname:n {##1} \cs_end: - 1 }
%<latexrelease>                       }
%<latexrelease>            \int_compare:nNnT
%<latexrelease>                { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
%<latexrelease>                {
%<latexrelease>                  \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } } {##1}
%<latexrelease>                  \tl_set:Nn \l_@@_rear_tl            {##1}
%<latexrelease>                }
%<latexrelease>          }
%<latexrelease>        \tl_set_eq:Nc \l_@@_front_tl
%<latexrelease>                      { \@@_tl_csname:n { \l_@@_front_tl } }
%<latexrelease>      }
%<latexrelease>    \int_compare:nNnF \l_@@_labels_int = 0
%<latexrelease>      {
%<latexrelease>        \iow_term:x{====================}
%<latexrelease>        \iow_term:x{Error:~ label~ rules~ are~ incompatible:}
%<latexrelease>        \@@_debug_label_data:N \l_@@_work_prop
%<latexrelease>        \iow_term:x{====================}
%<latexrelease>      }
%<latexrelease>    \exp_args:NNo \@@_tl_gput:Nn #1 { \cs:w @@_toplevel~#3 \cs_end: }
%<latexrelease>    \@@_tl_gput_right:No #1 { \cs:w @@_next~#3 \cs_end: }
%<latexrelease>  }
%<latexrelease>\cs_generate_variant:Nn \@@_tl_gput_right:Nn { No }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\@@_tl_gput:Nn,\@@_clist_gput:NV}
%    These append either on the right (normal hook) or on the left
%    (reversed hook). This is setup up in
%    \cs{@@_initialize_hook_code:n}, elsewhere their behavior is undefined.
%    \begin{macrocode}
\cs_new:Npn \@@_tl_gput:Nn    { \ERROR }
\cs_new:Npn \@@_clist_gput:NV { \ERROR }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\@@_apply_label_pair:nnn,\@@_label_if_exist_apply:nnnF}
%
%    This is the payload of steps T2 and T3 executed in the loop described
%    above. This macro assumes |#1| and |#2| are ordered, which means that
%    any rule pertaining the pair |#1| and |#2| is
%    \cs{g_@@_\meta{hook}_rule_\#1\string|\#2_tl}, and not
%    \cs{g_@@_\meta{hook}_rule_\#2\string|\#1_tl}.  This also saves a great deal
%    of time since we only need to check the order of the labels once.
%
%    The arguments here are \meta{label_1}, \meta{label_2}, \meta{hook}, and
%    \meta{hook-code-plist}.  We are about to apply the next rule and
%    enter it into the data structure.  \cs{@@_apply_label_pair:nnn} will
%    just call \cs{@@_label_if_exist_apply:nnnF} for the \meta{hook}, and
%    if no rule is found, also try the \meta{hook} name \texttt{??}
%    denoting a default hook rule.
%
%    \cs{@@_label_if_exist_apply:nnnF} will check if the rule exists for
%    the given hook, and if so call \cs{@@_apply_rule:nnn}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_apply_label_pair:nnn #1#2#3
  {
%    \end{macrocode}
%    Extra complication: as we use default rules and local hook specific
%    rules we first have to check if there is a local rule and if that
%    exist use it. Otherwise check if there is a default rule and use
%    that.
%    \begin{macrocode}
    \@@_label_if_exist_apply:nnnF {#1} {#2} {#3}
      {
%    \end{macrocode}
%    If there is no hook-specific rule we check for a default one and
%    use that if it exists.
%    \begin{macrocode}
        \@@_label_if_exist_apply:nnnF {#1} {#2} { ?? } { }
      }
  }
\cs_new_protected:Npn \@@_label_if_exist_apply:nnnF #1#2#3
  {
    \if_cs_exist:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end:
%    \end{macrocode}
%    What to do precisely depends on the type of rule we have
%    encountered. If it is a \texttt{before} rule it will be handled by the
%    algorithm but other types need to be managed differently. All
%    this is done in \cs{@@_apply_rule:nnnN}.
%    \begin{macrocode}
      \@@_apply_rule:nnn {#1} {#2} {#3}
      \exp_after:wN \use_none:n
    \else:
      \use:nn
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%  \JLNote{Update the rule separator}
%
%
%
%
%  \begin{macro}{\@@_apply_rule:nnn}
%    This is the code executed in steps T2 and T3 while looping through
%    the matrix  This is part of step T3. We are about to apply the next
%    rule and enter it into the data structure. The arguments are
%    \meta{label_1}, \meta{label_2}, \meta{hook}, and \meta{hook-code-plist}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_apply_rule:nnn #1#2#3
  {
    \cs:w @@_apply_
      \cs:w g_@@_#3_reversed_tl \cs_end: rule_
        \cs:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end: :nnn \cs_end:
      {#1} {#2} {#3}
  }
%    \end{macrocode}
%  \JLNote{3 or 4 arguments?}
% \end{macro}
%
%  \begin{macro}{\@@_apply_rule_<:nnn,\@@_apply_rule_>:nnn}
%    The most common cases are \texttt{\string<} and \texttt{\string>} so we handle
%    that first.  They are relations $\prec$ and $\succ$ in TAOCP, and
%    they dictate sorting.
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_<:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \tl_set:cx { \@@_tl_csname:n {#2} }
       { \int_eval:n{ \cs:w \@@_tl_csname:n {#2} \cs_end: + 1 } }
    \seq_put_right:cn{ \@@_seq_csname:n {#1} }{#2}
  }
\cs_new_protected:cpn { @@_apply_rule_>:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \tl_set:cx { \@@_tl_csname:n {#1} }
       { \int_eval:n{ \cs:w \@@_tl_csname:n {#1} \cs_end: + 1 } }
    \seq_put_right:cn{ \@@_seq_csname:n {#2} }{#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_apply_rule_xE:nnn,\@@_apply_rule_xW:nnn}
%   These relations make two labels incompatible within a hook.
%   |xE| makes raises an error if the labels are found in the same
%   hook, and |xW| makes it a warning.
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_xE:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \msg_error:nnnnnn { hooks } { labels-incompatible }
      {#1} {#2} {#3} { 1 }
    \use:c { @@_apply_rule_->:nnn } {#1} {#2} {#3}
    \use:c { @@_apply_rule_<-:nnn } {#1} {#2} {#3}
  }
\cs_new_protected:cpn { @@_apply_rule_xW:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \msg_warning:nnnnnn { hooks } { labels-incompatible }
      {#1} {#2} {#3} { 0 }
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\@@_apply_rule_->:nnn,\@@_apply_rule_<-:nnn}
%    If we see \texttt{\detokenize{->}} we have to drop code for label
%    \verb=#3= and carry on. We could do a little better and drop
%    everything for that label since it doesn't matter where we put
%    such empty code. However that would complicate the algorithm a
%    lot with little gain.\footnote{This also has the advantage that
%    the result of the sorting doesn't change, as it might otherwise do
%    (for unrelated chunks) if we aren't careful.} So we still
%    unnecessarily try to sort it in and depending on the rules that
%    might result in a loop that is otherwise resolved. If that turns
%    out to be a real issue, we can improve the code.
%
%    Here the code is removed from \cs{l_@@_cur_hook_tl} rather than
%    \verb=#3= because the latter may be \texttt{??}, and the default
%    hook doesn't store any code.  Removing it instead from \cs{l_@@_cur_hook_tl}
%    makes the default rules \verb=->= and  \verb=<-= work properly.
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_->:nnn } #1#2#3
  {
    \@@_debug:n
       {
         \@@_msg_pair_found:nnn {#1} {#2} {#3}
         \iow_term:x{--->~ Drop~ '#2'~ code~ from~
           \iow_char:N \\ g_@@_ \l_@@_cur_hook_tl _code_prop ~
           because~ of~ '#1' }
       }
    \prop_put:Nnn \l_@@_work_prop {#2} { }
  }
\cs_new_protected:cpn { @@_apply_rule_<-:nnn } #1#2#3
  {
    \@@_debug:n
       {
         \@@_msg_pair_found:nnn {#1} {#2} {#3}
         \iow_term:x{--->~ Drop~ '#1'~ code~ from~
           \iow_char:N \\ g_@@_ \l_@@_cur_hook_tl _code_prop ~
           because~ of~ '#2' }
       }
    \prop_put:Nnn \l_@@_work_prop {#1} { }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{
%     \@@_apply_-rule_<:nnn,
%     \@@_apply_-rule_>:nnn,
%     \@@_apply_-rule_<-:nnn,
%     \@@_apply_-rule_->:nnn,
%     \@@_apply_-rule_xW:nnn,
%     \@@_apply_-rule_xE:nnn,
%   }
%   Reversed rules.
%    \begin{macrocode}
\cs_new_eq:cc { @@_apply_-rule_<:nnn } { @@_apply_rule_>:nnn }
\cs_new_eq:cc { @@_apply_-rule_>:nnn } { @@_apply_rule_<:nnn }
\cs_new_eq:cc { @@_apply_-rule_<-:nnn } { @@_apply_rule_<-:nnn }
\cs_new_eq:cc { @@_apply_-rule_->:nnn } { @@_apply_rule_->:nnn }
\cs_new_eq:cc { @@_apply_-rule_xE:nnn } { @@_apply_rule_xE:nnn }
\cs_new_eq:cc { @@_apply_-rule_xW:nnn } { @@_apply_rule_xW:nnn }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_msg_pair_found:nnn}
%   A macro to avoid moving this many tokens around.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_msg_pair_found:nnn #1#2#3
  {
    \iow_term:x{~ \str_if_eq:nnTF {#3} {??} {default} {~normal} ~
        rule~ \@@_label_pair:nn {#1} {#2}:~
        \use:c { g_@@_#3_rule_ \@@_label_pair:nn {#1} {#2} _tl } ~
        found}
  }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}{\@@_debug_label_data:N}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_debug_label_data:N #1 {
  \iow_term:x{Code~ labels~ for~ sorting:}
  \iow_term:x{~ \seq_use:Nnnn\l_@@_labels_seq {~and~}{,~}{~and~} }
  \iow_term:x{^^J Data~ structure~ for~ label~ rules:}
  \prop_map_inline:Nn #1
       {
         \iow_term:x{~ ##1~ =~ \tl_use:c{ \@@_tl_csname:n {##1} }~ ->~
           \seq_use:cnnn{ \@@_seq_csname:n {##1} }{~->~}{~->~}{~->~}
         }
       }
  \iow_term:x{}
}
%    \end{macrocode}
%  \end{macro}
%
% \begin{variable}{\l_@@_info_seq}
% Sequence to record the code chunk labels by order of execution.
%    \begin{macrocode}
\seq_new:N \l_@@_info_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\hook_show:n,\hook_log:n}
% \begin{macro}{\@@_log_line:x,\@@_log_line_indent:x}
% \begin{macro}{\@@_log:nN}
%   This writes out information about the hook given in its argument
%   onto the \texttt{.log} file and the terminal, if \cs{show_hook:n} is
%   used.  Internally both share the same structure, except that at the
%   end, \cs{hook_show:n} triggers \TeX's prompt.
%    \begin{macrocode}
\cs_new_protected:Npn \hook_log:n #1
  {
    \cs_set_eq:NN \@@_log_cmd:x \iow_log:x
    \@@_normalize_hook_args:Nn \@@_log:nN {#1} \tl_log:x
  }
\cs_new_protected:Npn \hook_show:n #1
  {
    \cs_set_eq:NN \@@_log_cmd:x \iow_term:x
    \@@_normalize_hook_args:Nn \@@_log:nN {#1} \tl_show:x
  }
\cs_new_protected:Npn \@@_log_line:x #1
  { \@@_log_cmd:x { >~#1 } }
\cs_new_protected:Npn \@@_log_line_indent:x #1
  { \@@_log_cmd:x { >~\space\space #1 } }
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_log:nN}
%<latexrelease>                 {Hooks~with~args}
\tl_new:N \l_@@_print_tl
\cs_new_protected:Npn \@@_log:nN #1 #2
  {
    \@@_if_deprecated_generic:nT { #1 }
      {
        \@@_deprecated_generic_warn:n { #1 }
        \@@_do_deprecated_generic:Nn \@@_log:nN { #1 } #2
        \use_none:nnnnnnnnn
      }
    \@@_preamble_hook:n { #1 }
    \@@_log_cmd:x { ^^J ==>~Hook:~'#1' }
    \use:n
      {
        \seq_clear:N \l_@@_info_seq
        \@@_if_generic:nT { #1 }
          {
            \seq_put_right:Nn \l_@@_info_seq { builtin~generic }
            \use_none:nnn
          }
        \@@_if_usable:nF { #1 }
          { \seq_put_right:Nx \l_@@_info_seq { not~declared } }
        \@@_if_reversed:nT { #1 }
          { \seq_put_right:Nx \l_@@_info_seq { reversed } }
        \@@_if_disabled:nF { #1 }
          {
            \exp_args:Nf \int_compare:nNnT
              { \str_count:e { \@@_parameter:n { #1 } } } > 2
              {
                \seq_put_right:Nx \l_@@_info_seq
                  {
                    \@@_print_args:nn { #1 }
                      {
                        \int_eval:n
                          { \str_count:e { \@@_parameter:n { #1 } } / 3 }
                      }
                  }
              }
              \use_none:nnn
          }
        \seq_put_right:Nn \l_@@_info_seq { disabled }
        \hook_if_empty:nT { #1 }
          {
            \seq_if_empty:NT \l_@@_info_seq
              { \seq_put_right:Nn \l_@@_info_seq { empty } }
            #2 { ~ \space \seq_use:Nn \l_@@_info_seq { ,~ } }
            \use_none:nnnnnn
          }
        \seq_if_empty:NF \l_@@_info_seq
          {
            \@@_log_line_indent:x { \seq_use:Nn \l_@@_info_seq { ,~ } }
          }
      }
%    \end{macrocode}
% |#2| will be used when displaying the last executed code label.
%    \begin{macrocode}
    \hook_if_empty:nF { #1 }
      {
        \@@_log_line:x { Code~chunks: }
        \prop_if_empty:cF { g_@@_#1_code_prop }
          {
            \prop_map_inline:cn { g_@@_#1_code_prop }
              {
                \exp_after:wN \cs_set:Npn \exp_after:wN \@@_info_log_nN:w
                  \c_@@_nine_parameters_tl { ##2 }
                \@@_log_line_indent:x
                  { '##1' ~->~\cs_replacement_spec:N \@@_info_log_nN:w }
              }
          }
        \@@_cs_if_empty:cF { @@_toplevel~#1 }
          {
            \@@_log_line_indent:x
              { 'top-level' ~->~ \cs_replacement_spec:c { @@_toplevel~#1 } }
          }
        \@@_cs_if_empty:cF { @@_next~#1 }
          {
            \@@_log_line_indent:x
              {
                next-only ~->~ \exp_last_unbraced:Nf \@@_log_next_code:w
                  { \cs_replacement_spec:c { @@_next~#1 } }
              }
          }
%    \end{macrocode}
%   Loop through the default rules in a hook and for every rule found, print it.
%   The boolean \cs{l_@@_tmpa_bool} here indicates if the hook has no default rules.
%    \begin{macrocode}
        \cs_set:Npn \@@_info_log:nN:nw ##1 ##2 | ##3 \scan_stop:
          {
            \l_@@_print_tl
            \tl_clear:N \l_@@_print_tl
            \str_case:nnF { ##1 }
              {
                { xE } {
                         \cs_set:cpn { @@.xE.##2 } {}
                         \cs_set:cpn { @@.xE.##3 } {}
                         \@@_log_line_indent:x
                           { '##2'~incompatible-error~'##3' } }
                { xW } {
                         \cs_set:cpn { @@.xW.##2 } {}
                         \cs_set:cpn { @@.xW.##3 } {}
                         \@@_log_line_indent:x
                           { '##2'~incompatible-warning~'##3' } }
                { <  } { \@@_log_line_indent:x { '##2'~before~'##3' } }
                { <- } { \@@_log_line_indent:x { '##2'~voids~ '##3' } }
                {  > } { \@@_log_line_indent:x { '##2'~after~ '##3' } }
                { -> } { \@@_log_line_indent:x { '##3'~voids~ '##2' } }
              }
              { \@@_log_line_indent:x { '##2'~UNKNOWN(##1)~ '##3' } }
          }
        \tl_set:Nn \l_@@_print_tl
          {
            \@@_log_line:x
              {
                Default~rules
                \@@_if_reversed:nT { #1 } { ,~to~be~mirrored }:
              }
          }
        \@@_list_rules:nn {#1}
          {
            \str_if_eq:nnT { ##3 } { ?? }
              { \@@_info_log:nN:nw { ##1 } ##2 \scan_stop: }
          }
%    \end{macrocode}
%   Loop through the rules in a hook and for every non default rule found, print
%   it. The boolean \cs{l_@@_tmpa_bool} here indicates if the hook only has 
%   default rules.
%    \begin{macrocode}
        \tl_set:Nn \l_@@_print_tl
          { \@@_log_line:x { Rules: } }
        \@@_list_rules:nn { #1 }
          {
            \str_if_eq:nnF { ##3 } { ?? }
              { \@@_info_log:nN:nw { ##1 } ##2 \scan_stop: }
          }
%    \end{macrocode}
%   When the hook is declared (that is, the sorting algorithm is applied
%   to that hook)
%    \begin{macrocode}
        \@@_if_usable:nT { #1 }
          {
            \@@_log_line:x { Execution~order: }
            \seq_clear:N \l_@@_info_seq
            \@@_if_reversed:nT { #1 }
              {
                \@@_cs_if_empty:cF { @@_toplevel~#1 }
                  { \seq_put_right:Nn \l_@@_info_seq { 'top-level' } }
              }
            \clist_if_empty:cF { g_@@_#1_labels_clist }
              {
                \clist_map_inline:cn { g_@@_#1_labels_clist }
                  {
%    \end{macrocode}
% Mark with \enquote{\texttt{Error}} the labels that should not be there
% due to an \texttt{incompatible-error} rule.
% Mark with \enquote{\texttt{Warning}} the other labels involved in an
% \texttt{incompatible-warning} rule.
%    \begin{macrocode}
                    \cs_if_exist:cT { @@.xE.##1 }
                      {
                        \seq_put_right:Nn \l_@@_info_seq { '##1'~(Error) }
                        \cs_undefine:c { @@.xE.##1 }
                        \cs_undefine:c { @@.xW.##1 }
                        \use_none:nnnnnn
                      }
                    \cs_if_exist:cT { @@.xW.##1 }
                      {
                        \seq_put_right:Nn \l_@@_info_seq { '##1'~(Warning) }
                        \cs_undefine:c { @@.xW.##1 }
                        \use_none:nnn
                      }
                    \seq_put_right:Nn \l_@@_info_seq { '##1' }
                  }
              }
            \@@_if_reversed:nF { #1 }
              {
                \@@_cs_if_empty:cF { @@_toplevel~#1 }
                  { \seq_put_right:Nn \l_@@_info_seq { 'top-level' } }
              }
            \@@_cs_if_empty:cT { @@_next~#1 }
              {
                \seq_pop_right:NN \l_@@_info_seq \l_@@_print_tl
                \use_none:nnn
              }
              \tl_set:Nn \l_@@_print_tl { next-only }
            \seq_map_indexed_inline:Nn \l_@@_info_seq
              { \@@_log_line_indent:x { ##1:~##2 } }
            #2
              {
                \space\space
                \int_eval:n { \seq_count:N \l_@@_info_seq + 1 }
                :~
                \l_@@_print_tl
              }
            \use_none:nn
          }
        #2 { No~execution }
      }
  }
%<latexrelease>\EndIncludeInRelease
%
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_log:nN}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_log:nN #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_deprecated_generic:nT {#1}
%<latexrelease>      {
%<latexrelease>        \@@_deprecated_generic_warn:n {#1}
%<latexrelease>        \@@_do_deprecated_generic:Nn \@@_log:nN {#1} #2
%<latexrelease>        \exp_after:wN \use_none:nnnnnnnnn \use_none:nnnnn
%<latexrelease>      }
%<latexrelease>    \@@_preamble_hook:n {#1}
%<latexrelease>    \@@_log_cmd:x
%<latexrelease>      { ^^J ->~The~ \@@_if_generic:nT {#1} { generic~ } hook~'#1': }
%<latexrelease>    \@@_if_usable:nF {#1}
%<latexrelease>      { \@@_log_line:x { The~hook~is~not~declared. } }
%<latexrelease>    \@@_if_disabled:nT {#1}
%<latexrelease>      { \@@_log_line:x { The~hook~is~disabled. } }
%<latexrelease>    \hook_if_empty:nTF {#1}
%<latexrelease>      { #2 { The~hook~is~empty } }
%<latexrelease>      {
%<latexrelease>        \@@_log_line:x { Code~chunks: }
%<latexrelease>        \prop_if_empty:cTF { g_@@_#1_code_prop }
%<latexrelease>          { \@@_log_line_indent:x { --- } }
%<latexrelease>          {
%<latexrelease>            \prop_map_inline:cn { g_@@_#1_code_prop }
%<latexrelease>              { \@@_log_line_indent:x { ##1~->~\tl_to_str:n {##2} } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x
%<latexrelease>          {
%<latexrelease>            Document-level~(top-level)~code
%<latexrelease>            \@@_if_usable:nT {#1}
%<latexrelease>              { ~(executed~\@@_if_reversed:nTF {#1} {first} {last} ) } :
%<latexrelease>          }
%<latexrelease>        \@@_log_line_indent:x
%<latexrelease>          {
%<latexrelease>            \tl_if_empty:cTF { @@_toplevel~#1 }
%<latexrelease>              { --- }
%<latexrelease>              { -> ~ \exp_args:Nv \tl_to_str:n { @@_toplevel~#1 } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x { Extra~code~for~next~invocation: }
%<latexrelease>        \@@_log_line_indent:x
%<latexrelease>          {
%<latexrelease>            \tl_if_empty:cTF { @@_next~#1 }
%<latexrelease>              { --- }
%<latexrelease>              { ->~ \exp_args:Nv \@@_log_next_code:n { @@_next~#1 } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x { Rules: }
%<latexrelease>        \bool_set_true:N \l_@@_tmpa_bool
%<latexrelease>        \@@_list_rules:nn {#1}
%<latexrelease>          {
%<latexrelease>            \bool_set_false:N \l_@@_tmpa_bool
%<latexrelease>            \@@_log_line_indent:x
%<latexrelease>              {
%<latexrelease>                ##2~ with~
%<latexrelease>                \str_if_eq:nnT {##3} {??} { default~ }
%<latexrelease>                relation~ ##1
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>        \bool_if:NT \l_@@_tmpa_bool
%<latexrelease>          { \@@_log_line_indent:x { --- } }
%<latexrelease>        \bool_lazy_and:nnTF
%<latexrelease>            { \@@_if_usable_p:n {#1} }
%<latexrelease>            { ! \hook_if_empty_p:n {#1} }
%<latexrelease>          {
%<latexrelease>            \@@_log_line:x
%<latexrelease>              {
%<latexrelease>                Execution~order
%<latexrelease>                \bool_if:NTF \l_@@_tmpa_bool
%<latexrelease>                  { \@@_if_reversed:nT {#1} { ~(after~reversal) } }
%<latexrelease>                  { ~(after~
%<latexrelease>                    \@@_if_reversed:nT {#1} { reversal~and~ }
%<latexrelease>                    applying~rules)
%<latexrelease>                  } :
%<latexrelease>              }
%<latexrelease>            #2 % \tl_show:n
%<latexrelease>              {
%<latexrelease>                \@spaces
%<latexrelease>                \clist_if_empty:cTF { g_@@_#1_labels_clist }
%<latexrelease>                  { --- }
%<latexrelease>                  { \clist_use:cn { g_@@_#1_labels_clist } { ,~ } }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_log_line:x { Execution~order: }
%<latexrelease>            #2
%<latexrelease>              {
%<latexrelease>                \@spaces Not~set~because~the~hook~ \@@_if_usable:nTF {#1}
%<latexrelease>                  { code~pool~is~empty }
%<latexrelease>                  { is~\@@_if_disabled:nTF {#1} {disabled} {undeclared} }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
% \begin{macro}{\@@_log_next_code:n}
%    To display the code for next invocation only (i.e., from
%    \cs{AddToHookNext} we have to remove the string
%    \cs{@@_clear_next:n}\Arg{hook}, so the simplest is to use a macro
%    delimited by a \verb|}|$_12$.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_log_next_code:n}
%<latexrelease>                 {Hooks~with~args}
\exp_last_unbraced:NNNNo
\cs_new:Npn \@@_log_next_code:w #1 \c_right_brace_str { }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_log_next_code:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset:Npn \@@_log_next_code:n #1
%<latexrelease>  { \exp_args:No \tl_to_str:n { \use_none:nn #1 } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_print_args:nn}
%    Pretty-prints the number of arguments of a hook.
%    |#1| is a hook name, |#2| expands to a number.
%    \begin{macrocode}
\cs_new:Npn \@@_print_args:nn #1 #2
  {
    \int_compare:nNnT { #2 } > { 0 }
      {
        \@@_if_declared:nF { #1 } { \use_none:nn }
        \use:n { #2 ~ argument \int_compare:nNnT { #2 } > { 1 } { s } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_list_rules:nn}
% \begin{macro}{\@@_list_one_rule:nnn,\@@_list_if_rule_exists:nnnF}
%   This macro takes a \meta{hook} and an \meta{inline function} and
%   loops through each pair of labels in the hook, and if
%   there is a relation between this pair of labels, the
%   \meta{inline function} is executed with |#1|${}={}$\meta{relation},
%   |#2|${}={}$\meta{label_1}\verb=|=\meta{label_2},
%   and |#3|${}={}$\meta{hook} (the latter may be the argument |#1| to
%   \cs{@@_list_rules:nn}, or \texttt{??} if it is a default rule).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_list_rules:nn #1 #2
  {
    \cs_set_protected:Npn \@@_tmp:w ##1 ##2 ##3 {#2}
    \prop_map_inline:cn { g_@@_#1_code_prop }
      {
        \prop_map_inline:cn { g_@@_#1_code_prop }
          {
            \@@_if_label_case:nnnnn {##1} {####1}
              { \prop_map_break: }
              { \@@_list_one_rule:nnn {##1} {####1} }
              { \@@_list_one_rule:nnn {####1} {##1} }
                  {#1}
          }
      }
  }
%    \end{macrocode}
%
%   These two are quite similar to \cs{@@_apply_label_pair:nnn} and
%   \cs{@@_label_if_exist_apply:nnnF}, respectively, but rather than
%   applying the rule, they pass it to the \meta{inline function}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_list_one_rule:nnn #1#2#3
  {
    \@@_list_if_rule_exists:nnnF {#1} {#2} {#3}
      { \@@_list_if_rule_exists:nnnF {#1} {#2} { ?? } { } }
  }
\cs_new_protected:Npn \@@_list_if_rule_exists:nnnF #1#2#3
  {
    \if_cs_exist:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end:
      \exp_args:Nv \@@_tmp:w
        { g_@@_ #3 _rule_ #1 | #2 _tl } { #1 | #2 } {#3}
      \exp_after:wN \use_none:nn
    \fi:
    \use:n
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DebugPrintHook}
%   Print detailed hook information.
%    \begin{macrocode}
\cs_new_protected:Npn \DebugPrintHook #1
  {
    \tl_set:Ne \l_@@_print_tl { #1 }
    \@@_normalize_hook_args:Nn \@@_debug_print:n { #1 }
  }
\cs_new_protected:Npn \@@_debug_print:n #1
  {
    \@@_preamble_hook:n { #1 }
    \exp_args:NV \str_if_eq:nnF \l_@@_print_tl { #1 }
      {
        \iow_term:x { <<<~Hook:~'#1'(<- ~ '\l_@@_print_tl') }
        \use_none:nn
      }
    \iow_term:n { <<<~Hook:~'#1' }
    \iow_term:n { ...~Attributes: }
    \cs_set:Npn \@@_tmp:w ##1
      {
        \iow_term:x
          {
            ...~\space\space##1:~
            \cs_if_exist_use:cF { @@_if_##1:nT }
              { \use:c { hook_if_##1:nT } }
              { #1 } { Y \use_none:n } N
          }
      }
    \@@_tmp:w { deprecated_generic }
    \@@_tmp:w { generic }
    \@@_tmp:w { declared }
    \@@_tmp:w { structure_exist }
    \@@_tmp:w { usable }
    \@@_tmp:w { disabled }
    \@@_tmp:w { empty }
    \@@_tmp:w { reversed }
    \@@_tmp:w { generic_reversed }
    \@@_tmp:w { consumed }
%    \end{macrocode}
% Done with \cs[no-index]{@@_tmp:w}.
%    \begin{macrocode}
    \hook_if_paired:nTF { #1 }
      {
        \iow_term:x
          {
            ...~\space\space pair:~'\tl_use:c { c_@@_pair_#1_tl }'
          }
      }
      {
        \iow_term:x
          {
            ...~\space\space pair:~None
          }
      }
    \iow_term:x
      {
        ...~\space\space\c_hash_str\space of~arguments:~
        \int_eval:n { \str_count:e { \@@_parameter:n {#1} } / 3 }
      }
    \iow_term:n { ...~Code~chunks: }
    \prop_map_inline:cn { g_@@_#1_code_prop }
      {
        \exp_after:wN \cs_set:Npn \exp_after:wN \@@_debug_print:n:w
            \c_@@_nine_parameters_tl { ##2 }
        \iow_term:x
          {
            ...~\space\space
            '##1' ~->~\cs_replacement_spec:N \@@_debug_print:n:w
          }
      }
    \iow_term:x
      {
        ...~\space\space'top~level'
        \@@_cs_if_empty:cTF { @@_toplevel~#1 }
          { ~ empty }
          { ~ -> ~ \cs_replacement_spec:c { @@_toplevel~#1 } }
      }
    \iow_term:x
      {
        ...~\space\space next-only
        \@@_cs_if_empty:cTF { @@_next~#1 }
          { ~ empty }
          {
            ~ -> ~ \exp_last_unbraced:Nf \@@_log_next_code:w
              { \cs_replacement_spec:c { @@_next~#1 } }
          }
      }
    \iow_term:n { ...~Default~rules: }
    \tl_set:Nn \l_@@_print_tl { \iow_term:x { ...~\space\space None } }
    \@@_list_rules:nn {#1}
      {
        \str_if_eq:nnT {##3} {??}
        {
          \tl_set:Nn \l_@@_print_tl { ##2 }
          \tl_if_in:NnTF \l_@@_print_tl { ^^J }
            {
              \tl_replace_once:Nnn \l_@@_print_tl { ^^J } { '~##1~' }
            }
            {
              \tl_replace_once:Nnn \l_@@_print_tl { | } { '~##1~' }
            }
          \iow_term:x { ...~\space\space'\l_@@_print_tl' }
          \tl_clear:N \l_@@_print_tl
        }
    }
    \l_@@_print_tl
    \iow_term:n { ...~Rules: }
    \tl_set:Nn \l_@@_print_tl { \iow_term:x { ...~\space\space None } }
    \@@_list_rules:nn {#1}
      {
        \str_if_eq:nnF {##3} {??}
          {
            \tl_set:Nn \l_@@_print_tl { ##2 }
            \tl_if_in:NnTF \l_@@_print_tl { ^^J }
              {
                \tl_replace_once:Nnn \l_@@_print_tl { ^^J } { '~##1~' }
              }
              {
                \tl_replace_once:Nnn \l_@@_print_tl { | } { '~##1~' }
              }
            \iow_term:x { ...~\space\space'\l_@@_print_tl' }
            \tl_clear:N \l_@@_print_tl
          }
      }
    \l_@@_print_tl
    \iow_term:n { ...~Execution~order: }
    \hook_if_empty:nF { #1 }
      {
        \clist_if_exist:cT { g_@@_#1_labels_clist }
          {
            \clist_if_empty:cF
              { g_@@_#1_labels_clist }
              {
                \iow_term:x
                  {
                    ...~\space\space'
                    \clist_use:cn { g_@@_#1_labels_clist } { ',~' }'
                  }
                \use_none:n
              }
          }
      }
      { \iow_term:x { ...~\space\space None } }
    \iow_term:n { >>> }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Setting rules for mirrored hook pairs}
%
% \begin{macro}{
%   \DeclareHookPairRule,
%   \hook_pair_gset_rule:nnnn,
% }
% Test if the specified hook belongs to a mirrored hook pair
% and then executes
% \begin{lthooksCode}
% \ROW\cs{DeclareHookRule}\\
% \ROW\TAB\Arg{hook-spec}\Arg{label-spec_1}\Arg{relation}\Arg{label-spec_2}\\
% \ROW\cs{DeclareHookRule}\\
% \ROW\TAB\Arg{mirror hook-spec}\Arg{label-spec_1}\Arg{relation\LHXStar}\Arg{label-spec_2}
% \end{lthooksCode}
%    \begin{macrocode}
\cs_new_protected:Npn \hook_pair_gset_rule:nnnn #1#2#3#4
  {
    \@@_normalize_hook_rule_args:Nnnnn \@@_pair_gset_rule:nnnn
      {#1} {#2} {#3} {#4}
  }
\cs_new:Npn \@@_exp_mirror:Nn #1 #2 {
  \exp_args:Nv #1 { c_@@_pair_#2_tl }
}
\cs_new_protected:Npn \@@_pair_gset_rule:nnnn #1#2#3#4
  {
    \hook_if_paired:nTF { #1 }
      {
        \@@_gset_rule:nnnn { #1 } { #2 } { #3 } { #4 }
        \str_case:nnF { #3 }
          {
              { before }
              {
                \@@_exp_mirror:Nn
                \@@_gset_rule:nnnn { #1 } { #2 } { after } { #4 }
              }
              { < }
              {
                \@@_exp_mirror:Nn
                \@@_gset_rule:nnnn { #1 } { #2 } { > } { #4 }
              }
              { after }
              {
                \@@_exp_mirror:Nn
                \@@_gset_rule:nnnn { #1 } { #2 } { before } { #4 }
              }
              { > }
              {
                \@@_exp_mirror:Nn
                \@@_gset_rule:nnnn { #1 } { #2 } { < } { #4 }
              }
          }
          {
            \@@_exp_mirror:Nn
            \@@_gset_rule:nnnn  { #1 } { #2 } { #3 } { #4 }
          }
      }
      {
        \msg_error:nnn { hooks } { missing-pair } {#1}
      }
  }
%    \end{macrocode}
% The \LaTeXe\ API.
%    \begin{macrocode}
\cs_set_eq:NN \DeclareHookPairRule \hook_pair_gset_rule:nnnn
%    \end{macrocode}
% \end{macro}
%
%
%%  \subsection{Specifying code for next invocation}
%
% \begin{macro}{\hook_gput_next_code:nn}
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_gput_next_code_with_args:nn} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gput_next_code:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gput_next_code:nn #1 #2
  {
    \@@_replacing_args_false:
    \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} {#2}
    \@@_replacing_args_reset:
  }
\cs_new_protected:Npn \hook_gput_next_code_with_args:nn #1 #2
  {
    \@@_replacing_args_true:
    \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} {#2}
    \@@_replacing_args_reset:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gput_next_code:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_gput_next_code:nn #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} }
%<latexrelease>\cs_gset_protected:Npn \hook_gput_next_code_with_args:nn #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_gput_next_code:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_next_code:nn #1 #2
  {
    \@@_if_disabled:nTF {#1}
      { \msg_error:nnn { hooks } { hook-disabled } {#1} }
      {
        \@@_if_structure_exist:nTF {#1}
          { \@@_gput_next_do:nn }
          { \@@_try_declaring_generic_next_hook:nn }
              {#1} {#2}
      }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_gput_next_do:nn}
%   Start by sanity-checking with \cs{@@_chk_args_allowed:nn}.
%   Then check if the ``next code'' token list is empty:  if so we need
%   to add a \cs{tl_gclear:c} to clear it, so the code lasts for one
%   usage only.  The token list is cleared early so that nested usages
%   don't get lost.  \cs{tl_gclear:c} is used instead of
%   \cs{tl_gclear:N} in case the hook is used in an expansion-only
%   context, so the token list doesn't expand before \cs{tl_gclear:N}:
%   that would make an infinite loop.  Also in case the main code token
%   list is empty, the hook code has to be updated to add the next
%   execution token list.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
% \changes{v1.1c}{2023/04/19}
%         {Initialise hook structure when adding 'next' code (gh/1052).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_gput_next_do:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_gput_next_do:nn #1
  {
    \@@_init_structure:n {#1}
    \@@_chk_args_allowed:nn {#1} { AddToHookNext }
    \@@_cs_if_empty:cT { @@~#1 }
      { \@@_update_hook_code:n {#1} }
    \@@_cs_if_empty:cT { @@_next~#1 }
      { \@@_next_gset:nn {#1} { \@@_clear_next:n {#1} } }
    \@@_cs_gput_right:nnn { _next } {#1}
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_gput_next_do:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_gput_next_do:nn #1
%<latexrelease>  {
%<latexrelease>    \exp_args:Nc \@@_gput_next_do:Nnn
%<latexrelease>      { @@_next~#1 } {#1}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_gput_next_do:Nnn #1 #2
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:cT { @@~#2 }
%<latexrelease>      { \@@_update_hook_code:n {#2} }
%<latexrelease>    \tl_if_empty:NT #1
%<latexrelease>      { \@@_tl_gset:Nn #1 { \@@_clear_next:n {#2} } }
%<latexrelease>    \@@_tl_gput_right:Nn #1
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_gclear_next_code:n}
%    Discard anything set up for next invocation of the hook.
% \changes{v1.0o}{2021/07/27}{Macro made public}
%    \begin{macrocode}
\cs_new_protected:Npn \hook_gclear_next_code:n #1
  { \@@_normalize_hook_args:Nn \@@_clear_next:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_clear_next:n}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_clear_next:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_clear_next:n #1
  { \@@_next_gset:nn {#1} { } }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_clear_next:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_clear_next:n #1
%<latexrelease>  { \cs_gset_eq:cN { @@_next~#1 } \c_empty_tl }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Using the hook}
%
% \begin{macro}{\hook_use:n}
% \begin{macro}[EXP]{\@@_use_initialized:n}
% \begin{macro}{\@@_preamble_hook:n}
%   \cs{hook_use:n} as defined here is used in the preamble, where
%   hooks aren't initialized by default.  \cs{@@_use_initialized:n} is
%   also defined, which is the non-\tn{protected} version for use within
%   the document.  Their definition is identical, except for the
%   \cs{@@_preamble_hook:n} (which wouldn't hurt in the expandable
%   version, but it would be an unnecessary extra expansion).
%
%   \cs{@@_use_initialized:n} holds the expandable definition while in
%   the preamble. \cs{@@_preamble_hook:n} initializes the hook in the
%   preamble, and is redefined to \cs{use_none:n} at |\begin{document}|.
%
%   Both versions do the same thing internally: they check that the hook exists as
%   given, and if so they use it as quickly as possible.
%
%   At |\begin{document}|, all hooks are initialized, and any change in
%   them causes an update, so \cs{hook_use:n} can be made expandable.
%   This one is better not protected so that it can expand into nothing
%   if containing no code. Also important in case of generic hooks that
%   we do not generate a \cs[no-index]{relax} as a side effect of
%   checking for a csname. In contrast to the \TeX{} low-level
%   \verb=\csname ...\endcsname= construct \cs{tl_if_exist:c} is
%   careful to avoid this.
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use:n #1
  {
    \@@_preamble_hook:n {#1}
    \@@_use_initialized:n {#1}
  }
\cs_new:Npn \@@_use_initialized:n #1
  {
    \if_cs_exist:w @@~#1 \cs_end:
      \cs:w @@~#1 \use_i:nn
    \fi:
    \use_none:n
    \cs_end:
  }
\cs_new_protected:Npn \@@_preamble_hook:n #1
  {
    \if_cs_exist:w @@~#1 \cs_end:
      \@@_initialize_hook_code:n {#1}
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\hook_use:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \hook_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_initialized:n #1
%<latexrelease>  {
%<latexrelease>    \if_cs_exist:w @@~#1 \cs_end:
%<latexrelease>      \cs:w @@~#1 \exp_after:wN \cs_end:
%<latexrelease>    \fi:
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_preamble_hook:n #1
%<latexrelease>  { \@@_initialize_hook_code:n {#1} }
%<latexrelease>\cs_new:Npn \hook_use:nnw #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \hook_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cTF { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>      { \@@_use:wn #1 / \s_@@_mark {#1} }
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_initialized:n #1
%<latexrelease>  {
%<latexrelease>    \if_cs_exist:w @@~#1 \cs_end:
%<latexrelease>    \else:
%<latexrelease>      \@@_use_undefined:w
%<latexrelease>    \fi:
%<latexrelease>    \cs:w @@~#1 \@@_use_end:
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_undefined:w #1 #2 @@~#3 \@@_use_end:
%<latexrelease>  {
%<latexrelease>    #1 % fi
%<latexrelease>    \@@_use:wn #3 / \s_@@_mark {#3}
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_preamble_hook:n #1
%<latexrelease>  { \@@_initialize_hook_code:n {#1} }
%<latexrelease>\cs_new_eq:NN \@@_use_end: \cs_end:
%<latexrelease>\cs_new:Npn \hook_use:nnw #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\hook_use:nnw}
% \begin{macro}[EXP]{\@@_use_initialized:nnw}
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_use:nnw} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use:nnw}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use:nnw #1
  {
    \@@_preamble_hook:n {#1}
    \@@_use_initialized:nnw {#1}
  }
\cs_new:Npn \@@_use_initialized:nnw #1 #2
  {
    \cs:w
      \if_cs_exist:w @@~#1 \cs_end:
        @@~#1
      \else:
        use_none: \prg_replicate:nn {#2} { n }
      \fi:
    \cs_end:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use:nnw}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset:Npn \hook_use:nnw #1 #2
%<latexrelease>  { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\@@_post_initialization_defs:}
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_post_initialization_defs:}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_post_initialization_defs:
  {
    \cs_gset_eq:NN \hook_use:n \@@_use_initialized:n
    \cs_gset_eq:NN \hook_use:nnw \@@_use_initialized:nnw
    \cs_gset_eq:NN \@@_preamble_hook:n \use_none:n
    \cs_gset_eq:NN \@@_post_initialization_defs: \prg_do_nothing:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_post_initialization_defs:}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_post_initialization_defs:
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[EXP]{\@@_use:wn}
% \begin{macro}{\@@_try_file_hook:n,\@@_if_usable_use:n}
%   \cs{@@_use:wn} does a quick check to test if the current hook is a
%   file hook: those need a special treatment.  If it is not, the hook
%   does not exist.  If it is, then \cs{@@_try_file_hook:n} is called,
%   and checks that the current hook is a file-specific hook using
%   \cs{@@_if_file_hook:wTF}.  If it's not, then it's a generic |file/|
%   hook and is used if it exist.
%
%   If it is a file-specific hook, it passes through the same
%   normalization as during declaration, and then it is used if defined.
%   \cs{@@_if_usable_use:n} checks if the hook exist, and calls
%   \cs{@@_preamble_hook:n} if so, then uses the hook.
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_use:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new:Npn \@@_use:wn #1 / #2 \s_@@_mark #3
%<latexrelease>  {
%<latexrelease>    \str_if_eq:nnTF {#1} { file }
%<latexrelease>      { \@@_try_file_hook:n {#3} }
%<latexrelease>      { } % Hook doesn't exist
%<latexrelease>  }
%    \end{macrocode}
%
% \changes{v1.0s}{2021/09/28}
%                {Correct usage of older \cs{@@_if_file_hook:wTF} (gh/675)}
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_file_hook:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_file_hook:wTF #1 / \s_@@_mark
%<latexrelease>      {
%<latexrelease>        \exp_args:Ne \@@_if_usable_use:n
%<latexrelease>          { \exp_args:Ne \@@_file_hook_normalize:n {#1} }
%<latexrelease>      }
%<latexrelease>      { \@@_if_usable_use:n {#1} } % file/ generic hook (e.g. file/before)
%<latexrelease>  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_if_usable_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hook_use_once:n,\hook_use_once:nnw}
%   For hooks that can and should be used only once we have a special
%   use command that further inhibits the hook from getting more code
%   added to it.  This has the effect that any
%   further code added to the hook is executed immediately rather
%   than stored in the hook.
%
%   The code needs some gymnastics to prevent space trimming from the
%   hook name, since \cs{hook_use:n} and \cs{hook_use_once:n} are
%   documented to not trim spaces.
%
% \changes{v1.0r}{2021/09/06}{Clean up after \cs{UseOneTimeHook} (gh/606)}
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{hook_use_once:nnw} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use_once:nnw}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use_once:n #1
  {
    \@@_if_execute_immediately:nF {#1}
      { \@@_normalize_hook_args:Nn \@@_use_once:nn { \use:n {#1} } { 0 } }
  }
\cs_new_protected:Npn \hook_use_once:nnw #1 #2
  {
    \@@_if_execute_immediately:nF {#1}
      { \@@_normalize_hook_args:Nn \@@_use_once:nn { \use:n {#1} } {#2} }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use_once:nnw}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_use_once:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_execute_immediately:nF {#1}
%<latexrelease>      { \@@_normalize_hook_args:Nn \@@_use_once:n { \use:n {#1} } }
%<latexrelease>  }
%<latexrelease>\cs_gset:Npn \hook_use_once:nnw #1 #2
%<latexrelease>  { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
% \begin{macro}{\@@_use_once:nn}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_use_once:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_use_once:nn #1 #2
  {
    \@@_preamble_hook:n {#1}
    \@@_use_once_set:n {#1}
%    \end{macrocode}
%   When a hook has arguments, the call to \cs{@@_use_initialized:n},
%   should be the very last thing to happen, otherwise the arguments
%   grabbed will be wrong.  So, to clean up after the hook we need to
%   cheat a bit and sneak the cleanup code at the end of the hook,
%   along with the next execution code.
%    \begin{macrocode}
    \@@_replacing_args_false:
    \@@_cs_gput_right:nnn { _next } {#1} { \@@_use_once_clear:n {#1} }
    \@@_replacing_args_reset:
    \@@_if_usable:nTF {#1}
      { \@@_use_initialized:n {#1} }
      {
        \int_compare:nNnT {#2} > { 0 }
          { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
      }
  }
%<latexrelease>\EndIncludeInRelease
%
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use_once:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_use_once:n #1
%<latexrelease>  {
%<latexrelease>    \@@_preamble_hook:n {#1}
%<latexrelease>    \@@_use_once_set:n {#1}
%<latexrelease>    \@@_use_initialized:n {#1}
%<latexrelease>    \@@_use_once_clear:n {#1}
%<latexrelease>  }
%<latexrelease>\cs_undefine:N \@@_use_once:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_use_once_set:n}
% \begin{macro}{\@@_use_once_clear:n}
%   \cs{@@_use_once_set:n} is used before the actual hook code is
%   executed so that any usage of \cs{AddToHook} inside the hook causes
%   the code to execute immediately.
%   \cs[no-index]{\hook_if_paired:nT} has the side effect of caching
%   the |paired| attribute, that initially depends on the value of
%   \cs[no-index]{g_@@_\meta{hook}_reversed_tl}.
%   Setting
%   \cs[no-index]{g_@@_\meta{hook}_reversed_tl} to |I| prevents further
%   code from being added to the hook.  \cs{@@_use_once_clear:n} then
%   clears the hook so that any further call to \cs{hook_use:n} or
%   \cs{hook_use_once:n} will expand to nothing.
% \changes{v1.0r}{2021/09/06}{Clean up after \cs{UseOneTimeHook} (gh/606)}
% \changes{v1.0u}{2022/05/13}{Check if prop exists to avoid l3debug error}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_use_once_clear:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_use_once_set:n #1
  {
    \hook_if_paired:nT { #1 } {}
    \@@_tl_gset:cn { g_@@_#1_reversed_tl } { I }
  }
\cs_new_protected:Npn \@@_use_once_clear:n #1
  {
    \@@_code_gset:nn {#1} { }
    \@@_next_gset:nn {#1} { }
    \@@_toplevel_gset:nn {#1} { }
    \prop_gclear_new:c { g_@@_#1_code_prop }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use_once_clear:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_use_once_clear:n #1
%<latexrelease>  {
%<latexrelease>    \@@_tl_gclear:c { @@~#1 }
%<latexrelease>    \@@_tl_gclear:c { @@_next~#1 }
%<latexrelease>    \@@_tl_gclear:c { @@_toplevel~#1 }
%<latexrelease>    \prop_gclear_new:c { g_@@_#1_code_prop }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_if_execute_immediately:n}
%   To check whether the code being added should be executed immediately
%   (that is, if the hook is a one-time hook), we check if
%   \cs[no-index]{g_@@_\meta{hook}_reversed_tl} is |I|.  The gymnastics
%   around \cs{if:w} is there to allow the |reversed| token list to be
%   empty.
% \changes{v1.0r}{2021/09/06}{Macro added (gh/606)}
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_execute_immediately:n #1 { T, F, TF }
  {
    \exp_after:wN \@@_use_none_delimit_by_s_mark:w
    \if:w I
        \if_cs_exist:w g_@@_#1_reversed_tl \cs_end:
          \cs:w g_@@_#1_reversed_tl \exp_after:wN \cs_end:
        \fi:
        X
      \s_@@_mark \prg_return_true:
    \else:
      \s_@@_mark \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Querying a hook}
%
% Simpler data types, like token lists, have three possible states; they
% can exist and be empty, exist and be non-empty, and they may not
% exist, in which case emptiness doesn't apply (though
% \cs{tl_if_empty:N} returns false in this case).
%
% Hooks are a bit more complicated: they have several other states as
%    discussed in \ref{sec:existence}.
% A hook may exist or not, and either way it may or may not be empty
% (even a hook that doesn't exist may be non-empty) or may be disabled.
%
% A hook is said to be empty when no code was added to it, either to
% its permanent code pool, or to its ``next'' token list.  The hook
% doesn't need to be declared to have code added to its code pool
% (it may happen that a package $A$ defines a hook \hook{foo}, but
% it's loaded after package $B$, which adds some code to that hook.
% In this case it is important that the code added by package $B$ is
% remembered until package $A$ is loaded).
%
%    All other states can only be queried with internal tests as the
%    different states are irrelevant for package code.
%
% \begin{macro}[pTF]{\hook_if_empty:n}
%   Test if a hook is empty (that is, no code was added to that hook).
%   A \meta{hook} being empty means that all three of its
%   \cs{g_@@_\meta{hook}_code_prop}, its
%   \cs{@@_toplevel\textvisiblespace\meta{hook}} and its
%   \cs{@@_next\textvisiblespace\meta{hook}} are empty.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
% \changes{v1.1c}{2023/04/19}
%         {Simpler and faster version (gh/1052).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_if_empty:n}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \if:w
        T
        \prop_if_exist:cT { g_@@_#1_code_prop }
          { \prop_if_empty:cF { g_@@_#1_code_prop } { F } }
        \@@_cs_if_empty:cF { @@_toplevel~#1 } { F }
        \@@_cs_if_empty:cF { @@_next~#1 } { F }
        T
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_conditional:Npnn \hook_if_empty:n #1 { p , T , F , TF }
  {
    \if:w
        T
        \prop_if_exist:cT { g_@@_#1_code_prop }
          { \prop_if_empty:cF { g_@@_#1_code_prop } { F } }
        \@@_cs_if_empty:cF { @@_toplevel~#1 } { F }
        \@@_cs_if_empty:cF { @@_next~#1 } { F }
        T
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_if_empty:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\prg_new_conditional:Npnn \hook_if_empty:n #1 { p , T , F , TF }
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nTF {#1}
%<latexrelease>      {
%<latexrelease>        \bool_lazy_and:nnTF
%<latexrelease>            { \prop_if_empty_p:c { g_@@_#1_code_prop } }
%<latexrelease>            {
%<latexrelease>              \bool_lazy_and_p:nn
%<latexrelease>                { \tl_if_empty_p:c { @@_toplevel~#1 } }
%<latexrelease>                { \tl_if_empty_p:c { @@_next~#1 } }
%<latexrelease>            }
%<latexrelease>          { \prg_return_true: }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>      { \prg_return_true: }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\@@_if_usable:n}
%   A hook is usable if the
%   token list that stores the sorted code for that hook,
%   \cs[no-index]{@@\textvisiblespace\meta{hook}}, exists.  The property
%   list \cs[no-index]{g_@@_\meta{hook}_code_prop} cannot be used here
%   because often it is necessary to add code to a hook without knowing
%   if such hook was already declared, or even if it will ever be
%   (for example, in case the package that defines it isn't loaded).
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_usable:n #1 { p , T , F , TF }
  {
    \cs_if_exist:cTF { @@~#1 }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[pTF]{\hook_if_usable:n}
%    Declared or generic usable and not disabled.
%    \begin{macrocode}
\prg_new_conditional:Npnn \hook_if_usable:n #1 { p , T , F , TF }
  {
    \@@_if_disabled:nTF { #1 }
      { \prg_return_false: }
      {
        \@@_if_declared:nTF { #1 }
          { \prg_return_true: }
          { 
            \@@_if_generic:nTF { #1 }
              { \prg_return_true: }
              { \prg_return_false: }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_if_structure_exist:n}
%
%    An internal check if the hook has already its basic internal
%    structure set up with
%   \cs{@@_init_structure:n}.  This means that the hook was already used somehow
%   (a code chunk or rule was added to it), but it still wasn't declared
%   with \cs{hook_new:n}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_structure_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF { g_@@_#1_code_prop }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}[pTF]{\@@_if_declared:n}
%
%    Internal test to check if the hook was officially declared with
%    \cs{hook_new:n} or a variant.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_declared:n #1 { p, T, F, TF }
  {
    \tl_if_exist:cTF { g_@@_#1_declared_tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_reversed:n}
%   An internal conditional that checks if a hook is marked
%   as reversed, which can be false for reversed hooks.
%   For example, after a reversed hook has been
%   consumed by a `\cs{UseOneTimeHook}` command, it is no longer
%   marked as reversed. In that case, this test takes the true
%   branch before `\cs{UseOneTimeHook}` and the false branch after.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_reversed:n #1 { p , T , F , TF }
  {
    \exp_after:wN \@@_use_none_delimit_by_s_mark:w
    \if:w - \cs:w g_@@_#1_reversed_tl \cs_end:
      \s_@@_mark \prg_return_true:
    \else:
      \s_@@_mark \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_generic:n}
% \begin{macro}[pTF]{\@@_if_deprecated_generic:n}
%   An internal conditional that checks if a name belongs to a generic
%   hook.  The deprecated version needs to check if |#3| is empty to
%   avoid returning true on \hook{file/before}, for example.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_generic:n #1 { T, TF }
  { \@@_if_generic:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_generic:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist:cTF { c_@@_generic_#1/./#3_tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_new_conditional:Npnn \@@_if_deprecated_generic:n #1 { T, TF }
  { \@@_if_deprecated_generic:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_deprecated_generic:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist:cTF { c_@@_deprecated_#1/./#2_tl }
      {
        \tl_if_empty:nTF {#3}
          { \prg_return_false: }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_cmd_hook:n}
% \begin{macro}[pTF]{\@@_if_cmd_hook:w}
%   An internal conditional that checks if a given hook is a valid
%   generic \hook{cmd} hook.
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_if_cmd_hook:n}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \@@_if_cmd_hook:n #1 { T }
  { \@@_if_cmd_hook:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_cmd_hook:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \if:w Y
          \str_if_eq:nnF {#1} { cmd } { N }
          \tl_if_exist:cF { c_@@_generic_#1/./#3_tl } { N }
          Y
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_if_cmd_hook:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_if_cmd_hook:nT
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_generic_reversed:n}
%   An internal conditional that checks if a name belongs to a generic
%   reversed hook.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_generic_reversed:n #1 { T, TF }
  { \@@_if_generic_reversed:w #1 / / / \scan_stop: }
\cs_new:Npn \@@_if_generic_reversed:w #1 / #2 / #3 / #4 \scan_stop:
  {
    \if_charcode:w - \cs:w c_@@_generic_#1/./#3_tl \cs_end:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_if_replacing_args:TF}
% \begin{macro}[EXP]{\@@_misused_if_replacing_args:nn}
% \begin{macro}{\@@_replacing_args_true:}
% \begin{macro}{\@@_replacing_args_false:}
% \begin{macro}{\@@_replacing_args_reset:}
% \begin{macro}{\g_@@_replacing_stack_seq}
%   An internal conditional that checks if the code being added to the
%   hook contains arguments.
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
\seq_new:N \g_@@_replacing_stack_seq
\cs_new:Npn \@@_misused_if_replacing_args:nn #1 #2
  {
    \msg_expandable_error:nnn { latex2e } { should-not-happen }
      { Misused~\@@_if_replacing_args:. }
  }
\cs_new:Npn \@@_if_replacing_args:TF
  { \@@_misused_if_replacing_args:nn }
\cs_new_protected:Npn \@@_replacing_args_true:
  {
    \seq_gpush:No \g_@@_replacing_stack_seq
      { \@@_if_replacing_args:TF }
    \cs_set:Npn \@@_if_replacing_args:TF { \use_i:nn }
  }
\cs_new_protected:Npn \@@_replacing_args_false:
  {
    \seq_gpush:No \g_@@_replacing_stack_seq
      { \@@_if_replacing_args:TF }
    \cs_set:Npn \@@_if_replacing_args:TF { \use_ii:nn }
  }
\cs_new_protected:Npn \@@_replacing_args_reset:
  {
    \seq_gpop:NN \g_@@_replacing_stack_seq \l_@@_return_tl
    \cs_gset_eq:NN \@@_if_replacing_args:TF \l_@@_return_tl
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}[pTF]{
%   \hook_if_consumed:n,
% }
% Partially redundant with \cs[no-index]{@@_execute_immediately:nTF}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \hook_if_consumed:n #1 { p, T, F, TF }
  {
    \exp_after:wN \@@_use_none_delimit_by_s_mark:w
    \if:w I
        \if_cs_exist:w g_@@_#1_reversed_tl \cs_end:
          \cs:w g_@@_#1_reversed_tl \exp_after:wN \cs_end:
        \fi:
        X
      \s_@@_mark \prg_return_true:
    \else:
      \s_@@_mark \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \IfHookConsumedTF,
% }
% \LaTeXe\ API.
%    \begin{macrocode}
\cs_set_eq:NN \IfHookConsumedTF \hook_if_consumed:nTF  
%    \end{macrocode}
% \end{macro}
%
%
%  \subsection{Messages}
%
%    Hook errors are LaTeX kernel errors:
%    \begin{macrocode}
\prop_gput:Nnn \g_msg_module_type_prop { hooks } { LaTeX }
%    \end{macrocode}
% \changes{v1.0q}{2021/08/27}{Internal message name changes}
%    And so are kernel errors (this should move elsewhere eventually).
%    \begin{macrocode}
\prop_gput:Nnn \g_msg_module_type_prop { latex2e } { LaTeX }
\prop_gput:Nnn \g_msg_module_name_prop { latex2e } { kernel }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { labels-incompatible }
  {
    Labels~'#1'~and~'#2'~are~incompatible
    \str_if_eq:nnF {#3} {??} { ~in~hook~'#3' } .~
    \int_compare:nNnTF {#4} = { 1 }
      { The~ code~ for~ both~ labels~ will~ be~ dropped. }
      { You~ may~ see~ errors~ later. }
  }
  { LaTeX~found~two~incompatible~labels~in~the~same~hook.~
    This~indicates~an~incompatibility~between~packages.  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { exists }
    { Hook~'#1'~ has~ already~ been~ declared. }
    { There~ already~ exists~ a~ hook~ declaration~ with~ this~
      name.\\
      Please~ use~ a~ different~ name~ for~ your~ hook.}
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{too-many-args}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}
%         {Messages 'too-many-args', 'without-args' and 'one-time-args' added (hook-args).}
%    \begin{macrocode}
\msg_new:nnnn { hooks } { too-many-args }
  { Too~many~arguments~for~hook~'#1'. }
  {
    You~tried~to~declare~a~hook~with~#2~arguments,~but~a~
    hook~can~only~have~up~to~nine.~LaTeX~will~define~this~
    hook~with~nine~arguments.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { without-args }
  { Hook~'#1'~has~no~arguments. }
  {
    You~tried~to~use~\iow_char:N\\#2WithArguments~
    on~a~hook~that~takes~no~arguments.\\
    Check~the~usage~of~the~hook~or~use~\iow_char:N\\#2~instead.\\
    \\
    LaTeX~will~use~\iow_char:N\\#2.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { one-time-args }
  { You~can't~have~arguments~in~used~one-time~hook~'#1'. }
  {
    You~tried~to~use~\iow_char:N\\#2WithArguments~
    on~a~one-time~hook~that~has~already~been~used.~
    You~have~to~add~the~code~before~the~hook~is~used,~
    or~add~the~code~without~arguments~using~\iow_char:N\\#2~instead.\\
    \\
    LaTeX~will~use~\iow_char:N\\#2.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{too-many-args}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { hook-disabled }
  { Cannot~add~code~to~disabled~hook~'#1'. }
  {
    The~hook~'#1'~you~tried~to~add~code~to~was~previously~disabled~
    with~\iow_char:N\\hook_disable_generic:n~or~\iow_char:N\\DisableGenericHook,~so~
    it~cannot~have~code~added~to~it.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { empty-label }
  {
    Empty~code~label~\msg_line_context:.~
    Using~'\@@_currname_or_default:'~instead.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { no-default-label }
  {
    Missing~(empty)~default~label~\msg_line_context:. \\
    This~command~was~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { unknown-rule }
  {
    Unknown~ relationship~ '#3'~
    between~ labels~ '#2'~ and~ '#4'~
    \str_if_eq:nnF {#1} {??} { ~in~hook~'#1' }. ~
    Perhaps~ a~ misspelling?
  }
  {
    The~ relation~ used~ not~ known~ to~ the~ system.~ Allowed~ values~ are~
    'before'~ or~ '<',~
    'after'~ or~ '>',~
    'incompatible-warning',~
    'incompatible-error',~
    'voids'~ or~
    'unrelated'.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { rule-too-late }
  {
    Sorting~rule~for~'#1'~hook~applied~too~late.\\
    Try~setting~this~rule~earlier.
  }
  {
    You~tried~to~set~the~ordering~of~hook~'#1'~using\\
    \ \ \iow_char:N\\DeclareHookRule{#1}{#2}{#3}{#4}\\
    but~hook~'#1'~was~already~used~as~a~one-time~hook,~
    thus~sorting~is\\
    no~longer~possible.~Declare~the~rule~
    before~the~hook~is~used.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { misused-top-level }
  {
    Illegal~use~of~\iow_char:N \\AddToHook{#1}[top-level]{...}.\\
    'top-level'~is~reserved~for~the~user's~document.
  }
  {
    The~'top-level'~label~is~meant~for~user~code~only,~and~should~only~
    be~used~(sparingly)~in~the~main~document.~Use~the~default~label~
    '\@@_currname_or_default:'~for~this~\@cls@pkg,~or~another~
    suitable~label.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { missing-pair }
  { Hook~'#1'~does~not~belong~to~a~matching~hook~pair.~
    Missing~
    \iow_char:N\\NewMirroredHookPair~or~its~variant~with~arguments.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { set-top-level }
  {
    You~cannot~change~the~default~label~#1~'top-level'.~Illegal \\
    \use:nn { ~ } { ~ } \iow_char:N \\#2{#3} \\
    \msg_line_context:.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { extra-pop-label }
  {
    Extra~\iow_char:N \\PopDefaultHookLabel. \\
    This~command~will~be~ignored.
  }
\msg_new:nnn { hooks } { missing-pop-label }
  {
    Missing~\iow_char:N \\PopDefaultHookLabel. \\
    The~label~'#1'~was~pushed~but~never~popped.~Something~is~wrong.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { latex2e } { should-not-happen }
  {
    This~should~not~happen.~#1 \\
    Please~report~at~https://github.com/latex3/latex2e.
  }
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { activate-disabled }
  {
    Cannot~ activate~ hook~ '#1'~ because~ it~ is~ disabled!
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { cannot-remove }
  {
    Cannot~remove~chunk~'#2'~from~hook~'#1'~because~
    \@@_if_structure_exist:nTF {#1}
      { it~does~not~exist~in~that~hook. }
      { the~hook~does~not~exist. }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { generic-deprecated }
  {
    Generic~hook~'#1/#2/#3'~is~deprecated. \\
    Use~hook~'#1/#3/#2'~instead.
  }
%    \end{macrocode}
%
%
%  \subsection{\LaTeXe{} package interface commands}
%
%
%
%  \begin{macro}{\NewHook,\NewReversedHook,\NewMirroredHookPair}
%    Declaring new hooks \ldots
%    \begin{macrocode}
\NewDocumentCommand \NewHook             { m }
  { \hook_new:n {#1} }
\NewDocumentCommand \NewReversedHook     { m }
  { \hook_new_reversed:n {#1} }
\NewDocumentCommand \NewMirroredHookPair { mm }
  { \hook_new_pair:nn {#1}{#2} }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{
%    \NewHookWithArguments,
%    \NewReversedHookWithArguments,
%    \NewMirroredHookPairWithArguments
%  }
%    Declaring new hooks with arguments\ldots
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{NewHookWithArguments} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\NewHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \NewHookWithArguments             { mm }
  { \hook_new_with_args:nn {#1} {#2} }
\NewDocumentCommand \NewReversedHookWithArguments     { mm }
  { \hook_new_reversed_with_args:nn {#1} {#2} }
\NewDocumentCommand \NewMirroredHookPairWithArguments { mmm }
  { \hook_new_pair_with_args:nnn {#1} {#2} {#3} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\NewHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \NewHookWithArguments #1 #2 { }
%<latexrelease>\cs_new_protected:Npn \NewReversedHookWithArguments #1 #2 { }
%<latexrelease>\cs_new_protected:Npn \NewMirroredHookPairWithArguments #1 #2 #3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\ActivateGenericHook}
%<latexrelease>                 {Providing~hooks}
%    \end{macrocode}
%
%  \begin{macro}{
%    \ActivateGenericHook,
%  }
%    Enabling hooks \ldots
% \changes{v1.0m}{2021/04/29}{Add \cs{ProvideHook} etc.}
% \changes{v1.0o}{2021/08/02}{Change name}
%    \begin{macrocode}
\NewDocumentCommand \ActivateGenericHook { m }
  { \hook_activate_generic:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DisableGenericHook}
%    Disabling a generic hook.
% \changes{v1.0o}{2021/08/02}{Change name}
%    \begin{macrocode}
\NewDocumentCommand \DisableGenericHook { m }
  { \hook_disable_generic:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\ActivateGenericHook}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\def \ActivateGenericHook #1 { }
%<latexrelease>\def \DisableGenericHook #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%
% \begin{macro}{
%   \AddToHook,
%   \AddToHookWithArguments,
%   \AddToHookPair,
%   \AddToHookPairWithArguments
% }
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{AddToHookWithArguments} (hook-args).}
% \changes{v1.1?}{2024/01/01}
%         {Add \cs{AddToHookPair} and \cs{AddToHookPairWithArguments}.}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\AddToHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \AddToHook { m o +m }
  { \hook_gput_code:nnn {#1} {#2} {#3} }
\NewDocumentCommand \AddToHookPair { m o +m +m }
  { \hook_pair_gput_code:nnnn {#1} {#2} {#3} {#4} }
\NewDocumentCommand \AddToHookWithArguments { m o +m }
  { \hook_gput_code_with_args:nnn {#1} {#2} {#3} }
\NewDocumentCommand \AddToHookPairWithArguments { m o +m +m }
  { \hook_pair_gput_code_with_args:nnnn {#1} {#2} {#3} {#4} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\AddToHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \AddToHookWithArguments #1 #2 #3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\AddToHookNext,\AddToHookNextWithArguments}
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{AddToHookNextWithArguments} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\AddToHookNextWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \AddToHookNext { m +m }
  { \hook_gput_next_code:nn {#1} {#2} }
\NewDocumentCommand \AddToHookNextWithArguments { m +m }
  { \hook_gput_next_code_with_args:nn {#1} {#2} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\AddToHookNextWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \AddToHookNextWithArguments #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ClearHookNext}
% \changes{v1.0o}{2021/07/27}{Macro added}
%    \begin{macrocode}
\NewDocumentCommand \ClearHookNext { m }
  { \hook_gclear_next_code:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\RemoveFromHook,\RemoveFromHookPair}
%    \begin{macrocode}
\NewDocumentCommand \RemoveFromHook { m o }
  { \hook_gremove_code:nn {#1} {#2} }
%<latexrelease>\IncludeInRelease{2024/01/01}{\RemoveFromHookPair}
%<latexrelease>                 {Hooks~pairs}
\NewDocumentCommand \RemoveFromHookPair { m o }
  { \hook_pair_gremove_code:nn {#1} {#2} }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%   Now define a wrapper that replaces the top of the stack with the
%   argument, and updates \cs{g_@@_hook_curr_name_tl} accordingly.
%    \begin{macrocode}
\NewDocumentCommand \SetDefaultHookLabel { m }
  { \hook_current_name_set:n {#1} }
%
%   The label is only automatically updated with \cs{@onefilewithoptions}
%   (\cs{usepackage} and \cs{documentclass}), but some packages, like
%   Ti\emph{k}Z, define package-like interfaces, like
%   \cs{usetikzlibrary} that are wrappers around \cs{input}, so they
%   inherit the default label currently in force (usually |top-level|,
%   but it may change if loaded in another package).  To provide a
%   package-like behavior also for hooks in these files, we provide
%   high-level access to the default label stack.
%    \begin{macrocode}
\NewDocumentCommand \PushDefaultHookLabel { m }
  { \hook_current_name_push:n {#1} }
\NewDocumentCommand \PopDefaultHookLabel { }
  { \hook_current_name_pop: }
%    \end{macrocode}
%
%   The current label stack holds the labels for all files but the
%   current one (more or less like \cs{@currnamestack}), and the current
%   label token list, \cs{g_@@_hook_curr_name_tl}, holds the label for
%   the current file.  However \cs{@pushfilename} happens before
%   \cs{@currname} is set, so we need to look ahead to get the
%   \cs{@currname} for the label.  \pkg{expl3} also requires the current
%   file in \cs{@pushfilename}, so here we abuse
%   \cs{@expl@push@filename@aux@@@@} to do \cs{hook_current_name_push:n}.
%    \begin{macrocode}
\cs_gset_protected:Npn \@expl@push@filename@aux@@@@ #1#2#3
  {
    \hook_current_name_push:n {#3}
    \str_gset:Nx \g_file_curr_name_str {#3}
    #1 #2 {#3}
  }
%    \end{macrocode}
% Now the consistent new \LaTeXe\ API.
% \begin{macro}
%   {
%     \SetHookCurrentName,
%     \PushHookCurrentName,
%     \PopHookCurrentName,
%     \DebugHookCurrentName,
%     \hook_current_name_set:n,
%     \hook_current_name_push:n,
%     \hook_current_name_pop:n,
%   }
%    \begin{macrocode}
\NewDocumentCommand \SetHookCurrentName { m }
  { \hook_current_name_set:n {#1} }
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \PushHookCurrentName { m }
  { \hook_current_name_push:n {#1} }
%    \end{macrocode}
%    \begin{macrocode}
\NewDocumentCommand \PopHookCurrentName { }
  { \hook_current_name_pop: }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \DebugHookCurrentName
  { \g_@@_hook_curr_name_tl }
%    \end{macrocode}
%
% \end{macro}
%
%
%
%  \begin{macro}{
%    \UseHook,
%    \UseOneTimeHook,
%    \UseHookWithArguments,
%    \UseOneTimeHookWithArguments,
%  }
%    Avoid the overhead of \pkg{xparse} and its protection that we
%    don't want here (since the hook should vanish without trace if empty)!
% \changes{v1.1a}{2023/04/06}
%         {Add \cs{UseHookWithArguments} (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\UseHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \UseHook        { \hook_use:n }
\cs_new:Npn \UseOneTimeHook { \hook_use_once:n }
\cs_new:Npn \UseHookWithArguments        { \hook_use:nnw }
\cs_new:Npn \UseOneTimeHookWithArguments { \hook_use_once:nnw }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\UseHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new:Npn \UseHookWithArguments #1 #2 { }
%<latexrelease>\cs_new:Npn \UseOneTimeHookWithArguments #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
% \begin{macro}{\ShowHook,\LogHook}
%    \begin{macrocode}
\cs_new_protected:Npn \ShowHook { \hook_show:n }
\cs_new_protected:Npn \LogHook { \hook_log:n }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\DebugHooksOn,\DebugHooksOff}
%
%    \begin{macrocode}
\cs_new_protected:Npn \DebugHooksOn  { \hook_debug_on:  }
\cs_new_protected:Npn \DebugHooksOff { \hook_debug_off: }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\DeclareHookRule}
%
%    \begin{macrocode}
\NewDocumentCommand \DeclareHookRule { m m m m }
                    { \hook_gset_rule:nnnn {#1}{#2}{#3}{#4} }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DeclareDefaultHookRule}
%    This declaration is only supported before \verb=\begin{document}=.
%    \begin{macrocode}
\NewDocumentCommand \DeclareDefaultHookRule { m m m }
                    { \hook_gset_rule:nnnn {??}{#1}{#2}{#3} }
\@onlypreamble\DeclareDefaultHookRule
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ClearHookRule}
%    A special setup rule that removes an existing relation.
%    Basically {@@_rule_gclear:nnn} plus fixing the property list for debugging.
%    \fmiinline{Needs perhaps an L3 interface, or maybe it should get dropped?}
%    \begin{macrocode}
\NewDocumentCommand \ClearHookRule { m m m }
{ \hook_gset_rule:nnnn {#1}{#2}{unrelated}{#3} }
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}[EXP]{\IfHookEmptyTF}
%   Here we avoid the overhead of \pkg{xparse}, since \cs{IfHookEmptyTF}
%   is used in \cs{end} (that is, every \LaTeX{} environment).  As a
%   further optimization, use \cs{let} rather than \cs{def} to avoid one
%   expansion step.
%    \begin{macrocode}
\cs_new_eq:NN \IfHookEmptyTF \hook_if_empty:nTF
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\IfHookUsableTF}
%   Copy of \cs{hook_if_usable:nTF}.
%    \begin{macrocode}
\cs_new_eq:NN \IfHookUsableTF \hook_if_usable:nTF
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\IfGenericHookDisabledTF}
%   Copy of \cs{hook_if_generic_disabled:nTF}.
%    \begin{macrocode}
\cs_new_eq:NN \IfGenericHookDisabledTF \hook_if_generic_disabled:nTF
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,int]{\IfHookExistsTF}
%    Marked for removal and no longer documented in the doc section!
% \phoinline{\cs{IfHookExistsTF} is used in \texttt{jlreq.cls},
% \texttt{pxatbegshi.sty}, \texttt{pxeverysel.sty},
% \texttt{pxeveryshi.sty}, so the public name may be an alias of the
% internal conditional for a while.  Regardless, those packages' use for
% \cs{IfHookExistsTF} is not really correct and can be changed.}
%    \begin{macrocode}
\cs_new_eq:NN \IfHookExistsTF \@@_if_usable:nTF
%    \end{macrocode}
% \end{macro}
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{Deprecated that needs cleanup at some point}
%
% \changes{v1.0p}{2021/08/20}{Added deprecation warnings for
%                             old generic hook commands (gh/638)}
%
% \begin{macro}[int]{
%     \hook_disable:n,
%     \hook_provide:n,
%     \hook_provide_reversed:n,
%     \hook_provide_pair:nn,
%     \@@_activate_generic_reversed:n,
%     \@@_activate_generic_pair:nn,
%   }
%   Deprecated.
%    \begin{macrocode}
\cs_new_protected:Npn \hook_disable:n
  {
    \@@_deprecated_warn:nn
      { hook_disable:n }
      { hook_disable_generic:n }
    \hook_disable_generic:n
  }
\cs_new_protected:Npn \hook_provide:n
  {
    \@@_deprecated_warn:nn
      { hook_provide:n }
      { hook_activate_generic:n }
    \hook_activate_generic:n
  }
\cs_new_protected:Npn \hook_provide_reversed:n
  {
    \@@_deprecated_warn:nn
      { hook_provide_reversed:n }
      { hook_activate_generic:n }
    \@@_activate_generic_reversed:n
  }
\cs_new_protected:Npn \hook_provide_pair:nn
  {
    \@@_deprecated_warn:nn
      { hook_provide_pair:nn }
      { hook_activate_generic:n }
    \@@_activate_generic_pair:nn
  }
\cs_new_protected:Npn \@@_activate_generic_reversed:n #1
  { \@@_normalize_hook_args:Nn \@@_activate_generic:nn {#1} { - } }
\cs_new_protected:Npn \@@_activate_generic_pair:nn #1#2
  { \hook_activate_generic:n {#1} \@@_activate_generic_reversed:n {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{
%     \DisableHook,
%     \ProvideHook,
%     \ProvideReversedHook,
%     \ProvideMirroredHookPair,
%   }
%   Deprecated.
%    \begin{macrocode}
\cs_new_protected:Npn \DisableHook
  {
    \@@_deprecated_warn:nn
      { DisableHook }
      { DisableGenericHook }
    \hook_disable_generic:n
  }
\cs_new_protected:Npn \ProvideHook
  {
    \@@_deprecated_warn:nn
      { ProvideHook }
      { ActivateGenericHook }
    \hook_activate_generic:n
  }
\cs_new_protected:Npn \ProvideReversedHook
  {
    \@@_deprecated_warn:nn
      { ProvideReversedHook }
      { ActivateGenericHook }
    \@@_activate_generic_reversed:n
  }
\cs_new_protected:Npn \ProvideMirroredHookPair
  {
    \@@_deprecated_warn:nn
      { ProvideMirroredHookPair }
      { ActivateGenericHook }
    \@@_activate_generic_pair:nn
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_deprecated_warn:nn}
%   Warns about a deprecation, telling what should be used instead.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_deprecated_warn:nn #1 #2
  { \msg_warning:nnnn { hooks } { deprecated } {#1} {#2} }
\msg_new:nnn { hooks } { deprecated }
  {
    Command~\iow_char:N\\#1~is~deprecated~and~will~be~removed~in~a~
    future~release. \\ \\
    Use~\iow_char:N\\#2~instead.
  }
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \subsection{Internal commands needed elsewhere}
%
% Here we set up a few horrible (but consistent) \LaTeXe{} names to
% allow for internal commands to be used outside this module. We
% have to unset the \texttt{@\/@} since we want double ``at'' sign
% in place of double underscores.
%
%    \begin{macrocode}
%<@@=>
%    \end{macrocode}
%
%  \begin{macro}[int]{
%      \@expl@@@initialize@all@@,
%      \@expl@@@hook@curr@name@pop@@
%  }
%
% \InternalDetectionOff
%    \begin{macrocode}
\cs_new_eq:NN \@expl@@@initialize@all@@
              \__hook_initialize_all:
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_eq:NN \@expl@@@hook@curr@name@pop@@
              \hook_current_name_pop:
%    \end{macrocode}
% \InternalDetectionOn
%  \end{macro}
%
%    Rolling back here doesn't undefine the interface commands as they
%    may be used in packages without rollback functionality. So we
%    just make them do nothing which may or may not work depending on
%    the code usage.
% \changes{v1.0d}{2020/10/04}{Definition \cs{AddToHookNext} was supposed
%                             to be for \cs{AddToHook} vice versa (gh/401)}
%    \begin{macrocode}
%
%<latexrelease>\IncludeInRelease{0000/00/00}{lthooks}
%<latexrelease>                 {The~hook~management}%
%<latexrelease>
%<latexrelease>\def \NewHook#1{}
%<latexrelease>\def \NewReversedHook#1{}
%<latexrelease>\def \NewMirroredHookPair#1#2{}
%<latexrelease>
%<latexrelease>\def \DisableGenericHook #1{}
%<latexrelease>
%<latexrelease>\long\def\AddToHookNext#1#2{}
%<latexrelease>
%<latexrelease>\def\AddToHook#1{\@gobble@AddToHook@args}
%<latexrelease>\providecommand\@gobble@AddToHook@args[2][]{}
%<latexrelease>
%<latexrelease>\def\RemoveFromHook#1{\@gobble@RemoveFromHook@arg}
%<latexrelease>\providecommand\@gobble@RemoveFromHook@arg[1][]{}
%<latexrelease>
%<latexrelease>\def \UseHook        #1{}
%<latexrelease>\def \UseOneTimeHook #1{}
%<latexrelease>\def \ShowHook #1{}
%<latexrelease>\let \DebugHooksOn \@empty
%<latexrelease>\let \DebugHooksOff\@empty
%<latexrelease>
%<latexrelease>\def \DeclareHookRule #1#2#3#4{}
%<latexrelease>\def \DeclareDefaultHookRule #1#2#3{}
%<latexrelease>\def \ClearHookRule #1#2#3{}
%    \end{macrocode}
%    If the hook management is not provided we make the test for existence
%    false and the test for empty true in the hope that this is most
%    of the time reasonable. If not a package would need to guard
%    against running in an old kernel.
%    \begin{macrocode}
%<latexrelease>\long\def \IfHookExistsTF #1#2#3{#3}
%<latexrelease>\long\def \IfHookEmptyTF #1#2#3{#2}
%<latexrelease>
%<latexrelease>\EndModuleRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=hook>
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}
%         {Add dedicated rollback code to revert data structures (hook-args).}
%    \begin{macrocode}
%<latexrelease>\cs:w @@_rollback_tidying: \cs_end:
%<latexrelease>\bool_lazy_and:nnT
%<latexrelease>    { \int_compare_p:nNn { \sourceLaTeXdate } > { 20230600 } }
%<latexrelease>    { \int_compare_p:nNn { \requestedLaTeXdate } < { 20230601 } }
%<latexrelease>  {
%<latexrelease>    \cs_gset_protected:Npn \@@_rollback_tidying:
%<latexrelease>      {
%<latexrelease>        \@latex@error { Rollback~code~executed~twice }
%<latexrelease>          {
%<latexrelease>            Something~went~wrong~(unless~this~was~
%<latexrelease>            done~on~purpose~in~a~testing~environment).
%<latexrelease>          }
%<latexrelease>        \use_none:nnnn
%<latexrelease>      }
%<latexrelease>    \cs_set:Npn \@@_tmp:w #1 #2
%<latexrelease>      {
%<latexrelease>        \@@_tl_gset:cx { @@#1~#2 }
%<latexrelease>          {
%<latexrelease>            \exp_args:No \exp_not:o
%<latexrelease>              {
%<latexrelease>                \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
%<latexrelease>                  { \@@_braced_cs_parameter:n { @@#1~#2 } }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \seq_map_inline:Nn \g_@@_all_seq
%<latexrelease>      {
%<latexrelease>        \exp_after:wN \cs_gset_nopar:Npn
%<latexrelease>          \cs:w g_@@_#1_code_prop \exp_args:NNo \exp_args:No
%<latexrelease>            \cs_end: { \cs:w g_@@_#1_code_prop \cs_end: }
%<latexrelease>        \@@_tmp:w { _toplevel } {#1}
%<latexrelease>        \@@_tmp:w { _next } {#1}
%<latexrelease>      }
%<latexrelease>  }
\ExplSyntaxOff
%</2ekernel|latexrelease>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=>
%    \end{macrocode}
%
% \Finale
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\endinput

^^A  Needed for emacs
^^A
^^A  Local Variables: 
^^A  mode: latex
^^A  coding: utf-8-unix
^^A  End: 
